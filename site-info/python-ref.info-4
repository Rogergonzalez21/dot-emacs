This is python-ref.info, produced by makeinfo version 4.3 from
python-ref.texi.

October 3, 2003


File: python-ref.info,  Node: Slicings,  Next: Calls,  Prev: Subscriptions,  Up: Primaries

Slicings
--------

A slicing selects a range of items in a sequence object (e.g., a
string, tuple or list).  Slicings may be used as expressions or as
targets in assignment or del statements.  The syntax for a slicing:

`slicing `simple_slicing' | `extended_slicing''

`simple_slicing `primary' "[" `short_slice' "]"'

`extended_slicing `primary' "[" `slice_list' "]"'

`slice_list `slice_item' ("," `slice_item')* [","]'

`slice_item `expression' | `proper_slice' | `ellipsis''

`proper_slice `short_slice' | `long_slice''

`short_slice [`lower_bound'] ":" [`upper_bound']'

`long_slice `short_slice' ":" [`stride']'

`lower_bound `expression''

`upper_bound `expression''

`stride `expression''

`ellipsis "..."'
There is ambiguity in the formal syntax here: anything that looks like
an expression list also looks like a slice list, so any subscription
can be interpreted as a slicing.  Rather than further complicating the
syntax, this is disambiguated by defining that in this case the
interpretation as a subscription takes priority over the interpretation
as a slicing (this is the case if the slice list contains no proper
slice nor ellipses).  Similarly, when the slice list has exactly one
short slice and no trailing comma, the interpretation as a simple
slicing takes priority over that as an extended slicing.

The semantics for a simple slicing are as follows.  The primary must
evaluate to a sequence object.  The lower and upper bound expressions,
if present, must evaluate to plain integers; defaults are zero and the
`sys.maxint', respectively.  If either bound is negative, the
sequence's length is added to it.  The slicing now selects all items
with index K such that `I <= K < J' where I and J are the specified
lower and upper bounds.  This may be an empty sequence.  It is not an
error if I or J lie outside the range of valid indexes (such items
don't exist so they aren't selected).

The semantics for an extended slicing are as follows.  The primary must
evaluate to a mapping object, and it is indexed with a key that is
constructed from the slice list, as follows.  If the slice list
contains at least one comma, the key is a tuple containing the
conversion of the slice items; otherwise, the conversion of the lone
slice item is the key.  The conversion of a slice item that is an
expression is that expression.  The conversion of an ellipsis slice
item is the built-in `Ellipsis' object.  The conversion of a proper
slice is a slice object (see section *Note standard type hierarchy::)
whose `start', `stop' and `step' attributes are the values of the
expressions given as lower bound, upper bound and stride, respectively,
substituting `None' for missing expressions.


File: python-ref.info,  Node: Calls,  Prev: Slicings,  Up: Primaries

Calls
-----

A call calls a callable object (e.g., a function) with a possibly empty
series of arguments:

`call `primary' "(" [`argument_list' [","]] ")"'

`argument_list `positional_arguments' ["," `keyword_arguments']'

`                      ["," "*" `expression']'

`                      ["," "**" `expression']'

` | `keyword_arguments' ["," "*" `expression']'

`                     ["," "**" `expression']'

` | "*" `expression' ["," "**" `expression']'

` | "**" `expression''

`positional_arguments `expression' ("," `expression')*'

`keyword_arguments `keyword_item' ("," `keyword_item')*'

`keyword_item `identifier' "=" `expression''
A trailing comma may be present after an argument list but does not
affect the semantics.

The primary must evaluate to a callable object (user-defined functions,
built-in functions, methods of built-in objects, class objects, methods
of class instances, and certain class instances themselves are
callable; extensions may define additional callable object types).  All
argument expressions are evaluated before the call is attempted.
Please refer to section *Note Function definitions:: for the syntax of
formal parameter lists.

If keyword arguments are present, they are first converted to
positional arguments, as follows.  First, a list of unfilled slots is
created for the formal parameters.  If there are N positional
arguments, they are placed in the first N slots.  Next, for each
keyword argument, the identifier is used to determine the corresponding
slot (if the identifier is the same as the first formal parameter name,
the first slot is used, and so on).  If the slot is already filled, a
`TypeError' exception is raised.  Otherwise, the value of the argument
is placed in the slot, filling it (even if the expression is `None', it
fills the slot).  When all arguments have been processed, the slots
that are still unfilled are filled with the corresponding default value
from the function definition.  (Default values are calculated, once,
when the function is defined; thus, a mutable object such as a list or
dictionary used as default value will be shared by all calls that don't
specify an argument value for the corresponding slot; this should
usually be avoided.)  If there are any unfilled slots for which no
default value is specified, a `TypeError' exception is raised.
Otherwise, the list of filled slots is used as the argument list for
the call.

If there are more positional arguments than there are formal parameter
slots, a `TypeError' exception is raised, unless a formal parameter
using the syntax `*identifier' is present; in this case, that formal
parameter receives a tuple containing the excess positional arguments
(or an empty tuple if there were no excess positional arguments).

If any keyword argument does not correspond to a formal parameter name,
a `TypeError' exception is raised, unless a formal parameter using the
syntax `**identifier' is present; in this case, that formal parameter
receives a dictionary containing the excess keyword arguments (using
the keywords as keys and the argument values as corresponding values),
or a (new) empty dictionary if there were no excess keyword arguments.

If the syntax `*expression' appears in the function call, `expression'
must evaluate to a sequence.  Elements from this sequence are treated
as if they were additional positional arguments; if there are postional
arguments X1,...,XN , and `expression' evaluates to a sequence
Y1,...,YM, this is equivalent to a call with M+N positional arguments
X1,...,XN,Y1,...,YM.

A consequence of this is that although the `*expression' syntax appears
_after_ any keyword arguments, it is processed _before_ the keyword
arguments (and the `**expression' argument, if any - see below).  So:

     >>> def f(a, b):
     ...  print a, b
     ...
     >>> f(b=1, *(2,))
     2 1
     >>> f(a=1, *(2,))
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: f() got multiple values for keyword argument 'a'
     >>> f(1, *(2,))
     1 2

It is unusual for both keyword arguments and the `*expression' syntax
to be used in the same call, so in practice this confusion does not
arise.

If the syntax `**expression' appears in the function call, `expression'
must evaluate to a (subclass of) dictionary, the contents of which are
treated as additional keyword arguments.  In the case of a keyword
appearing in both `expression' and as an explicit keyword argument, a
`TypeError' exception is raised.

Formal parameters using the syntax `*identifier' or `**identifier'
cannot be used as positional argument slots or as keyword argument
names.  Formal parameters using the syntax `(sublist)' cannot be used
as keyword argument names; the outermost sublist corresponds to a
single unnamed argument slot, and the argument value is assigned to the
sublist using the usual tuple assignment rules after all other
parameter processing is done.

A call always returns some value, possibly `None', unless it raises an
exception.  How this value is computed depends on the type of the
callable object.

If it is--

`a user-defined function:'
     The code block for the function is executed, passing it the
     argument list.  The first thing the code block will do is bind the
     formal parameters to the arguments; this is described in section
     *Note Function definitions::.  When the code block executes a
     `return' statement, this specifies the return value of the
     function call.

`a built-in function or method:'
     The result is up to the interpreter; see the  for the descriptions
     of built-in functions and methods.

`a class object:'
     A new instance of that class is returned.

`a class instance method:'
     The corresponding user-defined function is called, with an
     argument list that is one longer than the argument list of the
     call: the instance becomes the first argument.

`a class instance:'
     The class must define a `__call__()' method; the effect is then
     the same as if that method was called.


File: python-ref.info,  Node: power operator,  Next: Unary arithmetic operations,  Prev: Primaries,  Up: Expressions

The power operator
==================

The power operator binds more tightly than unary operators on its left;
it binds less tightly than unary operators on its right.  The syntax is:

`power `primary' ["**" `u_expr']'
Thus, in an unparenthesized sequence of power and unary operators, the
operators are evaluated from right to left (this does not constrain the
evaluation order for the operands).

The power operator has the same semantics as the built-in `pow()'
function, when called with two arguments: it yields its left argument
raised to the power of its right argument.  The numeric arguments are
first converted to a common type.  The result type is that of the
arguments after coercion.

With mixed operand types, the coercion rules for binary arithmetic
operators apply. For int and long int operands, the result has the same
type as the operands (after coercion) unless the second argument is
negative; in that case, all arguments are converted to float and a
float result is delivered. For example, `10**2' returns `100', but
`10**-2' returns `0.01'. (This last feature was added in Python 2.2. In
Python 2.1 and before, if both arguments were of integer types and the
second argument was negative, an exception was raised).

Raising `0.0' to a negative power results in a `ZeroDivisionError'.
Raising a negative number to a fractional power results in a
`ValueError'.


File: python-ref.info,  Node: Unary arithmetic operations,  Next: Binary arithmetic operations,  Prev: power operator,  Up: Expressions

Unary arithmetic operations
===========================

All unary arithmetic (and bit-wise) operations have the same priority:

`u_expr `power' | "-" `u_expr' | "+" `u_expr' | "{~}" `u_expr''
The unary `-' (minus) operator yields the negation of its numeric
argument.

The unary `+' (plus) operator yields its numeric argument unchanged.

The unary `~' (invert) operator yields the bit-wise inversion of its
plain or long integer argument.  The bit-wise inversion of `x' is
defined as `-(x+1)'.  It only applies to integral numbers.

In all three cases, if the argument does not have the proper type, a
`TypeError' exception is raised.


File: python-ref.info,  Node: Binary arithmetic operations,  Next: Shifting operations,  Prev: Unary arithmetic operations,  Up: Expressions

Binary arithmetic operations
============================

The binary arithmetic operations have the conventional priority levels.
Note that some of these operations also apply to certain non-numeric
types.  Apart from the power operator, there are only two levels, one
for multiplicative operators and one for additive operators:

`m_expr `u_expr' | `m_expr' "*" `u_expr' | `m_expr' "//" `u_expr' | `m_expr' "/" `u_expr''

` | `m_expr' "%" `u_expr''

`a_expr `m_expr' | `a_expr' "+" `m_expr' | `a_expr' "-" `m_expr''
The `*' (multiplication) operator yields the product of its arguments.
The arguments must either both be numbers, or one argument must be an
integer (plain or long) and the other must be a sequence.  In the
former case, the numbers are converted to a common type and then
multiplied together.  In the latter case, sequence repetition is
performed; a negative repetition factor yields an empty sequence.

The `/' (division) and `//' (floor division) operators yield the
quotient of their arguments.  The numeric arguments are first converted
to a common type.  Plain or long integer division yields an integer of
the same type; the result is that of mathematical division with the
`floor' function applied to the result.  Division by zero raises the
`ZeroDivisionError' exception.

The `%' (modulo) operator yields the remainder from the division of the
first argument by the second.  The numeric arguments are first
converted to a common type.  A zero right argument raises the
`ZeroDivisionError' exception.  The arguments may be floating point
numbers, e.g., `3.14%0.7' equals `0.34' (since `3.14' equals `4*0.7 +
0.34'.)  The modulo operator always yields a result with the same sign
as its second operand (or zero); the absolute value of the result is
strictly smaller than the absolute value of the second operand(1).

The integer division and modulo operators are connected by the
following identity: `x == (x/y)*y + (x%y)'.  Integer division and
modulo are also connected with the built-in function `divmod()':
`divmod(x, y) == (x/y, x%y)'.  These identities don't hold for floating
point numbers; there similar identities hold approximately where `x/y'
is replaced by `floor(x/y)' or `floor(x/y) - 1'(2).

_This is deprecated in Python 2.3.  The floor division operator, the
modulo operator, and the `divmod()' function are no longer defined for
complex numbers.  Instead, convert to a floating point number using the
`abs()' function if appropriate._

The `+' (addition) operator yields the sum of its arguments.  The
arguments must either both be numbers or both sequences of the same
type.  In the former case, the numbers are converted to a common type
and then added together.  In the latter case, the sequences are
concatenated.

The `-' (subtraction) operator yields the difference of its arguments.
The numeric arguments are first converted to a common type.

---------- Footnotes ----------

(1)  While `abs(x%y) < abs(y)' is true mathematically, for floats it
may not be true numerically due to roundoff.  For example, and assuming
a platform on which a Python float is an IEEE 754 double-precision
number, in order that `-1e-100 % 1e100' have the same sign as `1e100',
the computed result is `-1e-100 + 1e100', which is numerically exactly
equal to `1e100'.  Function `fmod()' in the `math' module returns a
result whose sign matches the sign of the first argument instead, and
so returns `-1e-100' in this case. Which approach is more appropriate
depends on the application.

(2)  If x is very close to an exact integer multiple of y, it's
possible for `floor(x/y)' to be one larger than `(x-x%y)/y' due to
rounding.  In such cases, Python returns the latter result, in order to
preserve that `divmod(x,y)[0] * y + x %{} y' be very close to `x'.


File: python-ref.info,  Node: Shifting operations,  Next: Binary bit-wise operations,  Prev: Binary arithmetic operations,  Up: Expressions

Shifting operations
===================

The shifting operations have lower priority than the arithmetic
operations:

`shift_expr `a_expr' | `shift_expr' ( "<<" | ">>" ) `a_expr''
These operators accept plain or long integers as arguments.  The
arguments are converted to a common type.  They shift the first
argument to the left or right by the number of bits given by the second
argument.

A right shift by N bits is defined as division by `pow(2,N)'.  A left
shift by N bits is defined as multiplication with `pow(2,N)'; for plain
integers there is no overflow check so in that case the operation drops
bits and flips the sign if the result is not less than `pow(2,31)' in
absolute value.  Negative shift counts raise a `ValueError' exception.


File: python-ref.info,  Node: Binary bit-wise operations,  Next: Comparisons,  Prev: Shifting operations,  Up: Expressions

Binary bit-wise operations
==========================

Each of the three bitwise operations has a different priority level:

`and_expr `shift_expr' | `and_expr' "&" `shift_expr''

`xor_expr `and_expr' | `xor_expr' "^" `and_expr''

`or_expr `xor_expr' | `or_expr' "|" `xor_expr''
The `&' operator yields the bitwise AND of its arguments, which must be
plain or long integers.  The arguments are converted to a common type.

The `^' operator yields the bitwise XOR (exclusive OR) of its
arguments, which must be plain or long integers.  The arguments are
converted to a common type.

The `|' operator yields the bitwise (inclusive) OR of its arguments,
which must be plain or long integers.  The arguments are converted to a
common type.


File: python-ref.info,  Node: Comparisons,  Next: Boolean operations,  Prev: Binary bit-wise operations,  Up: Expressions

Comparisons
===========

Unlike C, all comparison operations in Python have the same priority,
which is lower than that of any arithmetic, shifting or bitwise
operation.  Also unlike C, expressions like `a < b < c' have the
interpretation that is conventional in mathematics:

`comparison `or_expr' ( `comp_operator' `or_expr' )*'

`comp_operator "<" | ">" | "==" | ">=" | "<=" | "<>" | "!="'

` | "is" ["not"] | ["not"] "in"'
Comparisons yield boolean values: `True' or `False'.

Comparisons can be chained arbitrarily, e.g., `x < y <= z' is
equivalent to `x < y and y <= z', except that `y' is evaluated only
once (but in both cases `z' is not evaluated at all when `x < y' is
found to be false).

Formally, if A, B, C, ..., Y, Z are expressions and OPA, OPB, ..., OPY
are comparison operators, then A OPA B OPB C ...Y OPY Z is equivalent
to A OPA B `and' B OPB C `and' ...  Y OPY Z, except that each
expression is evaluated at most once.

Note that A OPA B OPB C doesn't imply any kind of comparison between A
and C, so that, e.g., `x < y > z' is perfectly legal (though perhaps
not pretty).

The forms `<>' and `!=' are equivalent; for consistency with C, `!=' is
preferred; where `!=' is mentioned below `<>' is also accepted.  The
`<>' spelling is considered obsolescent.

The operators `<', `>', `==', `>=', `<=', and `!=' compare the values
of two objects.  The objects need not have the same type.  If both are
numbers, they are converted to a common type.  Otherwise, objects of
different types _always_ compare unequal, and are ordered consistently
but arbitrarily.

(This unusual definition of comparison was used to simplify the
definition of operations like sorting and the `in' and `not in'
operators.  In the future, the comparison rules for objects of
different types are likely to change.)

Comparison of objects of the same type depends on the type:

   * Numbers are compared arithmetically.

   * Strings are compared lexicographically using the numeric
     equivalents (the result of the built-in function `ord()') of their
     characters.  Unicode and 8-bit strings are fully interoperable in
     this behavior.

   * Tuples and lists are compared lexicographically using comparison of
     corresponding elements.  This means that to compare equal, each
     element must compare equal and the two sequences must be of the
     same type and have the same length.

     If not equal, the sequences are ordered the same as their first
     differing elements.  For example, `cmp([1,2,x], [1,2,y])' returns
     the same as `cmp(x,y)'.  If the corresponding element does not
     exist, the shorter sequence is ordered first (for example, `[1,2]
     < [1,2,3]').

   * Mappings (dictionaries) compare equal if and only if their sorted
     (key, value) lists compare equal.(1) Outcomes other than equality
     are resolved consistently, but are not otherwise defined.(2)

   * Most other types compare unequal unless they are the same object;
     the choice whether one object is considered smaller or larger than
     another one is made arbitrarily but consistently within one
     execution of a program.


The operators `in' and `not in' test for set membership.  `X in S'
evaluates to true if X is a member of the set S, and false otherwise.
`X not in S' returns the negation of `X in S'.  The set membership test
has traditionally been bound to sequences; an object is a member of a
set if the set is a sequence and contains an element equal to that
object.  However, it is possible for an object to support membership
tests without being a sequence.  In particular, dictionaries support
memership testing as a nicer way of spelling `KEY in DICT'; other
mapping types may follow suit.

For the list and tuple types, `X in Y' is true if and only if there
exists an index I such that `X == Y[I]' is true.

For the Unicode and string types, `X in Y' is true if and only if X is
a substring of Y.  An equivalent test is `y.find(x) != -1'.  Note, X
and Y need not be the same type; consequently, `u'ab' in 'abc'' will
return `True'.  Empty strings are always considered to be a substring
of any other string, so `"" in "abc"' will return `True'.  _Changed in
Python version 2.3_

For user-defined classes which define the `__contains__()' method, `X
in Y' is true if and only if `Y.__contains__(X)' is true.

For user-defined classes which do not define `__contains__()' and do
define `__getitem__()', `X in Y' is true if and only if there is a
non-negative integer index I such that `X == Y[I]', and all lower
integer indices do not raise `IndexError' exception. (If any other
exception is raised, it is as if `in' raised that exception).

The operator `not in' is defined to have the inverse true value of `in'.

The operators `is' and `is not' test for object identity: `X is Y' is
true if and only if X and Y are the same object.  `X is not Y' yields
the inverse truth value.

---------- Footnotes ----------

(1) The implementation computes this efficiently, without constructing
lists or sorting.

(2) Earlier versions of Python used lexicographic comparison of the
sorted (key, value) lists, but this was very expensive for the common
case of comparing for equality.  An even earlier version of Python
compared dictionaries by identity only, but this caused surprises
because people expected to be able to test a dictionary for emptiness
by comparing it to `{}'.


File: python-ref.info,  Node: Boolean operations,  Next: Lambdas,  Prev: Comparisons,  Up: Expressions

Boolean operations
==================

Boolean operations have the lowest priority of all Python operations:

`expression `or_test' | `lambda_form''

`or_test `and_test' | `or_test' "or" `and_test''

`and_test `not_test' | `and_test' "and" `not_test''

`not_test `comparison' | "not" `not_test''

`lambda_form "lambda" [`parameter_list']: `expression''
In the context of Boolean operations, and also when expressions are
used by control flow statements, the following values are interpreted
as false: `None', numeric zero of all types, empty sequences (strings,
tuples and lists), and empty mappings (dictionaries).  All other values
are interpreted as true.

The operator `not' yields `1' if its argument is false, `0' otherwise.

The expression `X and Y' first evaluates X; if X is false, its value is
returned; otherwise, Y is evaluated and the resulting value is returned.

The expression `X or Y' first evaluates X; if X is true, its value is
returned; otherwise, Y is evaluated and the resulting value is returned.

(Note that neither `and' nor `or' restrict the value and type they
return to `0' and `1', but rather return the last evaluated argument.
This is sometimes useful, e.g., if `s' is a string that should be
replaced by a default value if it is empty, the expression `s or 'foo''
yields the desired value.  Because `not' has to invent a value anyway,
it does not bother to return a value of the same type as its argument,
so e.g., `not 'foo'' yields `0', not `'''.)


File: python-ref.info,  Node: Lambdas,  Next: Expression lists,  Prev: Boolean operations,  Up: Expressions

Lambdas
=======

Lambda forms (lambda expressions) have the same syntactic position as
expressions.  They are a shorthand to create anonymous functions; the
expression `lambda ARGUMENTS: EXPRESSION' yields a function object.
The unnamed object behaves like a function object defined with

     def name(arguments):
         return expression

See section *Note Function definitions:: for the syntax of parameter
lists.  Note that functions created with lambda forms cannot contain
statements.


File: python-ref.info,  Node: Expression lists,  Next: Evaluation order,  Prev: Lambdas,  Up: Expressions

Expression lists
================

`expression_list `expression' ( "," `expression' )* [","]'
An expression list containing at least one comma yields a tuple.  The
length of the tuple is the number of expressions in the list.  The
expressions are evaluated from left to right.

The trailing comma is required only to create a single tuple (a.k.a. a
_singleton_); it is optional in all other cases.  A single expression
without a trailing comma doesn't create a tuple, but rather yields the
value of that expression.  (To create an empty tuple, use an empty pair
of parentheses: `()'.)


File: python-ref.info,  Node: Evaluation order,  Next: Summary,  Prev: Expression lists,  Up: Expressions

Evaluation order
================

Python evaluates expressions from left to right. Notice that while
evaluating an assignment, the right-hand side is evaluated before the
left-hand side.

In the following lines, expressions will be evaluated in the arithmetic
order of their suffixes:

     expr1, expr2, expr3, expr4
     (expr1, expr2, expr3, expr4)
     {expr1: expr2, expr3: expr4}
     expr1 + expr2 * (expr3 - expr4)
     func(expr1, expr2, *expr3, **expr4)
     expr3, expr4 = expr1, expr2


File: python-ref.info,  Node: Summary,  Prev: Evaluation order,  Up: Expressions

Summary
=======

The following table summarizes the operator precedences  in Python,
from lowest precedence (least binding) to highest precedence (most
binding).  Operators in the same box have the same precedence.  Unless
the syntax is explicitly given, operators are binary.  Operators in the
same box group left to right (except for comparisons, which chain from
left to right -- see above, and exponentiation, which groups from right
to left).

Operator                             Description
------                               -----
`lambda'                             Lambda expression
`or'                                 Boolean OR
`and'                                Boolean AND
`not' X                              Boolean NOT
`in', `not' `in'                     Membership tests
`is', `is not'                       Identity tests
`<', `<=', `>', `>=', `<>', `!=',    Comparisons
`=='                                 
`|'                                  Bitwise OR
`^'                                  Bitwise XOR
`&'                                  Bitwise AND
`<'`<', `>'`>'                       Shifts
`+', `-'                             Addition and subtraction
`*', `/', `%'                        Multiplication, division, remainder
`+X', `-X'                           Positive, negative
`~X'                                 Bitwise not
`**'                                 Exponentiation
`X.ATTRIBUTE'                        Attribute reference
`X[INDEX]'                           Subscription
`X[INDEX:INDEX]'                     Slicing
`F(ARGUMENTS...)'                    Function call
`(EXPRESSIONS...)'                   Binding or tuple display
`[EXPRESSIONS...]'                   List display
`{KEY:DATUM...}'                     Dictionary display
``EXPRESSIONS...`'                   String conversion


File: python-ref.info,  Node: Simple statements,  Next: Compound statements,  Prev: Expressions,  Up: Top

Simple statements
*****************

Simple statements are comprised within a single logical line.  Several
simple statements may occur on a single line separated by semicolons.
The syntax for simple statements is:

`simple_stmt `expression_stmt''

` | `assert_stmt''

` | `assignment_stmt''

` | `augmented_assignment_stmt''

` | `pass_stmt''

` | `del_stmt''

` | `print_stmt''

` | `return_stmt''

` | `yield_stmt''

` | `raise_stmt''

` | `break_stmt''

` | `continue_stmt''

` | `import_stmt''

` | `global_stmt''

` | `exec_stmt''
* Menu:

* Expression statements::
* Assert statements::
* Assignment statements::
* pass statement::
* del statement::
* print statement::
* return statement::
* yield statement::
* raise statement::
* break statement::
* continue statement::
* import statement::
* global statement::
* exec statement::


File: python-ref.info,  Node: Expression statements,  Next: Assert statements,  Prev: Simple statements,  Up: Simple statements

Expression statements
=====================

Expression statements are used (mostly interactively) to compute and
write a value, or (usually) to call a procedure (a function that
returns no meaningful result; in Python, procedures return the value
`None').  Other uses of expression statements are allowed and
occasionally useful.  The syntax for an expression statement is:

`expression_stmt `expression_list''
An expression statement evaluates the expression list (which may be a
single expression).

In interactive mode, if the value is not `None', it is converted to a
string using the built-in `repr()' function and the resulting string is
written to standard output (see section~*Note print statement::) on a
line by itself.  (Expression statements yielding `None' are not
written, so that procedure calls do not cause any output.)


File: python-ref.info,  Node: Assert statements,  Next: Assignment statements,  Prev: Expression statements,  Up: Simple statements

Assert statements
=================

Assert statements  are a convenient way to insert debugging assertions
into a program:

`assert_stmt "assert" `expression' ["," `expression']'
The simple form, `assert expression', is equivalent to

     if __debug__:
        if not expression: raise AssertionError

The extended form, `assert expression1, expression2', is equivalent to

     if __debug__:
        if not expression1: raise AssertionError, expression2

These equivalences assume that `__debug__'  and `AssertionError'  refer
to the built-in variables with those names.  In the current
implementation, the built-in variable `__debug__' is 1 under normal
circumstances, 0 when optimization is requested (command line option
-O).  The current code generator emits no code for an assert statement
when optimization is requested at compile time.  Note that it is
unnecessary to include the source code for the expression that failed
in the error message; it will be displayed as part of the stack trace.

Assignments to `__debug__' are illegal.  The value for the built-in
variable is determined when the interpreter starts.


File: python-ref.info,  Node: Assignment statements,  Next: pass statement,  Prev: Assert statements,  Up: Simple statements

Assignment statements
=====================

Assignment statements  are used to (re)bind names to values and to
modify attributes or items of mutable objects:

`assignment_stmt (`target_list' "=")+ `expression_list''

`target_list `target' ("," `target')* [","]'

`target `identifier''

` | "(" `target_list' ")"'

` | "[" `target_list' "]"'

` | `attributeref''

` | `subscription''

` | `slicing''
(See section~*Note Primaries:: for the syntax definitions for the last
three symbols.)

An assignment statement evaluates the expression list (remember that
this can be a single expression or a comma-separated list, the latter
yielding a tuple) and assigns the single resulting object to each of
the target lists, from left to right.

Assignment is defined recursively depending on the form of the target
(list).  When a target is part of a mutable object (an attribute
reference, subscription or slicing), the mutable object must ultimately
perform the assignment and decide about its validity, and may raise an
exception if the assignment is unacceptable.  The rules observed by
various types and the exceptions raised are given with the definition
of the object types (see section~*Note standard type hierarchy::).

Assignment of an object to a target list is recursively defined as
follows.

   * If the target list is a single target: The object is assigned to
     that target.

   * If the target list is a comma-separated list of targets: The object
     must be a sequence with the same number of items as the there are
     targets in the target list, and the items are assigned, from left
     to right, to the corresponding targets.  (This rule is relaxed as
     of Python 1.5; in earlier versions, the object had to be a tuple.
     Since strings are sequences, an assignment like `a, b = "xy"' is
     now legal as long as the string has the right length.)


Assignment of an object to a single target is recursively defined as
follows.

   * If the target is an identifier (name):

        * If the name does not occur in a `global' statement in the
          current code block: the name is bound to the object in the
          current local namespace.

        * Otherwise: the name is bound to the object in the current
          global namespace.


     The name is rebound if it was already bound.  This may cause the
     reference count for the object previously bound to the name to
     reach zero, causing the object to be deallocated and its destructor
     (if it has one) to be called.

   * If the target is a target list enclosed in parentheses or in square
     brackets: The object must be a sequence with the same number of
     items as there are targets in the target list, and its items are
     assigned, from left to right, to the corresponding targets.

   * If the target is an attribute reference: The primary expression in
     the reference is evaluated.  It should yield an object with
     assignable attributes; if this is not the case, `TypeError' is
     raised.  That object is then asked to assign the assigned object
     to the given attribute; if it cannot perform the assignment, it
     raises an exception (usually but not necessarily `AttributeError').

   * If the target is a subscription: The primary expression in the
     reference is evaluated.  It should yield either a mutable sequence
     object (e.g., a list) or a mapping object (e.g., a dictionary).
     Next, the subscript expression is evaluated.

     If the primary is a mutable sequence object (e.g., a list), the
     subscript must yield a plain integer.  If it is negative, the
     sequence's length is added to it.  The resulting value must be a
     nonnegative integer less than the sequence's length, and the
     sequence is asked to assign the assigned object to its item with
     that index.  If the index is out of range, `IndexError' is raised
     (assignment to a subscripted sequence cannot add new items to a
     list).

     If the primary is a mapping object (e.g., a dictionary), the
     subscript must have a type compatible with the mapping's key type,
     and the mapping is then asked to create a key/datum pair which
     maps the subscript to the assigned object.  This can either
     replace an existing key/value pair with the same key value, or
     insert a new key/value pair (if no key with the same value
     existed).

   * If the target is a slicing: The primary expression in the
     reference is evaluated.  It should yield a mutable sequence object
     (e.g., a list).  The assigned object should be a sequence object
     of the same type.  Next, the lower and upper bound expressions are
     evaluated, insofar they are present; defaults are zero and the
     sequence's length.  The bounds should evaluate to (small)
     integers.  If either bound is negative, the sequence's length is
     added to it.  The resulting bounds are clipped to lie between zero
     and the sequence's length, inclusive.  Finally, the sequence
     object is asked to replace the slice with the items of the
     assigned sequence.  The length of the slice may be different from
     the length of the assigned sequence, thus changing the length of
     the target sequence, if the object allows it.


(In the current implementation, the syntax for targets is taken to be
the same as for expressions, and invalid syntax is rejected during the
code generation phase, causing less detailed error messages.)

WARNING: Although the definition of assignment implies that overlaps
between the left-hand side and the right-hand side are `safe' (e.g.,
`a, b = b, a' swaps two variables), overlaps _within_ the collection of
assigned-to variables are not safe!  For instance, the following
program prints `[0, 2]':

     x = [0, 1]
     i = 0
     i, x[i] = 1, 2
     print x

* Menu:

* Augmented assignment statements::


File: python-ref.info,  Node: Augmented assignment statements,  Prev: Assignment statements,  Up: Assignment statements

Augmented assignment statements
-------------------------------

Augmented assignment is the combination, in a single statement, of a
binary operation and an assignment statement:

`augmented_assignment_stmt `target' `augop' `expression_list''

`augop "+=" | "-=" | "*=" | "/=" | "%=" | "**="'

` | ">>=" | "<<=" | "&=" | "^=" | "|="'
(See section~*Note Primaries:: for the syntax definitions for the last
three symbols.)

An augmented assignment evaluates the target (which, unlike normal
assignment statements, cannot be an unpacking) and the expression list,
performs the binary operation specific to the type of assignment on the
two operands, and assigns the result to the original target.  The
target is only evaluated once.

An augmented assignment expression like `x += 1' can be rewritten as `x
= x + 1' to achieve a similar, but not exactly equal effect. In the
augmented version, `x' is only evaluated once. Also, when possible, the
actual operation is performed _in-place_, meaning that rather than
creating a new object and assigning that to the target, the old object
is modified instead.

With the exception of assigning to tuples and multiple targets in a
single statement, the assignment done by augmented assignment
statements is handled the same way as normal assignments. Similarly,
with the exception of the possible _in-place_ behavior, the binary
operation performed by augmented assignment is the same as the normal
binary operations.

For targets which are attribute references, the initial value is
retrieved with a `getattr()' and the result is assigned with a
`setattr()'.  Notice that the two methods do not necessarily refer to
the same variable.  When `getattr()' refers to a class variable,
`setattr()' still writes to an instance variable.  For example:

     class A:
         x = 3    # class variable
     a = A()
     a.x += 1     # writes a.x as 4 leaving A.x as 3


File: python-ref.info,  Node: pass statement,  Next: del statement,  Prev: Assignment statements,  Up: Simple statements

The `pass' statement
====================

`pass_stmt "pass"'
`pass' is a null operation -- when it is executed, nothing happens.  It
is useful as a placeholder when a statement is required syntactically,
but no code needs to be executed, for example:

     def f(arg): pass    # a function that does nothing (yet)
     
     class C: pass       # a class with no methods (yet)


File: python-ref.info,  Node: del statement,  Next: print statement,  Prev: pass statement,  Up: Simple statements

The `del' statement
===================

`del_stmt "del" `target_list''
Deletion is recursively defined very similar to the way assignment is
defined. Rather that spelling it out in full details, here are some
hints.

Deletion of a target list recursively deletes each target, from left to
right.

Deletion of a name removes the binding of that name from the local or
global namespace, depending on whether the name occurs in a `global'
statement in the same code block.  If the name is unbound, a
`NameError' exception will be raised.

It is illegal to delete a name from the local namespace if it occurs as
a free variable  in a nested block.

Deletion of attribute references, subscriptions and slicings is passed
to the primary object involved; deletion of a slicing is in general
equivalent to assignment of an empty slice of the right type (but even
this is determined by the sliced object).


File: python-ref.info,  Node: print statement,  Next: return statement,  Prev: del statement,  Up: Simple statements

The `print' statement
=====================

`print_stmt "print" ( [`expression' ("," `expression')* [","]]'

` | ">`>'" `expression' [("," `expression')+ [","]] )'
`print' evaluates each expression in turn and writes the resulting
object to standard output (see below).  If an object is not a string,
it is first converted to a string using the rules for string
conversions.  The (resulting or original) string is then written.  A
space is written before each object is (converted and) written, unless
the output system believes it is positioned at the beginning of a line.
This is the case (1) when no characters have yet been written to
standard output, (2) when the last character written to standard output
is `\n', or (3) when the last write operation on standard output was
not a `print' statement.  (In some cases it may be functional to write
an empty string to standard output for this reason.)  _Note:_ Objects
which act like file objects but which are not the built-in file objects
often do not properly emulate this aspect of the file object's
behavior, so it is best not to rely on this.

A `\n' character is written at the end, unless the `print' statement
ends with a comma.  This is the only action if the statement contains
just the keyword `print'.

Standard output is defined as the file object named `stdout' in the
built-in module `sys'.  If no such object exists, or if it does not
have a `write()' method, a `RuntimeError' exception is raised.

`print' also has an extended form, defined by the second portion of the
syntax described above.  This form is sometimes referred to as "`print'
chevron."  In this form, the first expression after the `>'`>' must
evaluate to a "file-like" object, specifically an object that has a
`write()' method as described above.  With this extended form, the
subsequent expressions are printed to this file object.  If the first
expression evaluates to `None', then `sys.stdout' is used as the file
for output.


File: python-ref.info,  Node: return statement,  Next: yield statement,  Prev: print statement,  Up: Simple statements

The `return' statement
======================

`return_stmt "return" [`expression_list']'
`return' may only occur syntactically nested in a function definition,
not within a nested class definition.

If an expression list is present, it is evaluated, else `None' is
substituted.

`return' leaves the current function call with the expression list (or
`None') as return value.

When `return' passes control out of a `try' statement with a `finally'
clause, that `finally' clause is executed before really leaving the
function.

In a generator function, the `return' statement is not allowed to
include an `expression_list'.  In that context, a bare `return'
indicates that the generator is done and will cause `StopIteration' to
be raised.


File: python-ref.info,  Node: yield statement,  Next: raise statement,  Prev: return statement,  Up: Simple statements

The `yield' statement
=====================

`yield_stmt "yield" `expression_list''
The `yield' statement is only used when defining a generator function,
and is only used in the body of the generator function.  Using a
`yield' statement in a function definition is sufficient to cause that
definition to create a generator function instead of a normal function.

When a generator function is called, it returns an iterator known as a
generator iterator, or more commonly, a generator.  The body of the
generator function is executed by calling the generator's `next()'
method repeatedly until it raises an exception.

When a `yield' statement is executed, the state of the generator is
frozen and the value of `expression_list' is returned to `next()''s
caller.  By "frozen" we mean that all local state is retained,
including the current bindings of local variables, the instruction
pointer, and the internal evaluation stack: enough information is saved
so that the next time `next()' is invoked, the function can proceed
exactly as if the `yield' statement were just another external call.

The `yield' statement is not allowed in the `try' clause of a `try' ...
`finally' construct.  The difficulty is that there's no guarantee the
generator will ever be resumed, hence no guarantee that the `finally'
block will ever get executed.

_Notice:_ In Python 2.2, the `yield' statement is only allowed when the
`generators' feature has been enabled.  It will always be enabled in
Python 2.3.  This `__future__' import statment can be used to enable
the feature:

     from __future__ import generators

See also:
    *PEP0255 Simple Generators*
          The proposal for adding generators and the `yield' statement
          to Python.


File: python-ref.info,  Node: raise statement,  Next: break statement,  Prev: yield statement,  Up: Simple statements

The `raise' statement
=====================

`raise_stmt "raise" [`expression' ["," `expression' ["," `expression']]]'
If no expressions are present, `raise' re-raises the last expression
that was active in the current scope.  If no exception is active in the
current scope, an exception is raised indicating this error.

Otherwise, `raise' evaluates the expressions to get three objects,
using `None' as the value of omitted expressions.  The first two
objects are used to determine the _type_ and _value_ of the exception.

If the first object is an instance, the type of the exception is the
class of the instance, the instance itself is the value, and the second
object must be `None'.

If the first object is a class, it becomes the type of the exception.
The second object is used to determine the exception value: If it is an
instance of the class, the instance becomes the exception value.  If
the second object is a tuple, it is used as the argument list for the
class constructor; if it is `None', an empty argument list is used, and
any other object is treated as a single argument to the constructor.
The instance so created by calling the constructor is used as the
exception value.

If a third object is present and not `None', it must be a traceback
object (see section~*Note standard type hierarchy::), and it is
substituted instead of the current location as the place where the
exception occurred.  If the third object is present and not a traceback
object or `None', a `TypeError' exception is raised.  The
three-expression form of `raise' is useful to re-raise an exception
transparently in an except clause, but `raise' with no expressions
should be preferred if the exception to be re-raised was the most
recently active exception in the current scope.

Additional information on exceptions can be found in section~*Note
Exceptions::, and information about handling exceptions is in
section~*Note try statement::.


File: python-ref.info,  Node: break statement,  Next: continue statement,  Prev: raise statement,  Up: Simple statements

The `break' statement
=====================

`break_stmt "break"'
`break' may only occur syntactically nested in a `for' or `while' loop,
but not nested in a function or class definition within that loop.

It terminates the nearest enclosing loop, skipping the optional `else'
clause if the loop has one.

If a `for' loop is terminated by `break', the loop control target keeps
its current value.

When `break' passes control out of a `try' statement with a `finally'
clause, that `finally' clause is executed before really leaving the
loop.


File: python-ref.info,  Node: continue statement,  Next: import statement,  Prev: break statement,  Up: Simple statements

The `continue' statement
========================

`continue_stmt "continue"'
`continue' may only occur syntactically nested in a `for' or `while'
loop, but not nested in a function or class definition or `try'
statement within that loop.(1) It continues with the next cycle of the
nearest enclosing loop.

---------- Footnotes ----------

(1) It may occur within an `except' or `else' clause.  The restriction
on occurring in the `try' clause is implementor's laziness and will
eventually be lifted.

