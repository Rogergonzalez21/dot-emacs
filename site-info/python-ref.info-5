This is python-ref.info, produced by makeinfo version 4.3 from
python-ref.texi.

October 3, 2003


File: python-ref.info,  Node: import statement,  Next: global statement,  Prev: continue statement,  Up: Simple statements

The `import' statement
======================

`import_stmt "import" `module' ["as" `name'] ( "," `module' ["as" `name'] )*'

` | "from" `module' "import" `identifier' ["as" `name']'

`   ( "," `identifier' ["as" `name'] )*'

` | "from" `module' "import" "*"'

`module (`identifier' ".")* `identifier''
Import statements are executed in two steps: (1) find a module, and
initialize it if necessary; (2) define a name or names in the local
namespace (of the scope where the `import' statement occurs).  The
first form (without `from') repeats these steps for each identifier in
the list.  The form with `from' performs step (1) once, and then
performs step (2) repeatedly.

In this context, to "initialize" a built-in or extension module means to
call an initialization function that the module must provide for the
purpose (in the reference implementation, the function's name is
obtained by prepending string "init" to the module's name); to
"initialize" a Python-coded module means to execute the module's body.

The system maintains a table of modules that have been or are being
initialized, indexed by module name.  This table is accessible as
`sys.modules'.  When a module name is found in this table, step (1) is
finished.  If not, a search for a module definition is started.  When a
module is found, it is loaded.  Details of the module searching and
loading process are implementation and platform specific.  It generally
involves searching for a "built-in" module with the given name and then
searching a list of locations given as `sys.path'.

If a built-in module is found,  its built-in initialization code is
executed and step (1) is finished.  If no matching file is found,
`ImportError'  is raised.  If a file is found, it is parsed, yielding
an executable code block.  If a syntax error occurs, `SyntaxError'  is
raised.  Otherwise, an empty module of the given name is created and
inserted in the module table, and then the code block is executed in
the context of this module.  Exceptions during this execution terminate
step (1).

When step (1) finishes without raising an exception, step (2) can begin.

The first form of `import' statement binds the module name in the local
namespace to the module object, and then goes on to import the next
identifier, if any.  If the module name is followed by `as', the name
following `as' is used as the local name for the module.

The `from' form does not bind the module name: it goes through the list
of identifiers, looks each one of them up in the module found in step
(1), and binds the name in the local namespace to the object thus found.
As with the first form of `import', an alternate local name can be
supplied by specifying "`as' localname".  If a name is not found,
`ImportError' is raised.  If the list of identifiers is replaced by a
star (`*'), all public names defined in the module are bound in the
local namespace of the `import' statement..

The _public names_ defined by a module are determined by checking the
module's namespace for a variable named `__all__'; if defined, it must
be a sequence of strings which are names defined or imported by that
module.  The names given in `__all__' are all considered public and are
required to exist.  If `__all__' is not defined, the set of public
names includes all names found in the module's namespace which do not
begin with an underscore character (`_').  `__all__' should contain the
entire public API.  It is intended to avoid accidentally exporting
items that are not part of the API (such as library modules which were
imported and used within the module).

The `from' form with `*' may only occur in a module scope.  If the wild
card form of import -- `import *' -- is used in a function and the
function contains or is a nested block with free variables, the
compiler will raise a `SyntaxError'.

*Hierarchical module names:* when the module names contains one or more
dots, the module search path is carried out differently.  The sequence
of identifiers up to the last dot is used to find a "package" ; the
final identifier is then searched inside the package.  A package is
generally a subdirectory of a directory on `sys.path' that has a file
`__init__.py'.  [XXX Can't be bothered to spell this out right now; see
the URL <http://www.python.org/doc/essays/packages.html> for more
details, also about how the module search works from inside a package.]

The built-in function `__import__()' is provided to support
applications that determine which modules need to be loaded
dynamically; refer to Built-in Functions in the  for additional
information.

* Menu:

* Future statements::


File: python-ref.info,  Node: Future statements,  Prev: import statement,  Up: import statement

Future statements
-----------------

A "future statement"  is a directive to the compiler that a particular
module should be compiled using syntax or semantics that will be
available in a specified future release of Python.  The future
statement is intended to ease migration to future versions of Python
that introduce incompatible changes to the language.  It allows use of
the new features on a per-module basis before the release in which the
feature becomes standard.

     [*]

`future_statement "from" "__future__" "import" feature ["as" name]'

` ("," feature ["as" name])*'

`feature identifier'

`name identifier'
A future statement must appear near the top of the module.  The only
lines that can appear before a future statement are:

   * the module docstring (if any),

   * comments,

   * blank lines, and

   * other future statements.


The features recognized by Python 2.3 are `generators', `division' and
`nested_scopes'.  `generators' and `nested_scopes' are redundant in 2.3
because they are always enabled.

A future statement is recognized and treated specially at compile time:
Changes to the semantics of core constructs are often implemented by
generating different code.  It may even be the case that a new feature
introduces new incompatible syntax (such as a new reserved word), in
which case the compiler may need to parse the module differently.  Such
decisions cannot be pushed off until runtime.

For any given release, the compiler knows which feature names have been
defined, and raises a compile-time error if a future statement contains
a feature not known to it.

The direct runtime semantics are the same as for any import statement:
there is a standard module `__future__', described later, and it will
be imported in the usual way at the time the future statement is
executed.

The interesting runtime semantics depend on the specific feature
enabled by the future statement.

Note that there is nothing special about the statement:

     import __future__ [as name]

That is not a future statement; it's an ordinary import statement with
no special semantics or syntax restrictions.

Code compiled by an exec statement or calls to the builtin functions
`compile()' and `execfile()' that occur in a module `M' containing a
future statement will, by default, use the new syntax or semantics
associated with the future statement.  This can, starting with Python
2.2 be controlled by optional arguments to `compile()' -- see the
documentation of that function in the library reference for details.

A future statement typed at an interactive interpreter prompt will take
effect for the rest of the interpreter session.  If an interpreter is
started with the `-i' option, is passed a script name to execute, and
the script includes a future statement, it will be in effect in the
interactive session started after the script is executed.


File: python-ref.info,  Node: global statement,  Next: exec statement,  Prev: import statement,  Up: Simple statements

The `global' statement
======================

`global_stmt "global" `identifier' ("," `identifier')*'
The `global' statement is a declaration which holds for the entire
current code block.  It means that the listed identifiers are to be
interpreted as globals.  It would be impossible to assign to a global
variable without `global', although free variables may refer to globals
without being declared global.

Names listed in a `global' statement must not be used in the same code
block textually preceding that `global' statement.

Names listed in a `global' statement must not be defined as formal
parameters or in a `for' loop control target, `class' definition,
function definition, or `import' statement.

(The current implementation does not enforce the latter two
restrictions, but programs should not abuse this freedom, as future
implementations may enforce them or silently change the meaning of the
program.)

*Programmer's note:* the `global' is a directive to the parser.  It
applies only to code parsed at the same time as the `global' statement.
In particular, a `global' statement contained in an `exec' statement
does not affect the code block _containing_ the `exec' statement, and
code contained in an `exec' statement is unaffected by `global'
statements in the code containing the `exec' statement.  The same
applies to the `eval()', `execfile()' and `compile()' functions.


File: python-ref.info,  Node: exec statement,  Prev: global statement,  Up: Simple statements

The `exec' statement
====================

`exec_stmt "exec" `expression' ["in" `expression' ["," `expression']]'
This statement supports dynamic execution of Python code.  The first
expression should evaluate to either a string, an open file object, or
a code object.  If it is a string, the string is parsed as a suite of
Python statements which is then executed (unless a syntax error
occurs).  If it is an open file, the file is parsed until `EOF' and
executed.  If it is a code object, it is simply executed.

In all cases, if the optional parts are omitted, the code is executed
in the current scope.  If only the first expression after `in' is
specified, it should be a dictionary, which will be used for both the
global and the local variables.  If two expressions are given, both
must be dictionaries and they are used for the global and local
variables, respectively.

As a side effect, an implementation may insert additional keys into the
dictionaries given besides those corresponding to variable names set by
the executed code.  For example, the current implementation may add a
reference to the dictionary of the built-in module `__builtin__' under
the key `__builtins__' (!).

*Programmer's hints:* dynamic evaluation of expressions is supported by
the built-in function `eval()'.  The built-in functions `globals()' and
`locals()' return the current global and local dictionary,
respectively, which may be useful to pass around for use by `exec'.


File: python-ref.info,  Node: Compound statements,  Next: Top-level components,  Prev: Simple statements,  Up: Top

Compound statements
*******************

Compound statements contain (groups of) other statements; they affect
or control the execution of those other statements in some way.  In
general, compound statements span multiple lines, although in simple
incarnations a whole compound statement may be contained in one line.

The `if', `while' and `for' statements implement traditional control
flow constructs.  `try' specifies exception handlers and/or cleanup
code for a group of statements.  Function and class definitions are
also syntactically compound statements.

Compound statements consist of one or more `clauses.'  A clause
consists of a header and a `suite.'  The clause headers of a particular
compound statement are all at the same indentation level.  Each clause
header begins with a uniquely identifying keyword and ends with a
colon.  A suite is a group of statements controlled by a clause.  A
suite can be one or more semicolon-separated simple statements on the
same line as the header, following the header's colon, or it can be one
or more indented statements on subsequent lines.  Only the latter form
of suite can contain nested compound statements; the following is
illegal, mostly because it wouldn't be clear to which `if' clause a
following `else' clause would belong:

     if test1: if test2: print x

Also note that the semicolon binds tighter than the colon in this
context, so that in the following example, either all or none of the
`print' statements are executed:

     if x < y < z: print x; print y; print z

Summarizing:

`compound_stmt `if_stmt''

` | `while_stmt''

` | `for_stmt''

` | `try_stmt''

` | `funcdef''

` | `classdef''

`suite `stmt_list' NEWLINE | NEWLINE INDENT `statement'+ DEDENT'

`statement `stmt_list' NEWLINE | `compound_stmt''

`stmt_list `simple_stmt' (";" `simple_stmt')* [";"]'
Note that statements always end in a `NEWLINE'  possibly followed by a
`DEDENT'.   Also note that optional continuation clauses always begin
with a keyword that cannot start a statement, thus there are no
ambiguities (the `dangling `else'' problem is solved in Python by
requiring nested `if' statements to be indented).

The formatting of the grammar rules in the following sections places
each clause on a separate line for clarity.

* Menu:

* if statement::
* while statement::
* for statement::
* try statement::
* Function definitions::
* Class definitions::


File: python-ref.info,  Node: if statement,  Next: while statement,  Prev: Compound statements,  Up: Compound statements

The `if' statement
==================

The `if' statement is used for conditional execution:

`if_stmt "if" `expression' ":" `suite''

` ( "elif" `expression' ":" `suite' )*'

` ["else" ":" `suite']'
It selects exactly one of the suites by evaluating the expressions one
by one until one is found to be true (see section~*Note Boolean
operations:: for the definition of true and false); then that suite is
executed (and no other part of the `if' statement is executed or
evaluated).  If all expressions are false, the suite of the `else'
clause, if present, is executed.


File: python-ref.info,  Node: while statement,  Next: for statement,  Prev: if statement,  Up: Compound statements

The `while' statement
=====================

The `while' statement is used for repeated execution as long as an
expression is true:

`while_stmt "while" `expression' ":" `suite''

` ["else" ":" `suite']'
This repeatedly tests the expression and, if it is true, executes the
first suite; if the expression is false (which may be the first time it
is tested) the suite of the `else' clause, if present, is executed and
the loop terminates.

A `break' statement executed in the first suite terminates the loop
without executing the `else' clause's suite.  A `continue' statement
executed in the first suite skips the rest of the suite and goes back
to testing the expression.


File: python-ref.info,  Node: for statement,  Next: try statement,  Prev: while statement,  Up: Compound statements

The `for' statement
===================

The `for' statement is used to iterate over the elements of a sequence
(such as a string, tuple or list) or other iterable object:

`for_stmt "for" `target_list' "in" `expression_list' ":" `suite''

` ["else" ":" `suite']'
The expression list is evaluated once; it should yield a sequence.  The
suite is then executed once for each item in the sequence, in the order
of ascending indices.  Each item in turn is assigned to the target list
using the standard rules for assignments, and then the suite is
executed.  When the items are exhausted (which is immediately when the
sequence is empty), the suite in the `else' clause, if present, is
executed, and the loop terminates.

A `break' statement executed in the first suite terminates the loop
without executing the `else' clause's suite.  A `continue' statement
executed in the first suite skips the rest of the suite and continues
with the next item, or with the `else' clause if there was no next item.

The suite may assign to the variable(s) in the target list; this does
not affect the next item assigned to it.

The target list is not deleted when the loop is finished, but if the
sequence is empty, it will not have been assigned to at all by the
loop.  Hint: the built-in function `range()' returns a sequence of
integers suitable to emulate the effect of Pascal's `for i := a to b
do'; e.g., `range(3)' returns the list `[0, 1, 2]'.

_There is a subtlety when the sequence is being modified by the loop
(this can only occur for mutable sequences, i.e. lists). An internal
counter is used to keep track of which item is used next, and this is
incremented on each iteration.  When this counter has reached the
length of the sequence the loop terminates.  This means that if the
suite deletes the current (or a previous) item from the sequence, the
next item will be skipped (since it gets the index of the current item
which has already been treated).  Likewise, if the suite inserts an
item in the sequence before the current item, the current item will be
treated again the next time through the loop. This can lead to nasty
bugs that can be avoided by making a temporary copy using a slice of
the whole sequence, e.g.,

_

     for x in a[:]:
         if x < 0: a.remove(x)


File: python-ref.info,  Node: try statement,  Next: Function definitions,  Prev: for statement,  Up: Compound statements

The `try' statement
===================

The `try' statement specifies exception handlers and/or cleanup code
for a group of statements:

`try_stmt `try_exc_stmt' | `try_fin_stmt''

`try_exc_stmt "try" ":" `suite''

` ("except" [`expression' ["," `target']] ":" `suite')+'

` ["else" ":" `suite']'

`try_fin_stmt "try" ":" `suite' "finally" ":" `suite''
There are two forms of `try' statement: `try'...`except' and
`try'...`finally'.  These forms cannot be mixed (but they can be nested
in each other).

The `try'...`except' form specifies one or more exception handlers (the
`except' clauses).  When no exception occurs in the `try' clause, no
exception handler is executed.  When an exception occurs in the `try'
suite, a search for an exception handler is started.  This search
inspects the except clauses in turn until one is found that matches the
exception.  An expression-less except clause, if present, must be last;
it matches any exception.  For an except clause with an expression,
that expression is evaluated, and the clause matches the exception if
the resulting object is "compatible" with the exception.  An object is
compatible with an exception if it is either the object that identifies
the exception, or (for exceptions that are classes) it is a base class
of the exception, or it is a tuple containing an item that is
compatible with the exception.  Note that the object identities must
match, i.e. it must be the same object, not just an object with the
same value.

If no except clause matches the exception, the search for an exception
handler continues in the surrounding code and on the invocation stack.

If the evaluation of an expression in the header of an except clause
raises an exception, the original search for a handler is canceled and
a search starts for the new exception in the surrounding code and on
the call stack (it is treated as if the entire `try' statement raised
the exception).

When a matching except clause is found, the exception's parameter is
assigned to the target specified in that except clause, if present, and
the except clause's suite is executed.  All except clauses must have an
executable block.  When the end of this block is reached, execution
continues normally after the entire try statement.  (This means that if
two nested handlers exist for the same exception, and the exception
occurs in the try clause of the inner handler, the outer handler will
not handle the exception.)

Before an except clause's suite is executed, details about the
exception are assigned to three variables in the `sys'  module:
`sys.exc_type' receives the object identifying the exception;
`sys.exc_value' receives the exception's parameter; `sys.exc_traceback'
receives a traceback object  (see section~*Note standard type
hierarchy::) identifying the point in the program where the exception
occurred.  These details are also available through the `sys.exc_info()'
function, which returns a tuple `(EXC_TYPE, EXC_VALUE, EXC_TRACEBACK)'.
Use of the corresponding variables is deprecated in favor of this
function, since their use is unsafe in a threaded program.  As of
Python 1.5, the variables are restored to their previous values (before
the call) when returning from a function that handled an exception.

The optional `else' clause is executed if and when control flows off
the end of the `try' clause.(1) Exceptions in the `else' clause are not
handled by the preceding `except' clauses.

The `try'...`finally' form specifies a `cleanup' handler.  The `try'
clause is executed.  When no exception occurs, the `finally' clause is
executed.  When an exception occurs in the `try' clause, the exception
is temporarily saved, the `finally' clause is executed, and then the
saved exception is re-raised.  If the `finally' clause raises another
exception or executes a `return' or `break' statement, the saved
exception is lost.  A `continue' statement is illegal in the `finally'
clause.  (The reason is a problem with the current implementation -
this restriction may be lifted in the future).  The exception
information is not available to the program during execution of the
`finally' clause.

When a `return', `break' or `continue' statement is executed in the
`try' suite of a `try'...`finally' statement, the `finally' clause is
also executed `on the way out.' A `continue' statement is illegal in
the `finally' clause.  (The reason is a problem with the current
implementation -- this restriction may be lifted in the future).

Additional information on exceptions can be found in section~*Note
Exceptions::, and information on using the `raise' statement to
generate exceptions may be found in section~*Note raise statement::.

---------- Footnotes ----------

(1)  Currently, control "flows off the end" except in the case of an
exception or the execution of a `return', `continue', or `break'
statement.


File: python-ref.info,  Node: Function definitions,  Next: Class definitions,  Prev: try statement,  Up: Compound statements

Function definitions
====================

A function definition defines a user-defined function object (see
section~*Note standard type hierarchy::):

`funcdef "def" `funcname' "(" [`parameter_list'] ")" ":" `suite''

`parameter_list (`defparameter' ",")*'

` ("*" `identifier' [, "**" `identifier']'

` | "**" `identifier' | `defparameter' [","])'

`defparameter `parameter' ["=" `expression']'

`sublist `parameter' ("," `parameter')* [","]'

`parameter `identifier' | "(" `sublist' ")"'

`funcname `identifier''
A function definition is an executable statement.  Its execution binds
the function name in the current local namespace to a function object
(a wrapper around the executable code for the function).  This function
object contains a reference to the current global namespace as the
global namespace to be used when the function is called.

The function definition does not execute the function body; this gets
executed only when the function is called.

When one or more top-level parameters have the form PARAMETER `='
EXPRESSION, the function is said to have "default parameter values."
For a parameter with a default value, the corresponding argument may be
omitted from a call, in which case the parameter's default value is
substituted.  If a parameter has a default value, all following
parameters must also have a default value -- this is a syntactic
restriction that is not expressed by the grammar.

*Default parameter values are evaluated when the function definition is
executed.*  This means that the expression is evaluated once, when the
function is defined, and that that same "pre-computed" value is used
for each call.  This is especially important to understand when a
default parameter is a mutable object, such as a list or a dictionary:
if the function modifies the object (e.g. by appending an item to a
list), the default value is in effect modified.  This is generally not
what was intended.  A way around this is to use `None' as the default,
and explicitly test for it in the body of the function, e.g.:

     def whats_on_the_telly(penguin=None):
         if penguin is None:
             penguin = []
         penguin.append("property of the zoo")
         return penguin

Function call semantics are described in more detail in section~*Note
Calls::.  A function call always assigns values to all parameters
mentioned in the parameter list, either from position arguments, from
keyword arguments, or from default values.  If the form "`*identifier'"
is present, it is initialized to a tuple receiving any excess
positional parameters, defaulting to the empty tuple.  If the form
"`**identifier'" is present, it is initialized to a new dictionary
receiving any excess keyword arguments, defaulting to a new empty
dictionary.

It is also possible to create anonymous functions (functions not bound
to a name), for immediate use in expressions.  This uses lambda forms,
described in section~*Note Lambdas::.  Note that the lambda form is
merely a shorthand for a simplified function definition; a function
defined in a "`def'" statement can be passed around or assigned to
another name just like a function defined by a lambda form.  The
"`def'" form is actually more powerful since it allows the execution of
multiple statements.

*Programmer's note:* Functions are first-class objects.  A "`def'" form
executed inside a function definition defines a local function that can
be returned or passed around.  Free variables used in the nested
function can access the local variables of the function containing the
def.  See section~*Note Naming and binding:: for details.


File: python-ref.info,  Node: Class definitions,  Prev: Function definitions,  Up: Compound statements

Class definitions
=================

A class definition defines a class object (see section~*Note standard
type hierarchy::):

`classdef "class" `classname' [`inheritance'] ":" `suite''

`inheritance "(" [`expression_list'] ")"'

`classname `identifier''
A class definition is an executable statement.  It first evaluates the
inheritance list, if present.  Each item in the inheritance list should
evaluate to a class object.  The class's suite is then executed in a
new execution frame (see section~*Note Naming and binding::), using a
newly created local namespace and the original global namespace.
(Usually, the suite contains only function definitions.)  When the
class's suite finishes execution, its execution frame is discarded but
its local namespace is saved.  A class object is then created using the
inheritance list for the base classes and the saved local namespace for
the attribute dictionary.  The class name is bound to this class object
in the original local namespace.

*Programmer's note:* variables defined in the class definition are
class variables; they are shared by all instances.  To define instance
variables, they must be given a value in the `__init__()' method or in
another method.  Both class and instance variables are accessible
through the notation "`self.name'", and an instance variable hides a
class variable with the same name when accessed in this way.  Class
variables with immutable values can be used as defaults for instance
variables.


File: python-ref.info,  Node: Top-level components,  Next: History and License,  Prev: Compound statements,  Up: Top

Top-level components
********************

The Python interpreter can get its input from a number of sources: from
a script passed to it as standard input or as program argument, typed
in interactively, from a module source file, etc.  This chapter gives
the syntax used in these cases.

* Menu:

* Complete Python programs::
* File input::
* Interactive input::
* Expression input::


File: python-ref.info,  Node: Complete Python programs,  Next: File input,  Prev: Top-level components,  Up: Top-level components

Complete Python programs
========================

While a language specification need not prescribe how the language
interpreter is invoked, it is useful to have a notion of a complete
Python program.  A complete Python program is executed in a minimally
initialized environment: all built-in and standard modules are
available, but none have been initialized, except for `sys' (various
system services), `__builtin__' (built-in functions, exceptions and
`None') and `__main__'.  The latter is used to provide the local and
global namespace for execution of the complete program.

The syntax for a complete Python program is that for file input,
described in the next section.

The interpreter may also be invoked in interactive mode; in this case,
it does not read and execute a complete program but reads and executes
one statement (possibly compound) at a time.  The initial environment
is identical to that of a complete program; each statement is executed
in the namespace of `__main__'.

Under {UNIX}, a complete program can be passed to the interpreter in
three forms: with the `-c' STRING command line option, as a file passed
as the first command line argument, or as standard input.  If the file
or standard input is a tty device, the interpreter enters interactive
mode; otherwise, it executes the file as a complete program.


File: python-ref.info,  Node: File input,  Next: Interactive input,  Prev: Complete Python programs,  Up: Top-level components

File input
==========

All input read from non-interactive files has the same form:

`file_input (NEWLINE | `statement')*'
This syntax is used in the following situations:

   * when parsing a complete Python program (from a file or from a
     string);

   * when parsing a module;

   * when parsing a string passed to the `exec' statement;



File: python-ref.info,  Node: Interactive input,  Next: Expression input,  Prev: File input,  Up: Top-level components

Interactive input
=================

Input in interactive mode is parsed using the following grammar:

`interactive_input [`stmt_list'] NEWLINE | `compound_stmt' NEWLINE'
Note that a (top-level) compound statement must be followed by a blank
line in interactive mode; this is needed to help the parser detect the
end of the input.


File: python-ref.info,  Node: Expression input,  Prev: Interactive input,  Up: Top-level components

Expression input
================

There are two forms of expression input.  Both ignore leading
whitespace.  The string argument to `eval()' must have the following
form:

`eval_input `expression_list' NEWLINE*'
The input line read by `input()' must have the following form:

`input_input `expression_list' NEWLINE'
Note: to read `raw' input line without interpretation, you can use the
built-in function `raw_input()' or the `readline()' method of file
objects.


File: python-ref.info,  Node: History and License,  Next: Module Index,  Prev: Top-level components,  Up: Top

History and License
*******************

* Menu:

* History of the software::
* Terms and conditions for accessing or otherwise using Python::


File: python-ref.info,  Node: History of the software,  Next: Terms and conditions for accessing or otherwise using Python,  Prev: History and License,  Up: History and License

History of the software
=======================

Python was created in the early 1990s by Guido van Rossum at Stichting
Mathematisch Centrum (CWI, see <http://www.cwi.nl/>) in the Netherlands
as a successor of a language called ABC.  Guido remains Python's
principal author, although it includes many contributions from others.

In 1995, Guido continued his work on Python at the Corporation for
National Research Initiatives (CNRI, see
<http://www.cnri.reston.va.us/>) in Reston, Virginia where he released
several versions of the software.

In May 2000, Guido and the Python core development team moved to
BeOpen.com to form the BeOpen PythonLabs team.  In October of the same
year, the PythonLabs team moved to Digital Creations (now Zope
Corporation; see <http://www.zope.com/>).  In 2001, the Python Software
Foundation (PSF, see <http://www.python.org/psf/>) was formed, a
non-profit organization created specifically to own Python-related
Intellectual Property.  Zope Corporation is a sponsoring member of the
PSF.

All Python releases are Open Source (see <http://www.opensource.org/>
for the Open Source Definition).  Historically, most, but not all,
Python releases have also been GPL-compatible; the table below
summarizes the various releases.

Release        Derived from   Year           Owner          GPL
                                                            compatible?
------         ------         ------         ------         ------
0.9.0 thru     n/a            1991-1995      CWI            yes
1.2                                                         
1.3 thru       1.2            1995-1999      CNRI           yes
1.5.2                                                       
1.6            1.5.2          2000           CNRI           no
2.0            1.6            2000           BeOpen.com     no
1.6.1          1.6            2001           CNRI           no
2.1            2.0+1.6.1      2001           PSF            no
2.0.1          2.0+1.6.1      2001           PSF            yes
2.1.1          2.1+2.0.1      2001           PSF            yes
2.2            2.1.1          2001           PSF            yes
2.1.2          2.1.1          2002           PSF            yes
2.1.3          2.1.2          2002           PSF            yes
2.2.1          2.2            2002           PSF            yes
2.2.2          2.2.1          2002           PSF            yes
2.2.3          2.2.2          2002-2003      PSF            yes
2.3            2.2.2          2002-2003      PSF            yes
2.3.1          2.3            2002-2003      PSF            yes
2.3.2          2.3.1          2003           PSF            yes

_Note:_ GPL-compatible doesn't mean that we're distributing Python
under the GPL.  All Python licenses, unlike the GPL, let you distribute
a modified version without making your changes open source. The
GPL-compatible licenses make it possible to combine Python with other
software that is released under the GPL; the others don't.

Thanks to the many outside volunteers who have worked under Guido's
direction to make these releases possible.


File: python-ref.info,  Node: Terms and conditions for accessing or otherwise using Python,  Prev: History of the software,  Up: History and License

Terms and conditions for accessing or otherwise using Python
============================================================

               *PSF LICENSE AGREEMENT FOR PYTHON 2.3.2*
  1. This LICENSE AGREEMENT is between the Python Software Foundation
     ("PSF"), and the Individual or Organization ("Licensee") accessing
     and otherwise using Python 2.3.2 software in source or binary form
     and its associated documentation.

  2. Subject to the terms and conditions of this License Agreement, PSF
     hereby grants Licensee a nonexclusive, royalty-free, world-wide
     license to reproduce, analyze, test, perform and/or display
     publicly, prepare derivative works, distribute, and otherwise use
     Python 2.3.2 alone or in any derivative version, provided,
     however, that PSF's License Agreement and PSF's notice of
     copyright, i.e., "Copyright (C) 2001-2003 Python Software
     Foundation; All Rights Reserved" are retained in Python 2.3.2
     alone or in any derivative version prepared by Licensee.

  3. In the event Licensee prepares a derivative work that is based on
     or incorporates Python 2.3.2 or any part thereof, and wants to
     make the derivative work available to others as provided herein,
     then Licensee hereby agrees to include in any such work a brief
     summary of the changes made to Python 2.3.2.

  4. PSF is making Python 2.3.2 available to Licensee on an "AS IS"
     basis.  PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
     IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND
     DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR
     FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 2.3.2
     WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.

  5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON
     2.3.2 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR
     LOSS AS A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING
     PYTHON 2.3.2, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE
     POSSIBILITY THEREOF.

  6. This License Agreement will automatically terminate upon a material
     breach of its terms and conditions.

  7. Nothing in this License Agreement shall be deemed to create any
     relationship of agency, partnership, or joint venture between PSF
     and Licensee.  This License Agreement does not grant permission to
     use PSF trademarks or trade name in a trademark sense to endorse
     or promote products or services of Licensee, or any third party.

  8. By copying, installing or otherwise using Python 2.3.2, Licensee
     agrees to be bound by the terms and conditions of this License
     Agreement.

             *BEOPEN.COM LICENSE AGREEMENT FOR PYTHON 2.0*
         *BEOPEN PYTHON OPEN SOURCE LICENSE AGREEMENT VERSION 1*
  1. This LICENSE AGREEMENT is between BeOpen.com ("BeOpen"), having an
     office at 160 Saratoga Avenue, Santa Clara, CA 95051, and the
     Individual or Organization ("Licensee") accessing and otherwise
     using this software in source or binary form and its associated
     documentation ("the Software").

  2. Subject to the terms and conditions of this BeOpen Python License
     Agreement, BeOpen hereby grants Licensee a non-exclusive,
     royalty-free, world-wide license to reproduce, analyze, test,
     perform and/or display publicly, prepare derivative works,
     distribute, and otherwise use the Software alone or in any
     derivative version, provided, however, that the BeOpen Python
     License is retained in the Software, alone or in any derivative
     version prepared by Licensee.

  3. BeOpen is making the Software available to Licensee on an "AS IS"
     basis.  BEOPEN MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
     IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, BEOPEN MAKES NO
     AND DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR
     FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE
     WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.

  4. BEOPEN SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF THE
     SOFTWARE FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR
     LOSS AS A RESULT OF USING, MODIFYING OR DISTRIBUTING THE SOFTWARE,
     OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY
     THEREOF.

  5. This License Agreement will automatically terminate upon a material
     breach of its terms and conditions.

  6. This License Agreement shall be governed by and interpreted in all
     respects by the law of the State of California, excluding conflict
     of law provisions.  Nothing in this License Agreement shall be
     deemed to create any relationship of agency, partnership, or joint
     venture between BeOpen and Licensee.  This License Agreement does
     not grant permission to use BeOpen trademarks or trade names in a
     trademark sense to endorse or promote products or services of
     Licensee, or any third party.  As an exception, the "BeOpen
     Python" logos available at http://www.pythonlabs.com/logos.html
     may be used according to the permissions granted on that web page.

  7. By copying, installing or otherwise using the software, Licensee
     agrees to be bound by the terms and conditions of this License
     Agreement.

               *CNRI LICENSE AGREEMENT FOR PYTHON 1.6.1*
  1. This LICENSE AGREEMENT is between the Corporation for National
     Research Initiatives, having an office at 1895 Preston White Drive,
     Reston, VA 20191 ("CNRI"), and the Individual or Organization
     ("Licensee") accessing and otherwise using Python 1.6.1 software in
     source or binary form and its associated documentation.

  2. Subject to the terms and conditions of this License Agreement, CNRI
     hereby grants Licensee a nonexclusive, royalty-free, world-wide
     license to reproduce, analyze, test, perform and/or display
     publicly, prepare derivative works, distribute, and otherwise use
     Python 1.6.1 alone or in any derivative version, provided,
     however, that CNRI's License Agreement and CNRI's notice of
     copyright, i.e., "Copyright (C) 1995-2001 Corporation for National
     Research Initiatives; All Rights Reserved" are retained in Python
     1.6.1 alone or in any derivative version prepared by Licensee.
     Alternately, in lieu of CNRI's License Agreement, Licensee may
     substitute the following text (omitting the quotes): "Python 1.6.1
     is made available subject to the terms and conditions in CNRI's
     License Agreement.  This Agreement together with Python 1.6.1 may
     be located on the Internet using the following unique, persistent
     identifier (known as a handle): 1895.22/1013.  This Agreement may
     also be obtained from a proxy server on the Internet using the
     following URL: <http://hdl.handle.net/1895.22/1013>."

  3. In the event Licensee prepares a derivative work that is based on
     or incorporates Python 1.6.1 or any part thereof, and wants to make
     the derivative work available to others as provided herein, then
     Licensee hereby agrees to include in any such work a brief summary
     of the changes made to Python 1.6.1.

  4. CNRI is making Python 1.6.1 available to Licensee on an "AS IS"
     basis.  CNRI MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
     IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, CNRI MAKES NO AND
     DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR
     FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 1.6.1
     WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.

  5. CNRI SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON
     1.6.1 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR
     LOSS AS A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING
     PYTHON 1.6.1, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE
     POSSIBILITY THEREOF.

  6. This License Agreement will automatically terminate upon a material
     breach of its terms and conditions.

  7. This License Agreement shall be governed by the federal
     intellectual property law of the United States, including without
     limitation the federal copyright law, and, to the extent such U.S.
     federal law does not apply, by the law of the Commonwealth of
     Virginia, excluding Virginia's conflict of law provisions.
     Notwithstanding the foregoing, with regard to derivative works
     based on Python 1.6.1 that incorporate non-separable material that
     was previously distributed under the GNU General Public License
     (GPL), the law of the Commonwealth of Virginia shall govern this
     License Agreement only as to issues arising under or with respect
     to Paragraphs 4, 5, and 7 of this License Agreement.  Nothing in
     this License Agreement shall be deemed to create any relationship
     of agency, partnership, or joint venture between CNRI and
     Licensee.  This License Agreement does not grant permission to use
     CNRI trademarks or trade name in a trademark sense to endorse or
     promote products or services of Licensee, or any third party.

  8. By clicking on the "ACCEPT" button where indicated, or by copying,
     installing or otherwise using Python 1.6.1, Licensee agrees to be
     bound by the terms and conditions of this License Agreement.

                                ACCEPT
          *CWI LICENSE AGREEMENT FOR PYTHON 0.9.0 THROUGH 1.2*
 Copyright
(C) 1991 - 1995, Stichting Mathematisch Centrum Amsterdam, The
Netherlands.  All rights reserved.

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Stichting Mathematisch
Centrum or CWI not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior permission.

STICHTING MATHEMATISCH CENTRUM DISCLAIMS ALL WARRANTIES WITH REGARD TO
THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH CENTRUM BE LIABLE FOR
ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.


File: python-ref.info,  Node: Module Index,  Next: Class-Exception-Object Index,  Prev: History and License,  Up: Top

Module Index
************

* Menu:

* __abs__:                               Emulating numeric types.
* __and__:                               Emulating numeric types.
* __builtin__ <1>:                       Complete Python programs.
* __builtin__:                           exec statement.
* __divmod__:                            Emulating numeric types.
* __eq__:                                Basic customization.
* __float__:                             Emulating numeric types.
* __floordiv__:                          Emulating numeric types.
* __ge__:                                Basic customization.
* __gt__:                                Basic customization.
* __hex__:                               Emulating numeric types.
* __iand__:                              Emulating numeric types.
* __idiv__:                              Emulating numeric types.
* __ifloordiv__:                         Emulating numeric types.
* __ilshift__:                           Emulating numeric types.
* __imod__:                              Emulating numeric types.
* __imul__:                              Emulating numeric types.
* __int__:                               Emulating numeric types.
* __invert__:                            Emulating numeric types.
* __ior__:                               Emulating numeric types.
* __ipow__:                              Emulating numeric types.
* __irshift__:                           Emulating numeric types.
* __isub__:                              Emulating numeric types.
* __itruediv__:                          Emulating numeric types.
* __ixor__:                              Emulating numeric types.
* __le__:                                Basic customization.
* __long__:                              Emulating numeric types.
* __lshift__:                            Emulating numeric types.
* __main__ <1>:                          Complete Python programs.
* __main__:                              Naming and binding.
* __mod__:                               Emulating numeric types.
* __mul__:                               Emulating numeric types.
* __ne__:                                Basic customization.
* __or__:                                Emulating numeric types.
* __pos__:                               Emulating numeric types.
* __pow__:                               Emulating numeric types.
* __rand__:                              Emulating numeric types.
* __rdiv__:                              Emulating numeric types.
* __rdivmod__:                           Emulating numeric types.
* __rfloordiv__:                         Emulating numeric types.
* __rlshift__:                           Emulating numeric types.
* __rmod__:                              Emulating numeric types.
* __rmul__:                              Emulating numeric types.
* __ror__:                               Emulating numeric types.
* __rpow__:                              Emulating numeric types.
* __rrshift__:                           Emulating numeric types.
* __rshift__:                            Emulating numeric types.
* __rsub__:                              Emulating numeric types.
* __rtruediv__:                          Emulating numeric types.
* __rxor__:                              Emulating numeric types.
* __sub__:                               Emulating numeric types.
* __truediv__:                           Emulating numeric types.
* __xor__:                               Emulating numeric types.
* array:                                 standard type hierarchy.
* bsddb:                                 standard type hierarchy.
* dbm:                                   standard type hierarchy.
* gdbm:                                  standard type hierarchy.
* sys <1>:                               Complete Python programs.
* sys <2>:                               try statement.
* sys <3>:                               import statement.
* sys:                                   print statement.

