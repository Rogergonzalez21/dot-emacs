This is python-lib.info, produced by makeinfo version 4.3 from
python-lib.texi.

October 3, 2003


File: python-lib.info,  Node: shlex Objects,  Next: Parsing Rules,  Prev: Module Contents,  Up: shlex

shlex Objects
-------------

A `shlex' instance has the following methods:

`get_token()'
     Return a token.  If tokens have been stacked using `push_token()',
     pop a token off the stack.  Otherwise, read one from the input
     stream.  If reading encounters an immediate end-of-file,
     `self.eof' is returned (the empty string (`''') in non-POSIX mode,
     and `None' in POSIX mode).

`push_token(str)'
     Push the argument onto the token stack.

`read_token()'
     Read a raw token.  Ignore the pushback stack, and do not interpret
     source requests.  (This is not ordinarily a useful entry point,
     and is documented here only for the sake of completeness.)

`sourcehook(filename)'
     When `shlex' detects a source request (see `source' below) this
     method is given the following token as argument, and expected to
     return a tuple consisting of a filename and an open file-like
     object.

     Normally, this method first strips any quotes off the argument.  If
     the result is an absolute pathname, or there was no previous source
     request in effect, or the previous source was a stream (e.g.
     `sys.stdin'), the result is left alone.  Otherwise, if the result
     is a relative pathname, the directory part of the name of the file
     immediately before it on the source inclusion stack is prepended
     (this behavior is like the way the C preprocessor handles
     `#include "file.h"').

     The result of the manipulations is treated as a filename, and
     returned as the first component of the tuple, with `open()' called
     on it to yield the second component. (Note: this is the reverse of
     the order of arguments in instance initialization!)

     This hook is exposed so that you can use it to implement directory
     search paths, addition of file extensions, and other namespace
     hacks.  There is no corresponding `close' hook, but a shlex
     instance will call the `close()' method of the sourced input
     stream when it returns `EOF'.

     For more explicit control of source stacking, use the
     `push_source()' and `pop_source()' methods.

`push_source(stream[, filename])'
     Push an input source stream onto the input stack.  If the filename
     argument is specified it will later be available for use in error
     messages.  This is the same method used internally by the
     `sourcehook' method.  _Added in Python version 2.1_

`pop_source()'
     Pop the last-pushed input source from the input stack.  This is
     the same method used internally when the lexer reaches `EOF' on a
     stacked input stream.  _Added in Python version 2.1_

`error_leader([file[, line]])'
     This method generates an error message leader in the format of a
     UNIX C compiler error label; the format is `'"%s", line %d: '',
     where the `%s' is replaced with the name of the current source
     file and the `%d' with the current input line number (the optional
     arguments can be used to override these).

     This convenience is provided to encourage `shlex' users to
     generate error messages in the standard, parseable format
     understood by Emacs and other UNIX tools.

Instances of `shlex' subclasses have some public instance variables
which either control lexical analysis or can be used for debugging:

`commenters'
     The string of characters that are recognized as comment beginners.
     All characters from the comment beginner to end of line are
     ignored.  Includes just `#' by default.

`wordchars'
     The string of characters that will accumulate into multi-character
     tokens.  By default, includes all ASCII alphanumerics and
     underscore.

`whitespace'
     Characters that will be considered whitespace and skipped.
     Whitespace bounds tokens.  By default, includes space, tab,
     linefeed and carriage-return.

`escape'
     Characters that will be considered as escape. This will be only
     used in POSIX mode, and includes just `\' by default.  _Added in
     Python version 2.3_

`quotes'
     Characters that will be considered string quotes.  The token
     accumulates until the same quote is encountered again (thus,
     different quote types protect each other as in the shell.)  By
     default, includes ASCII single and double quotes.

`escapedquotes'
     Characters in `quotes' that will interpret escape characters
     defined in `escape'.  This is only used in POSIX mode, and
     includes just `"' by default.  _Added in Python version 2.3_

`whitespace_split'
     If `True', tokens will only be split in whitespaces. This is
     useful, for example, for parsing command lines with `shlex',
     getting tokens in a similar way to shell arguments.  _Added in
     Python version 2.3_

`infile'
     The name of the current input file, as initially set at class
     instantiation time or stacked by later source requests.  It may be
     useful to examine this when constructing error messages.

`instream'
     The input stream from which this `shlex' instance is reading
     characters.

`source'
     This member is `None' by default.  If you assign a string to it,
     that string will be recognized as a lexical-level inclusion request
     similar to the `source' keyword in various shells.  That is, the
     immediately following token will opened as a filename and input
     taken from that stream until `EOF', at which point the `close()'
     method of that stream will be called and the input source will
     again become the original input stream. Source requests may be
     stacked any number of levels deep.

`debug'
     If this member is numeric and `1' or more, a `shlex' instance will
     print verbose progress output on its behavior.  If you need to use
     this, you can read the module source code to learn the details.

`lineno'
     Source line number (count of newlines seen so far plus one).

`token'
     The token buffer.  It may be useful to examine this when catching
     exceptions.

`eof'
     Token used to determine end of file. This will be set to the empty
     string (`'''), in non-POSIX mode, and to `None' in POSIX mode.
     _Added in Python version 2.3_


File: python-lib.info,  Node: Parsing Rules,  Prev: shlex Objects,  Up: shlex

Parsing Rules
-------------

When operating in non-POSIX mode, `shlex' will try to obey to the
following rules.

   * Quote characters are not recognized within words
     (`Do"Not"Separate' is parsed as the single word `Do"Not"Separate');

   * Escape characters are not recognized;

   * Enclosing characters in quotes preserve the literal value of all
     characters within the quotes;

   * Closing quotes separate words (`"Do"Separate' is parsed as `"Do"'
     and `Separate');

   * If `whitespace_split' is `False', any character not declared to be
     a word character, whitespace, or a quote will be returned as a
     single-character token. If it is `True', `shlex' will only split
     words in whitespaces;

   * EOF is signaled with an empty string (`''');

   * It's not possible to parse empty strings, even if quoted.

When operating in POSIX mode, `shlex' will try to obey to the following
parsing rules.

   * Quotes are stripped out, and do not separate words
     (`"Do"Not"Separate"' is parsed as the single word `DoNotSeparate');

   * Non-quoted escape characters (e.g. `\') preserve the literal value
     of the next character that follows;

   * Enclosing characters in quotes which are not part of
     `escapedquotes' (e.g. `'') preserve the literal value of all
     characters within the quotes;

   * Enclosing characters in quotes which are part of `escapedquotes'
     (e.g. `"') preserves the literal value of all characters within
     the quotes, with the exception of the characters mentioned in
     `escape'. The escape characters retain its special meaning only
     when followed by the quote in use, or the escape character itself.
     Otherwise the escape character will be considered a normal
     character.

   * EOF is signaled with a `None' value;

   * Quoted empty strings (`''') are allowed;


File: python-lib.info,  Node: Generic Operating System Services,  Next: Optional Operating System Services,  Prev: Miscellaneous Services,  Up: Top

Generic Operating System Services
*********************************

The modules described in this chapter provide interfaces to operating
system features that are available on (almost) all operating systems,
such as files and a clock.  The interfaces are generally modeled after
the UNIX or C interfaces, but they are available on most other systems
as well.  Here's an overview:

* Menu:

* os::
* ospath::
* dircache::
* stat::
* statcache::
* statvfs::
* filecmp::
* popen2::
* datetime::
* time::
* sched::
* mutex::
* getpass::
* curses::
* cursestextpad::
* curseswrapper::
* cursesascii::
* cursespanel::
* getopt::
* optparse::
* tempfile::
* errno::
* glob::
* fnmatch::
* shutil::
* locale::
* gettext::
* logging::


File: python-lib.info,  Node: os,  Next: ospath,  Prev: Generic Operating System Services,  Up: Generic Operating System Services

Miscellaneous operating system interfaces
=========================================

Miscellaneous operating system interfaces.

This module provides a more portable way of using operating system
dependent functionality than importing a operating system dependent
built-in module like `posix' or `nt'.

This module searches for an operating system dependent built-in module
like `mac' or `posix' and exports the same functions and data as found
there.  The design of all Python's built-in operating system dependent
modules is such that as long as the same functionality is available, it
uses the same interface; for example, the function `os.stat(PATH)'
returns stat information about PATH in the same format (which happens
to have originated with the POSIX interface).

Extensions peculiar to a particular operating system are also available
through the `os' module, but using them is of course a threat to
portability!

Note that after the first time `os' is imported, there is _no_
performance penalty in using functions from `os' instead of directly
from the operating system dependent built-in module, so there should be
_no_ reason not to use `os'!

The `os' module contains many functions and data values.  The items
below and in the following sub-sections are all available directly from
the `os' module.

`error'
     This exception is raised when a function returns a system-related
     error (not for illegal argument types or other incidental errors).
     This is also known as the built-in exception `OSError'.  The
     accompanying value is a pair containing the numeric error code from
     `errno' and the corresponding string, as would be printed by the C
     function `perror()'.  See the module `errno' , which contains
     names for the error codes defined by the underlying operating
     system.

     When exceptions are classes, this exception carries two attributes,
     `errno' and `strerror'.  The first holds the value of the C
     `errno' variable, and the latter holds the corresponding error
     message from `strerror()'.  For exceptions that involve a file
     system path (such as `chdir()' or `unlink()'), the exception
     instance will contain a third attribute, `filename', which is the
     file name passed to the function.

`name'
     The name of the operating system dependent module imported.  The
     following names have currently been registered: `'posix'', `'nt'',
     `'mac'', `'os2'', `'ce'', `'java'', `'riscos''.

`path'
     The corresponding operating system dependent standard module for
     pathname operations, such as `posixpath' or `macpath'.  Thus,
     given the proper imports, `os.path.split(FILE)' is equivalent to
     but more portable than `posixpath.split(FILE)'.  Note that this is
     also an importable module: it may be imported directly as
     `os.path'.

* Menu:

* Process Parameters::
* File Object Creation::
* File Descriptor Operations::
* Files and Directories::
* Process Management::
* Miscellaneous System Information::


File: python-lib.info,  Node: Process Parameters,  Next: File Object Creation,  Prev: os,  Up: os

Process Parameters
------------------

These functions and data items provide information and operate on the
current process and user.

`environ'
     A mapping object representing the string environment. For example,
     `environ['HOME']' is the pathname of your home directory (on some
     platforms), and is equivalent to `getenv("HOME")' in C.

     If the platform supports the `putenv()' function, this mapping may
     be used to modify the environment as well as query the
     environment.  `putenv()' will be called automatically when the
     mapping is modified.  _Note:_ On some platforms, including FreeBSD
     and Mac OS X, setting `environ' may cause memory leaks. Refer to
     the system documentation for putenv.

     If `putenv()' is not provided, this mapping may be passed to the
     appropriate process-creation functions to cause child processes to
     use a modified environment.

`chdir(path)'

`fchdir fd'

`getcwd'
     These functions are described in "Files and Directories" (section
     *Note Files and Directories::).

`ctermid()'
     Return the filename corresponding to the controlling terminal of
     the process.  Availability: UNIX.

`getegid()'
     Return the effective group id of the current process.  This
     corresponds to the `set id' bit on the file being executed in the
     current process.  Availability: UNIX.

`geteuid()'
     Return the current process' effective user id.  Availability: UNIX.

`getgid()'
     Return the real group id of the current process.  Availability:
     UNIX.

`getgroups()'
     Return list of supplemental group ids associated with the current
     process.  Availability: UNIX.

`getlogin()'
     Return the name of the user logged in on the controlling terminal
     of the process.  For most purposes, it is more useful to use the
     environment variable `LOGNAME' to find out who the user is, or
     `pwd.getpwuid(os.getuid())[0]' to get the login name of the
     currently effective user ID.  Availability: UNIX.

`getpgid(pid)'
     Return the process group id of the process with process id PID.
     If PID is 0, the process group id of the current process is
     returned. Availability: UNIX.  _Added in Python version 2.3_

`getpgrp()'
     Return the id of the current process group.  Availability: UNIX.

`getpid()'
     Return the current process id.  Availability: UNIX, Windows.

`getppid()'
     Return the parent's process id.  Availability: UNIX.

`getuid()'
     Return the current process' user id.  Availability: UNIX.

`getenv(varname[, value])'
     Return the value of the environment variable VARNAME if it exists,
     or VALUE if it doesn't.  VALUE defaults to `None'.  Availability:
     most flavors of UNIX, Windows.

`putenv(varname, value)'
     Set the environment variable named VARNAME to the string VALUE.
     Such changes to the environment affect subprocesses started with
     `os.system()', `popen()' or `fork()' and `execv()'.  Availability:
     most flavors of UNIX, Windows.

     _Note:_ On some platforms, including FreeBSD and Mac OS X, setting
     `environ' may cause memory leaks. Refer to the system
     documentation for putenv.

     When `putenv()' is supported, assignments to items in `os.environ'
     are automatically translated into corresponding calls to
     `putenv()'; however, calls to `putenv()' don't update
     `os.environ', so it is actually preferable to assign to items of
     `os.environ'.

`setegid(egid)'
     Set the current process's effective group id.  Availability: UNIX.

`seteuid(euid)'
     Set the current process's effective user id.  Availability: UNIX.

`setgid(gid)'
     Set the current process' group id.  Availability: UNIX.

`setgroups(groups)'
     Set the list of supplemental group ids associated with the current
     process to GROUPS. GROUPS must be a sequence, and each element
     must be an integer identifying a group. This operation is typical
     available only to the superuser.  Availability: UNIX.  _Added in
     Python version 2.2_

`setpgrp()'
     Calls the system call `setpgrp()' or `setpgrp(0, 0)' depending on
     which version is implemented (if any).  See the UNIX manual for
     the semantics.  Availability: UNIX.

`setpgid(pid, pgrp)'
     Calls the system call `setpgid()' to set the process group id of
     the process with id PID to the process group with id PGRP.  See
     the UNIX manual for the semantics.  Availability: UNIX.

`setreuid(ruid, euid)'
     Set the current process's real and effective user ids.
     Availability: UNIX.

`setregid(rgid, egid)'
     Set the current process's real and effective group ids.
     Availability: UNIX.

`setsid()'
     Calls the system call `setsid()'.  See the UNIX manual for the
     semantics.  Availability: UNIX.

`setuid(uid)'
     Set the current process' user id.  Availability: UNIX.

`strerror(code)'
     Return the error message corresponding to the error code in CODE.
     Availability: UNIX, Windows.

`umask(mask)'
     Set the current numeric umask and returns the previous umask.
     Availability: UNIX, Windows.

`uname()'
     Return a 5-tuple containing information identifying the current
     operating system.  The tuple contains 5 strings: `(SYSNAME,
     NODENAME, RELEASE, VERSION, MACHINE)'.  Some systems truncate the
     nodename to 8 characters or to the leading component; a better way
     to get the hostname is `socket.gethostname()' or even
     `socket.gethostbyaddr(socket.gethostname())'.  Availability:
     recent flavors of UNIX.


File: python-lib.info,  Node: File Object Creation,  Next: File Descriptor Operations,  Prev: Process Parameters,  Up: os

File Object Creation
--------------------

These functions create new file objects.

`fdopen(fd[, mode[, bufsize]])'
     Return an open file object connected to the file descriptor FD.
     The MODE and BUFSIZE arguments have the same meaning as the
     corresponding arguments to the built-in `open()' function.
     Availability: Macintosh, UNIX, Windows.

     _Changed in Python version 2.3_

`popen(command[, mode[, bufsize]])'
     Open a pipe to or from COMMAND.  The return value is an open file
     object connected to the pipe, which can be read or written
     depending on whether MODE is `'r'' (default) or `'w''.  The
     BUFSIZE argument has the same meaning as the corresponding
     argument to the built-in `open()' function.  The exit status of
     the command (encoded in the format specified for `wait()') is
     available as the return value of the `close()' method of the file
     object, except that when the exit status is zero (termination
     without errors), `None' is returned.  Availability: UNIX, Windows.

     _Changed in Python version 2.0_

`tmpfile()'
     Return a new file object opened in update mode (`w+b').  The file
     has no directory entries associated with it and will be
     automatically deleted once there are no file descriptors for the
     file.  Availability: UNIX, Windows.

For each of these `popen()' variants, if BUFSIZE is specified, it
specifies the buffer size for the I/O pipes.  MODE, if provided, should
be the string `'b'' or `'t''; on Windows this is needed to determine
whether the file objects should be opened in binary or text mode.  The
default value for MODE is `'t''.

These methods do not make it possible to retrieve the return code from
the child processes.  The only way to control the input and output
streams and also retrieve the return codes is to use the `Popen3' and
`Popen4' classes from the `popen2' module; these are only available on
UNIX.

For a discussion of possible deadlock conditions related to the use of
these functions, see "Flow Control Issues" (section~*Note Available
Types::).

`popen2(cmd[, mode[, bufsize]])'
     Executes CMD as a sub-process.  Returns the file objects
     `(CHILD_STDIN, CHILD_STDOUT)'.  Availability: UNIX, Windows.
     _Added in Python version 2.0_

`popen3(cmd[, mode[, bufsize]])'
     Executes CMD as a sub-process.  Returns the file objects
     `(CHILD_STDIN, CHILD_STDOUT, CHILD_STDERR)'.  Availability: UNIX,
     Windows.  _Added in Python version 2.0_

`popen4(cmd[, mode[, bufsize]])'
     Executes CMD as a sub-process.  Returns the file objects
     `(CHILD_STDIN, CHILD_STDOUT_AND_STDERR)'.  Availability: UNIX,
     Windows.  _Added in Python version 2.0_

This functionality is also available in the `popen2' module using
functions of the same names, but the return values of those functions
have a different order.


File: python-lib.info,  Node: File Descriptor Operations,  Next: Files and Directories,  Prev: File Object Creation,  Up: os

File Descriptor Operations
--------------------------

These functions operate on I/O streams referred to using file
descriptors.

`close(fd)'
     Close file descriptor FD.  Availability: Macintosh, UNIX, Windows.

     Note: this function is intended for low-level I/O and must be
     applied to a file descriptor as returned by `open()' or `pipe()'.
     To close a "file object" returned by the built-in function
     `open()' or by `popen()' or `fdopen()', use its `close()' method.

`dup(fd)'
     Return a duplicate of file descriptor FD.  Availability:
     Macintosh, UNIX, Windows.

`dup2(fd, fd2)'
     Duplicate file descriptor FD to FD2, closing the latter first if
     necessary.  Availability: UNIX, Windows.

`fdatasync(fd)'
     Force write of file with filedescriptor FD to disk.  Does not
     force update of metadata.  Availability: UNIX.

`fpathconf(fd, name)'
     Return system configuration information relevant to an open file.
     NAME specifies the configuration value to retrieve; it may be a
     string which is the name of a defined system value; these names are
     specified in a number of standards (POSIX.1, UNIX 95, UNIX 98, and
     others).  Some platforms define additional names as well.  The
     names known to the host operating system are given in the
     `pathconf_names' dictionary.  For configuration variables not
     included in that mapping, passing an integer for NAME is also
     accepted.  Availability: UNIX.

     If NAME is a string and is not known, `ValueError' is raised.  If
     a specific value for NAME is not supported by the host system,
     even if it is included in `pathconf_names', an `OSError' is raised
     with `errno.EINVAL' for the error number.

`fstat(fd)'
     Return status for file descriptor FD, like `stat()'.
     Availability: UNIX, Windows.

`fstatvfs(fd)'
     Return information about the filesystem containing the file
     associated with file descriptor FD, like `statvfs()'.
     Availability: UNIX.

`fsync(fd)'
     Force write of file with filedescriptor FD to disk.  On UNIX, this
     calls the native `fsync()' function; on Windows, the MS
     `_commit()' function.

     If you're starting with a Python file object F, first do
     `F.flush()', and then do `os.fsync(F.fileno())', to ensure that
     all internal buffers associated with F are written to disk.
     Availability: UNIX, and Windows starting in 2.2.3.

`ftruncate(fd, length)'
     Truncate the file corresponding to file descriptor FD, so that it
     is at most LENGTH bytes in size.  Availability: UNIX.

`isatty(fd)'
     Return `True' if the file descriptor FD is open and connected to a
     tty(-like) device, else `False'.  Availability: UNIX.

`lseek(fd, pos, how)'
     Set the current position of file descriptor FD to position POS,
     modified by HOW: `0' to set the position relative to the beginning
     of the file; `1' to set it relative to the current position; `2'
     to set it relative to the end of the file.  Availability:
     Macintosh, UNIX, Windows.

`open(file, flags[, mode])'
     Open the file FILE and set various flags according to FLAGS and
     possibly its mode according to MODE.  The default MODE is `0777'
     (octal), and the current umask value is first masked out.  Return
     the file descriptor for the newly opened file.  Availability:
     Macintosh, UNIX, Windows.

     For a description of the flag and mode values, see the C run-time
     documentation; flag constants (like `O_RDONLY' and `O_WRONLY') are
     defined in this module too (see below).

     Note: this function is intended for low-level I/O.  For normal
     usage, use the built-in function `open()', which returns a "file
     object" with `read()' and `write()' methods (and many more).

`openpty()'
     Open a new pseudo-terminal pair. Return a pair of file descriptors
     `(MASTER, SLAVE)' for the pty and the tty, respectively. For a
     (slightly) more portable approach, use the `pty'  module.
     Availability: Some flavors of UNIX.

`pipe()'
     Create a pipe.  Return a pair of file descriptors `(R, W)' usable
     for reading and writing, respectively.  Availability: UNIX,
     Windows.

`read(fd, n)'
     Read at most N bytes from file descriptor FD.  Return a string
     containing the bytes read.  If the end of the file referred to by
     FD has been reached, an empty string is returned.  Availability:
     Macintosh, UNIX, Windows.

     Note: this function is intended for low-level I/O and must be
     applied to a file descriptor as returned by `open()' or `pipe()'.
     To read a "file object" returned by the built-in function `open()'
     or by `popen()' or `fdopen()', or `sys.stdin', use its `read()' or
     `readline()' methods.

`tcgetpgrp(fd)'
     Return the process group associated with the terminal given by FD
     (an open file descriptor as returned by `open()').  Availability:
     UNIX.

`tcsetpgrp(fd, pg)'
     Set the process group associated with the terminal given by FD (an
     open file descriptor as returned by `open()') to PG.
     Availability: UNIX.

`ttyname(fd)'
     Return a string which specifies the terminal device associated with
     file-descriptor FD.  If FD is not associated with a terminal
     device, an exception is raised.  Availability: UNIX.

`write(fd, str)'
     Write the string STR to file descriptor FD.  Return the number of
     bytes actually written.  Availability: Macintosh, UNIX, Windows.

     Note: this function is intended for low-level I/O and must be
     applied to a file descriptor as returned by `open()' or `pipe()'.
     To write a "file object" returned by the built-in function
     `open()' or by `popen()' or `fdopen()', or `sys.stdout' or
     `sys.stderr', use its `write()' method.

The following data items are available for use in constructing the
FLAGS parameter to the `open()' function.

`O_RDONLY'

`O_WRONLY'

`O_RDWR'

`O_NDELAY'

`O_NONBLOCK'

`O_APPEND'

`O_DSYNC'

`O_RSYNC'

`O_SYNC'

`O_NOCTTY'

`O_CREAT'

`O_EXCL'

`O_TRUNC'
     Options for the FLAG argument to the `open()' function.  These can
     be bit-wise OR'd together.  Availability: Macintosh, UNIX, Windows.

`O_BINARY'
     Option for the FLAG argument to the `open()' function.  This can
     be bit-wise OR'd together with those listed above.  Availability:
     Macintosh, Windows.

`O_NOINHERIT'

`O_SHORT_LIVED'

`O_TEMPORARY'

`O_RANDOM'

`O_SEQUENTIAL'

`O_TEXT'
     Options for the FLAG argument to the `open()' function.  These can
     be bit-wise OR'd together.  Availability: Windows.


File: python-lib.info,  Node: Files and Directories,  Next: Process Management,  Prev: File Descriptor Operations,  Up: os

Files and Directories
---------------------

`access(path, mode)'
     Use the real uid/gid to test for access to PATH.  Note that most
     operations will use the effective uid/gid, therefore this routine
     can be used in a suid/sgid environment to test if the invoking
     user has the specified access to PATH.  MODE should be `F_OK' to
     test the existence of PATH, or it can be the inclusive OR of one
     or more of `R_OK', `W_OK', and `X_OK' to test permissions.  Return
     `1' if access is allowed, `0' if not.  See the UNIX man page
     `access(2)' for more information.  Availability: UNIX, Windows.

`F_OK'
     Value to pass as the MODE parameter of `access()' to test the
     existence of PATH.

`R_OK'
     Value to include in the MODE parameter of `access()' to test the
     readability of PATH.

`W_OK'
     Value to include in the MODE parameter of `access()' to test the
     writability of PATH.

`X_OK'
     Value to include in the MODE parameter of `access()' to determine
     if PATH can be executed.

`chdir(path)'
     Change the current working directory to PATH.  Availability:
     Macintosh, UNIX, Windows.

`fchdir(fd)'
     Change the current working directory to the directory represented
     by the file descriptor FD.  The descriptor must refer to an opened
     directory, not an open file.  Availability: UNIX.  _Added in
     Python version 2.3_

`getcwd()'
     Return a string representing the current working directory.
     Availability: Macintosh, UNIX, Windows.

`getcwdu()'
     Return a Unicode object representing the current working directory.
     Availability: UNIX, Windows.  _Added in Python version 2.3_

`chroot(path)'
     Change the root directory of the current process to PATH.
     Availability: UNIX.  _Added in Python version 2.2_

`chmod(path, mode)'
     Change the mode of PATH to the numeric MODE.  MODE may take one of
     the following values (as defined in the `stat' module):
        * `S_ISUID'

        * `S_ISGID'

        * `S_ENFMT'

        * `S_ISVTX'

        * `S_IREAD'

        * `S_IWRITE'

        * `S_IEXEC'

        * `S_IRWXU'

        * `S_IRUSR'

        * `S_IWUSR'

        * `S_IXUSR'

        * `S_IRWXG'

        * `S_IRGRP'

        * `S_IWGRP'

        * `S_IXGRP'

        * `S_IRWXO'

        * `S_IROTH'

        * `S_IWOTH'

        * `S_IXOTH'

     Availability: UNIX, Windows.

`chown(path, uid, gid)'
     Change the owner and group id of PATH to the numeric UID and GID.
     Availability: UNIX.

`lchown(path, uid, gid)'
     Change the owner and group id of PATH to the numeric UID and gid.
     This function will not follow symbolic links.  Availability: UNIX.
     _Added in Python version 2.3_

`link(src, dst)'
     Create a hard link pointing to SRC named DST.  Availability: UNIX.

`listdir(path)'
     Return a list containing the names of the entries in the directory.
     The list is in arbitrary order.  It does not include the special
     entries `'.'' and `'..'' even if they are present in the directory.
     Availability: Macintosh, UNIX, Windows.

     _Changed in Python version 2.3_

`lstat(path)'
     Like `stat()', but do not follow symbolic links.  Availability:
     UNIX.

`mkfifo(path[, mode])'
     Create a FIFO (a named pipe) named PATH with numeric mode MODE.
     The default MODE is `0666' (octal).  The current umask value is
     first masked out from the mode.  Availability: UNIX.

     FIFOs are pipes that can be accessed like regular files.  FIFOs
     exist until they are deleted (for example with `os.unlink()').
     Generally, FIFOs are used as rendezvous between "client" and
     "server" type processes: the server opens the FIFO for reading, and
     the client opens it for writing.  Note that `mkfifo()' doesn't
     open the FIFO -- it just creates the rendezvous point.

`mknod(path[, mode=0600, device])'
     Create a filesystem node (file, device special file or named pipe)
     named filename. MODE specifies both the permissions to use and the
     type of node to be created, being combined (bitwise OR) with one
     of S_IFREG, S_IFCHR, S_IFBLK, and S_IFIFO (those constants are
     available in `stat'). For S_IFCHR and S_IFBLK, DEVICE defines the
     newly created device special file (probably using `os.makedev()'),
     otherwise it is ignored.  _Added in Python version 2.3_

`major(device)'
     Extracts a device major number from a raw device number.  _Added
     in Python version 2.3_

`minor(device)'
     Extracts a device minor number from a raw device number.  _Added
     in Python version 2.3_

`makedev(major, minor)'
     Composes a raw device number from the major and minor device
     numbers.  _Added in Python version 2.3_

`mkdir(path[, mode])'
     Create a directory named PATH with numeric mode MODE.  The default
     MODE is `0777' (octal).  On some systems, MODE is ignored.  Where
     it is used, the current umask value is first masked out.
     Availability: Macintosh, UNIX, Windows.

`makedirs(path[, mode])'
     Recursive directory creation function.  Like `mkdir()', but makes
     all intermediate-level directories needed to contain the leaf
     directory.  Throws an `error' exception if the leaf directory
     already exists or cannot be created.  The default MODE is `0777'
     (octal).  This function does not properly handle UNC paths (only
     relevant on Windows systems; Universal Naming Convention paths are
     those that use the ``\\host\path'' syntax).  _Added in Python
     version 1.5.2_

`pathconf(path, name)'
     Return system configuration information relevant to a named file.
     NAME specifies the configuration value to retrieve; it may be a
     string which is the name of a defined system value; these names are
     specified in a number of standards (POSIX.1, UNIX 95, UNIX 98, and
     others).  Some platforms define additional names as well.  The
     names known to the host operating system are given in the
     `pathconf_names' dictionary.  For configuration variables not
     included in that mapping, passing an integer for NAME is also
     accepted.  Availability: UNIX.

     If NAME is a string and is not known, `ValueError' is raised.  If
     a specific value for NAME is not supported by the host system,
     even if it is included in `pathconf_names', an `OSError' is raised
     with `errno.EINVAL' for the error number.

`pathconf_names'
     Dictionary mapping names accepted by `pathconf()' and
     `fpathconf()' to the integer values defined for those names by the
     host operating system.  This can be used to determine the set of
     names known to the system.  Availability: UNIX.

`readlink(path)'
     Return a string representing the path to which the symbolic link
     points.  The result may be either an absolute or relative
     pathname; if it is relative, it may be converted to an absolute
     pathname using `os.path.join(os.path.dirname(PATH), RESULT)'.
     Availability: UNIX.

`remove(path)'
     Remove the file PATH.  If PATH is a directory, `OSError' is
     raised; see `rmdir()' below to remove a directory.  This is
     identical to the `unlink()' function documented below.  On
     Windows, attempting to remove a file that is in use causes an
     exception to be raised; on UNIX, the directory entry is removed
     but the storage allocated to the file is not made available until
     the original file is no longer in use.  Availability: Macintosh,
     UNIX, Windows.

`removedirs(path)'
     Removes directories recursively.  Works like `rmdir()' except
     that, if the leaf directory is successfully removed, directories
     corresponding to rightmost path segments will be pruned way until
     either the whole path is consumed or an error is raised (which is
     ignored, because it generally means that a parent directory is not
     empty).  Throws an `error' exception if the leaf directory could
     not be successfully removed.  _Added in Python version 1.5.2_

`rename(src, dst)'
     Rename the file or directory SRC to DST.  If DST is a directory,
     `OSError' will be raised.  On UNIX, if DST exists and is a file,
     it will be removed silently if the user has permission.  The
     operation may fail on some UNIX flavors if SRC and DST are on
     different filesystems.  If successful, the renaming will be an
     atomic operation (this is a POSIX requirement).  On Windows, if
     DST already exists, `OSError' will be raised even if it is a file;
     there may be no way to implement an atomic rename when DST names
     an existing file.  Availability: Macintosh, UNIX, Windows.

`renames(old, new)'
     Recursive directory or file renaming function.  Works like
     `rename()', except creation of any intermediate directories needed
     to make the new pathname good is attempted first.  After the
     rename, directories corresponding to rightmost path segments of
     the old name will be pruned away using `removedirs()'.

     Note: this function can fail with the new directory structure made
     if you lack permissions needed to remove the leaf directory or
     file.  _Added in Python version 1.5.2_

`rmdir(path)'
     Remove the directory PATH.  Availability: Macintosh, UNIX, Windows.

`stat(path)'
     Perform a `stat()' system call on the given path.  The return
     value is an object whose attributes correspond to the members of
     the `stat' structure, namely: `st_mode' (protection bits),
     `st_ino' (inode number), `st_dev' (device), `st_nlink' (number of
     hard links), `st_uid' (user ID of owner), `st_gid' (group ID of
     owner), `st_size' (size of file, in bytes), `st_atime' (time of
     most recent access), `st_mtime' (time of most recent content
     modification), `st_ctime' (time of most recent content
     modification or metadata change).

     _Changed in Python version stat_float_times_ returns true, the time
     values are floats, measuring seconds. Fractions of a second may be
     reported if the system supports that. On Mac OS, the times are
     always floats. See `stat_float_times' for further discussion.
     ]{2.3}

     On some Unix systems (such as Linux), the following attributes may
     also be available: `st_blocks' (number of blocks allocated for
     file), `st_blksize' (filesystem blocksize), `st_rdev' (type of
     device if an inode device).

     On Mac OS systems, the following attributes may also be available:
     `st_rsize', `st_creator', `st_type'.

     On RISCOS systems, the following attributes are also available:
     `st_ftype' (file type), `st_attrs' (attributes), `st_obtype'
     (object type).

     For backward compatibility, the return value of `stat()' is also
     accessible as a tuple of at least 10 integers giving the most
     important (and portable) members of the `stat' structure, in the
     order `st_mode', `st_ino', `st_dev', `st_nlink', `st_uid',
     `st_gid', `st_size', `st_atime', `st_mtime', `st_ctime'.  More
     items may be added at the end by some implementations.  The
     standard module `stat'  defines functions and constants that are
     useful for extracting information from a `stat' structure.  (On
     Windows, some items are filled with dummy values.)  Availability:
     Macintosh, UNIX, Windows.

     _Changed in Python version 2.2_

`stat_float_times([newvalue])'
     Determine whether `stat_result' represents time stamps as float
     objects.  If newval is True, future calls to stat() return floats,
     if it is False, future calls return ints.  If newval is omitted,
     return the current setting.

     For compatibility with older Python versions, accessing
     `stat_result' as a tuple always returns integers. For
     compatibility with Python 2.2, accessing the time stamps by field
     name also returns integers. Applications that want to determine the
     fractions of a second in a time stamp can use this function to have
     time stamps represented as floats. Whether they will actually
     observe non-zero fractions depends on the system.

     Future Python releases will change the default of this setting;
     applications that cannot deal with floating point time stamps can
     then use this function to turn the feature off.

     It is recommended that this setting is only changed at program
     startup time in the __MAIN__ module; libraries should never change
     this setting. If an application uses a library that works
     incorrectly if floating point time stamps are processed, this
     application should turn the feature off until the library has been
     corrected.

`statvfs(path)'
     Perform a `statvfs()' system call on the given path.  The return
     value is an object whose attributes describe the filesystem on the
     given path, and correspond to the members of the `statvfs'
     structure, namely: `f_frsize', `f_blocks', `f_bfree', `f_bavail',
     `f_files', `f_ffree', `f_favail', `f_flag', `f_namemax'.
     Availability: UNIX.

     For backward compatibility, the return value is also accessible as
     a tuple whose values correspond to the attributes, in the order
     given above.  The standard module `statvfs' defines constants that
     are useful for extracting information from a `statvfs' structure
     when accessing it as a sequence; this remains useful when writing
     code that needs to work with versions of Python that don't support
     accessing the fields as attributes.

     _Changed in Python version 2.2_

`symlink(src, dst)'
     Create a symbolic link pointing to SRC named DST.  Availability:
     UNIX.

`tempnam([dir[, prefix]])'
     Return a unique path name that is reasonable for creating a
     temporary file.  This will be an absolute path that names a
     potential directory entry in the directory DIR or a common
     location for temporary files if DIR is omitted or `None'.  If
     given and not `None', PREFIX is used to provide a short prefix to
     the filename.  Applications are responsible for properly creating
     and managing files created using paths returned by `tempnam()'; no
     automatic cleanup is provided.  On UNIX, the environment variable
     `TMPDIR' overrides DIR, while on Windows the `TMP' is used.  The
     specific behavior of this function depends on the C library
     implementation; some aspects are underspecified in system
     documentation.  _Use of `tempnam()' is vulnerable to symlink
     attacks; consider using `tmpfile()' instead._ Availability: UNIX,
     Windows.

`tmpnam()'
     Return a unique path name that is reasonable for creating a
     temporary file.  This will be an absolute path that names a
     potential directory entry in a common location for temporary
     files.  Applications are responsible for properly creating and
     managing files created using paths returned by `tmpnam()'; no
     automatic cleanup is provided.  _Use of `tmpnam()' is vulnerable
     to symlink attacks; consider using `tmpfile()' instead._
     Availability: UNIX, Windows.  This function probably shouldn't be
     used on Windows, though:  Microsoft's implementation of `tmpnam()'
     always creates a name in the root directory of the current drive,
     and that's generally a poor location for a temp file (depending on
     privileges, you may not even be able to open a file using this
     name).

`TMP_MAX'
     The maximum number of unique names that `tmpnam()' will generate
     before reusing names.

`unlink(path)'
     Remove the file PATH.  This is the same function as `remove()';
     the `unlink()' name is its traditional UNIX name.  Availability:
     Macintosh, UNIX, Windows.

`utime(path, times)'
     Set the access and modified times of the file specified by PATH.
     If TIMES is `None', then the file's access and modified times are
     set to the current time.  Otherwise, TIMES must be a 2-tuple of
     numbers, of the form `(ATIME, MTIME)' which is used to set the
     access and modified times, respectively.  _Changed in Python
     version 2.0_ Availability: Macintosh, UNIX, Windows.

`walk(top[, topdown`=True' [, onerror`=None']])'
     `walk()' generates the file names in a directory tree, by walking
     the tree either top down or bottom up.  For each directory in the
     tree rooted at directory TOP (including TOP itself), it yields a
     3-tuple `(DIRPATH, DIRNAMES, FILENAMES)'.

     DIRPATH is a string, the path to the directory.  DIRNAMES is a
     list of the names of the subdirectories in DIRPATH (excluding
     `'.'' and `'..'').  FILENAMES is a list of the names of the
     non-directory files in DIRPATH.  Note that the names in the lists
     contain no path components.  To get a full path (which begins with
     TOP) to a file or directory in DIRPATH, do `os.path.join(DIRPATH,
     NAME)'.

     If optional argument TOPDOWN is true or not specified, the triple
     for a directory is generated before the triples for any of its
     subdirectories (directories are generated top down).  If TOPDOWN is
     false, the triple for a directory is generated after the triples
     for all of its subdirectories (directories are generated bottom
     up).

     When TOPDOWN is true, the caller can modify the DIRNAMES list
     in-place (perhaps using `del' or slice assignment), and `walk()'
     will only recurse into the subdirectories whose names remain in
     DIRNAMES; this can be used to prune the search, impose a specific
     order of visiting, or even to inform `walk()' about directories
     the caller creates or renames before it resumes `walk()' again.
     Modifying DIRNAMES when TOPDOWN is false is ineffective, because
     in bottom-up mode the directories in DIRNAMES are generated before
     DIRNAMES itself is generated.

     By default errors from the `os.listdir()' call are ignored.  If
     optional argument ONERROR is specified, it should be a function;
     it will be called with one argument, an os.error instance.  It can
     report the error to continue with the walk, or raise the exception
     to abort the walk.  Note that the filename is available as the
     `filename' attribute of the exception object.

     _Notice:_ If you pass a relative pathname, don't change the
     current working directory between resumptions of `walk()'.
     `walk()' never changes the current directory, and assumes that its
     caller doesn't either.

     _Notice:_ On systems that support symbolic links, links to
     subdirectories appear in DIRNAMES lists, but `walk()' will not
     visit them (infinite loops are hard to avoid when following
     symbolic links).  To visit linked directories, you can identify
     them with `os.path.islink(PATH)', and invoke `walk(PATH)' on each
     directly.

     This example displays the number of bytes taken by non-directory
     files in each directory under the starting directory, except that
     it doesn't look under any CVS subdirectory:

          import os
          from os.path import join, getsize
          for root, dirs, files in os.walk('python/Lib/email'):
              print root, "consumes",
              print sum([getsize(join(root, name)) for name in files]),
              print "bytes in", len(files), "non-directory files"
              if 'CVS' in dirs:
                  dirs.remove('CVS')  # don't visit CVS directories

     In the next example, walking the tree bottom up is essential:
     `rmdir()' doesn't allow deleting a directory before the directory
     is empty:

          import os
          from os.path import join
          # Delete everything reachable from the directory named in 'top'.
          # CAUTION:  This is dangerous!  For example, if top == '/', it
          # could delete all your disk files.
          for root, dirs, files in os.walk(top, topdown=False):
              for name in files:
                  os.remove(join(root, name))
              for name in dirs:
                  os.rmdir(join(root, name))

     _Added in Python version 2.3_

