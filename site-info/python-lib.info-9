This is python-lib.info, produced by makeinfo version 4.3 from
python-lib.texi.

October 3, 2003


File: python-lib.info,  Node: __builtin__,  Next: __main__,  Prev: user,  Up: Python Runtime Services

Built-in functions
==================

The set of built-in functions.

This module provides direct access to all `built-in' identifiers of
Python; e.g. `__builtin__.open' is the full name for the built-in
function `open()'.  See section *Note Built-in Functions::, "Built-in
Functions."


File: python-lib.info,  Node: __main__,  Next: __future__,  Prev: __builtin__,  Up: Python Runtime Services

Top-level script environment
============================

The environment where the top-level script is run.

This module represents the (otherwise anonymous) scope in which the
interpreter's main program executes -- commands read either from
standard input, from a script file, or from an interactive prompt.  It
is this environment in which the idiomatic "conditional script" stanza
causes a script to run:

     if __name__ == "__main__":
         main()


File: python-lib.info,  Node: __future__,  Prev: __main__,  Up: Python Runtime Services

Future statement definitions
============================

Future statement definitions

`__future__' is a real module, and serves three purposes:

   * To avoid confusing existing tools that analyze import statements
     and expect to find the modules they're importing.

   * To ensure that future_statements run under releases prior to 2.1
     at least yield runtime exceptions (the import of `__future__' will
     fail, because there was no module of that name prior to 2.1).

   * To document when incompatible changes were introduced, and when
     they will be -- or were -- made mandatory.  This is a form of
     executable documentation, and can be inspected programatically via
     importing `__future__' and examining its contents.


Each statement in `__future__.py' is of the form:

     FeatureName = "_Feature(" OptionalRelease "," MandatoryRelease ","
                             CompilerFlag ")"

where, normally, OptionalRelease is less then MandatoryRelease, and
both are 5-tuples of the same form as `sys.version_info':

         (PY_MAJOR_VERSION, # the 2 in 2.1.0a3; an int
          PY_MINOR_VERSION, # the 1; an int
          PY_MICRO_VERSION, # the 0; an int
          PY_RELEASE_LEVEL, # "alpha", "beta", "candidate" or "final"; string
          PY_RELEASE_SERIAL # the 3; an int
         )

OptionalRelease records the first release in which the feature was
accepted.

In the case of MandatoryReleases that have not yet occurred,
MandatoryRelease predicts the release in which the feature will become
part of the language.

Else MandatoryRelease records when the feature became part of the
language; in releases at or after that, modules no longer need a future
statement to use the feature in question, but may continue to use such
imports.

MandatoryRelease may also be `None', meaning that a planned feature got
dropped.

Instances of class `_Feature' have two corresponding methods,
`getOptionalRelease()' and `getMandatoryRelease()'.

CompilerFlag is the (bitfield) flag that should be passed in the fourth
argument to the builtin function `compile()' to enable the feature in
dynamically compiled code.  This flag is stored in the `compiler_flag'
attribute on `_Future' instances.

No feature description will ever be deleted from `__future__'.


File: python-lib.info,  Node: String Services,  Next: Miscellaneous Services,  Prev: Python Runtime Services,  Up: Top

String Services
***************

The modules described in this chapter provide a wide range of string
manipulation operations.  Here's an overview:

Information on the methods of string objects can be found in
section~*Note String Methods::, "String Methods."

* Menu:

* string::
* re::
* struct::
* difflib::
* fpformat::
* StringIO::
* cStringIO::
* textwrap::
* codecs::
* unicodedata::
* stringprep::


File: python-lib.info,  Node: string,  Next: re,  Prev: String Services,  Up: String Services

Common string operations
========================

Common string operations.

This module defines some constants useful for checking character
classes and some useful string functions.  See the module `re'  for
string functions based on regular expressions.

The constants defined in this module are:

`ascii_letters'
     The concatenation of the `ascii_lowercase' and `ascii_uppercase'
     constants described below.  This value is not locale-dependent.

`ascii_lowercase'
     The lowercase letters `'abcdefghijklmnopqrstuvwxyz''.  This value
     is not locale-dependent and will not change.

`ascii_uppercase'
     The uppercase letters `'ABCDEFGHIJKLMNOPQRSTUVWXYZ''.  This value
     is not locale-dependent and will not change.

`digits'
     The string `'0123456789''.

`hexdigits'
     The string `'0123456789abcdefABCDEF''.

`letters'
     The concatenation of the strings `lowercase' and `uppercase'
     described below.  The specific value is locale-dependent, and will
     be updated when `locale.setlocale()' is called.

`lowercase'
     A string containing all the characters that are considered
     lowercase letters.  On most systems this is the string
     `'abcdefghijklmnopqrstuvwxyz''.  Do not change its definition --
     the effect on the routines `upper()' and `swapcase()' is
     undefined.  The specific value is locale-dependent, and will be
     updated when `locale.setlocale()' is called.

`octdigits'
     The string `'01234567''.

`punctuation'
     String of ASCII characters which are considered punctuation
     characters in the `C' locale.

`printable'
     String of characters which are considered printable.  This is a
     combination of `digits', `letters', `punctuation', and
     `whitespace'.

`uppercase'
     A string containing all the characters that are considered
     uppercase letters.  On most systems this is the string
     `'ABCDEFGHIJKLMNOPQRSTUVWXYZ''.  Do not change its definition --
     the effect on the routines `lower()' and `swapcase()' is
     undefined.  The specific value is locale-dependent, and will be
     updated when `locale.setlocale()' is called.

`whitespace'
     A string containing all characters that are considered whitespace.
     On most systems this includes the characters space, tab, linefeed,
     return, formfeed, and vertical tab.  Do not change its definition
     -- the effect on the routines `strip()' and `split()' is undefined.

Many of the functions provided by this module are also defined as
methods of string and Unicode objects; see "String Methods" (section
*Note String Methods::) for more information on those.  The functions
defined in this module are:

`atof(s)'
     _This is deprecated in Python 2.0.  Use the `float()' built-in
     function._ Convert a string to a floating point number.  The
     string must have the standard syntax for a floating point literal
     in Python, optionally preceded by a sign (`+' or `-').  Note that
     this behaves identical to the built-in function `float()'  when
     passed a string.

     _Note:_ When passing in a string, values for NaN  and Infinity
     may be returned, depending on the underlying C library.  The
     specific set of strings accepted which cause these values to be
     returned depends entirely on the C library and is known to vary.

`atoi(s[, base])'
     _This is deprecated in Python 2.0.  Use the `int()' built-in
     function._ Convert string S to an integer in the given BASE.  The
     string must consist of one or more digits, optionally preceded by a
     sign (`+' or `-').  The BASE defaults to 10.  If it is 0, a
     default base is chosen depending on the leading characters of the
     string (after stripping the sign): `0x' or `0X' means 16, `0'
     means 8, anything else means 10.  If BASE is 16, a leading `0x' or
     `0X' is always accepted, though not required.  This behaves
     identically to the built-in function `int()' when passed a string.
     (Also note: for a more flexible interpretation of numeric
     literals, use the built-in function `eval()' .)

`atol(s[, base])'
     _This is deprecated in Python 2.0.  Use the `long()' built-in
     function._ Convert string S to a long integer in the given BASE.
     The string must consist of one or more digits, optionally preceded
     by a sign (`+' or `-').  The BASE argument has the same meaning as
     for `atoi()'.  A trailing `l' or `L' is not allowed, except if the
     base is 0.  Note that when invoked without BASE or with BASE set
     to 10, this behaves identical to the built-in function `long()'
     when passed a string.

`capitalize(word)'
     Return a copy of WORD with only its first character capitalized.

`capwords(s)'
     Split the argument into words using `split()', capitalize each
     word using `capitalize()', and join the capitalized words using
     `join()'.  Note that this replaces runs of whitespace characters
     by a single space, and removes leading and trailing whitespace.

`expandtabs(s[, tabsize])'
     Expand tabs in a string, i.e. replace them by one or more spaces,
     depending on the current column and the given tab size.  The column
     number is reset to zero after each newline occurring in the string.
     This doesn't understand other non-printing characters or escape
     sequences.  The tab size defaults to 8.

`find(s, sub[, start[,end]])'
     Return the lowest index in S where the substring SUB is found such
     that SUB is wholly contained in `S[START:END]'.  Return `-1' on
     failure.  Defaults for START and END and interpretation of
     negative values is the same as for slices.

`rfind(s, sub[, start[, end]])'
     Like `find()' but find the highest index.

`index(s, sub[, start[, end]])'
     Like `find()' but raise `ValueError' when the substring is not
     found.

`rindex(s, sub[, start[, end]])'
     Like `rfind()' but raise `ValueError' when the substring is not
     found.

`count(s, sub[, start[, end]])'
     Return the number of (non-overlapping) occurrences of substring
     SUB in string `S[START:END]'.  Defaults for START and END and
     interpretation of negative values are the same as for slices.

`lower(s)'
     Return a copy of S, but with upper case letters converted to lower
     case.

`maketrans(from, to)'
     Return a translation table suitable for passing to `translate()'
     or `regex.compile()', that will map each character in FROM into
     the character at the same position in TO; FROM and TO must have
     the same length.

     _Don't use strings derived from `lowercase' and `uppercase' as
     arguments; in some locales, these don't have the same length.  For
     case conversions, always use `lower()' and `upper()'._

`split(s[, sep[, maxsplit]])'
     Return a list of the words of the string S.  If the optional
     second argument SEP is absent or `None', the words are separated
     by arbitrary strings of whitespace characters (space, tab,
     newline, return, formfeed).  If the second argument SEP is present
     and not `None', it specifies a string to be used as the word
     separator.  The returned list will then have one more item than
     the number of non-overlapping occurrences of the separator in the
     string.  The optional third argument MAXSPLIT defaults to 0.  If
     it is nonzero, at most MAXSPLIT number of splits occur, and the
     remainder of the string is returned as the final element of the
     list (thus, the list will have at most `MAXSPLIT+1' elements).

`splitfields(s[, sep[, maxsplit]])'
     This function behaves identically to `split()'.  (In the past,
     `split()' was only used with one argument, while `splitfields()'
     was only used with two arguments.)

`join(words[, sep])'
     Concatenate a list or tuple of words with intervening occurrences
     of SEP.  The default value for SEP is a single space character.
     It is always true that `string.join(string.split(S, SEP), SEP)'
     equals S.

`joinfields(words[, sep])'
     This function behaves identically to `join()'.  (In the past,
     `join()' was only used with one argument, while `joinfields()' was
     only used with two arguments.)  Note that there is no
     `joinfields()' method on string objects; use the `join()' method
     instead.

`lstrip(s[, chars])'
     Return a copy of the string with leading characters removed.  If
     CHARS is omitted or `None', whitespace characters are removed.  If
     given and not `None', CHARS must be a string; the characters in
     the string will be stripped from the beginning of the string this
     method is called on.  _Changed in Python version 2.2.3_

`rstrip(s[, chars])'
     Return a copy of the string with trailing characters removed.  If
     CHARS is omitted or `None', whitespace characters are removed.  If
     given and not `None', CHARS must be a string; the characters in
     the string will be stripped from the end of the string this method
     is called on.  _Changed in Python version 2.2.3_

`strip(s[, chars])'
     Return a copy of the string with leading and trailing characters
     removed.  If CHARS is omitted or `None', whitespace characters are
     removed.  If given and not `None', CHARS must be a string; the
     characters in the string will be stripped from the both ends of
     the string this method is called on.  _Changed in Python version
     2.2.3_

`swapcase(s)'
     Return a copy of S, but with lower case letters converted to upper
     case and vice versa.

`translate(s, table[, deletechars])'
     Delete all characters from S that are in DELETECHARS (if present),
     and then translate the characters using TABLE, which must be a
     256-character string giving the translation for each character
     value, indexed by its ordinal.

`upper(s)'
     Return a copy of S, but with lower case letters converted to upper
     case.

`ljust(s, width)'

`rjust s, width'

`center s, width'
     These functions respectively left-justify, right-justify and center
     a string in a field of given width.  They return a string that is
     at least WIDTH characters wide, created by padding the string S
     with spaces until the given width on the right, left or both
     sides.  The string is never truncated.

`zfill(s, width)'
     Pad a numeric string on the left with zero digits until the given
     width is reached.  Strings starting with a sign are handled
     correctly.

`replace(str, old, new[, maxsplit])'
     Return a copy of string STR with all occurrences of substring OLD
     replaced by NEW.  If the optional argument MAXSPLIT is given, the
     first MAXSPLIT occurrences are replaced.


File: python-lib.info,  Node: re,  Next: struct,  Prev: string,  Up: String Services

Regular expression operations
=============================

Regular expression search and match operations with a Perl-style
expression syntax.

This module provides regular expression matching operations similar to
those found in Perl.  Regular expression pattern strings may not
contain null bytes, but can specify the null byte using the `\NUMBER'
notation.  Both patterns and strings to be searched can be Unicode
strings as well as 8-bit strings.  The `re' module is always available.

Regular expressions use the backslash character (`\') to indicate
special forms or to allow special characters to be used without
invoking their special meaning.  This collides with Python's usage of
the same character for the same purpose in string literals; for
example, to match a literal backslash, one might have to write `'\\\\''
as the pattern string, because the regular expression must be `\\', and
each backslash must be expressed as `\\' inside a regular Python string
literal.

The solution is to use Python's raw string notation for regular
expression patterns; backslashes are not handled in any special way in
a string literal prefixed with `r'.  So `r"\n"' is a two-character
string containing `\' and `n', while `"\n"' is a one-character string
containing a newline.  Usually patterns will be expressed in Python
code using this raw string notation.

See also:
     `Mastering Regular Expressions'{Book on regular expressions by
     Jeffrey Friedl, published by O'Reilly.  The second  edition of the
     book no longer covers Python at all,  but the first edition
     covered writing good regular expression patterns in great detail.}

* Menu:

* Regular Expression Syntax::
* Matching vs Searching::
* Contents of Module re::
* Regular Expression Objects::
* Match Objects::
* Examples 2::


File: python-lib.info,  Node: Regular Expression Syntax,  Next: Matching vs Searching,  Prev: re,  Up: re

Regular Expression Syntax
-------------------------

A regular expression (or RE) specifies a set of strings that matches
it; the functions in this module let you check if a particular string
matches a given regular expression (or if a given regular expression
matches a particular string, which comes down to the same thing).

Regular expressions can be concatenated to form new regular
expressions; if _A_ and _B_ are both regular expressions, then _AB_ is
also a regular expression.  In general, if a string _p_ matches _A_ and
another string _q_ matches _B_, the string _pq_ will match AB.  This
holds unless _A_ or _B_ contain low precedence operations; boundary
conditions between _A_ and _B_; or have numbered group references.
Thus, complex expressions can easily be constructed from simpler
primitive expressions like the ones described here.  For details of the
theory and implementation of regular expressions, consult the Friedl
book referenced above, or almost any textbook about compiler
construction.

A brief explanation of the format of regular expressions follows.  For
further information and a gentler presentation, consult the Regular
Expression HOWTO, accessible from <http://www.python.org/doc/howto/>.

Regular expressions can contain both special and ordinary characters.
Most ordinary characters, like `A', `a', or `0', are the simplest
regular expressions; they simply match themselves.  You can concatenate
ordinary characters, so "last" matches the string `'last''.  (In the
rest of this section, we'll write RE's in "this special style", usually
without quotes, and strings to be matched `'in single quotes''.)

Some characters, like `|' or `(', are special.  Special characters
either stand for classes of ordinary characters, or affect how the
regular expressions around them are interpreted.

The special characters are:

``.''
     (Dot.)  In the default mode, this matches any character except a
     newline.  If the `DOTALL' flag has been specified, this matches
     any character including a newline.

``^''
     (Caret.)  Matches the start of the string, and in `MULTILINE' mode
     also matches immediately after each newline.

``$''
     Matches the end of the string or just before the newline at the
     end of the string, and in `MULTILINE' mode also matches before a
     newline.  "foo" matches both 'foo' and 'foobar', while the regular
     expression "foo$" matches only 'foo'.  More interestingly,
     searching for "foo.$" in 'foo1\nfoo2\n' matches 'foo2' normally,
     but 'foo1' in `MULTILINE' mode.

``*''
     Causes the resulting RE to match 0 or more repetitions of the
     preceding RE, as many repetitions as are possible.  "ab*" will
     match 'a', 'ab', or 'a' followed by any number of 'b's.

``+''
     Causes the resulting RE to match 1 or more repetitions of the
     preceding RE.  "ab+" will match 'a' followed by any non-zero
     number of 'b's; it will not match just 'a'.

``?''
     Causes the resulting RE to match 0 or 1 repetitions of the
     preceding RE.  "ab?" will match either 'a' or 'ab'.

``*?', `+?', `??''
     The `*', `+', and `?' qualifiers are all "greedy"; they match as
     much text as possible.  Sometimes this behaviour isn't desired; if
     the RE "<.*>" is matched against `'<H1>title</H1>'', it will match
     the entire string, and not just `'<H1>''.  Adding `?' after the
     qualifier makes it perform the match in "non-greedy" or "minimal"
     fashion; as _few_ characters as possible will be matched.  Using
     ".*?"  in the previous expression will match only `'<H1>''.

``{M}''
     Specifies that exactly M copies of the previous RE should be
     matched; fewer matches cause the entire RE not to match.  For
     example, "a{6}" will match exactly six `a' characters, but not
     five.

``{M,N}''
     Causes the resulting RE to match from M to N repetitions of the
     preceding RE, attempting to match as many repetitions as possible.
     For example, "a{3,5}" will match from 3 to 5 `a' characters.
     Omitting M specifies a lower bound of zero, and omitting N
     specifies an infinite upper bound.  As an example, "a{4,}b" will
     match `aaaab' or a thousand `a' characters followed by a `b', but
     not `aaab'.  The comma may not be omitted or the modifier would be
     confused with the previously described form.

``{M,N}?''
     Causes the resulting RE to match from M to N repetitions of the
     preceding RE, attempting to match as _few_ repetitions as
     possible.  This is the non-greedy version of the previous
     qualifier.  For example, on the 6-character string `'aaaaaa'',
     "a{3,5}" will match 5 `a' characters, while "a{3,5}?" will only
     match 3 characters.

``\''
     Either escapes special characters (permitting you to match
     characters like `*', `?', and so forth), or signals a special
     sequence; special sequences are discussed below.

     If you're not using a raw string to express the pattern, remember
     that Python also uses the backslash as an escape sequence in
     string literals; if the escape sequence isn't recognized by
     Python's parser, the backslash and subsequent character are
     included in the resulting string.  However, if Python would
     recognize the resulting sequence, the backslash should be repeated
     twice.  This is complicated and hard to understand, so it's highly
     recommended that you use raw strings for all but the simplest
     expressions.

``[ '] Used to indicate a set of characters.  Characters can'
     be listed individually, or a range of characters can be indicated
     by giving two characters and separating them by a `-'.  Special
     characters are not active inside sets.  For example, "[akm$]" will
     match any of the characters `a', `k', `m', or `$'; "[a-z]" will
     match any lowercase letter, and `[a-zA-Z0-9]' matches any letter
     or digit.  Character classes such as `\w' or `\S' (defined below)
     are also acceptable inside a range.  If you want to include a `]'
     or a `-' inside a set, precede it with a backslash, or place it as
     the first character.  The pattern "[]]" will match `']'', for
     example.

     You can match the characters not within a range by "complementing"
     the set.  This is indicated by including a `^' as the first
     character of the set; `^' elsewhere will simply match the `^'
     character.  For example, "[{^}5]" will match any character except
     `5', and "[^`^']" will match any character except `^'.

``|''
     `A|B', where A and B can be arbitrary REs, creates a regular
     expression that will match either A or B.  An arbitrary number of
     REs can be separated by the `|' in this way.  This can be used
     inside groups (see below) as well.  As the target string is
     scanned, REs separated by `|' are tried from left to right. When
     one pattern completely matches, that branch is accepted.  This
     means that once `A' matches, `B' will not be tested further, even
     if it would produce a longer overall match.  In other words, the
     `|' operator is never greedy.  To match a literal `|', use "\|",
     or enclose it inside a character class, as in "[|]".

``(...)''
     Matches whatever regular expression is inside the parentheses, and
     indicates the start and end of a group; the contents of a group
     can be retrieved after a match has been performed, and can be
     matched later in the string with the "\NUMBER" special sequence,
     described below.  To match the literals `(' or `)', use "\(" or
     "\)", or enclose them inside a character class: "[(] [)]".

``(?...)''
     This is an extension notation (a `?' following a `(' is not
     meaningful otherwise).  The first character after the `?'
     determines what the meaning and further syntax of the construct is.
     Extensions usually do not create a new group; "(?P<NAME>...)" is
     the only exception to this rule.  Following are the currently
     supported extensions.

``(?iLmsux)''
     (One or more letters from the set `i', `L', `m', `s', `u', `x'.)
     The group matches the empty string; the letters set the
     corresponding flags (`re.I', `re.L', `re.M', `re.S', `re.U',
     `re.X') for the entire regular expression.  This is useful if you
     wish to include the flags as part of the regular expression,
     instead of passing a FLAG argument to the `compile()' function.

     Note that the "(?x)" flag changes how the expression is parsed.
     It should be used first in the expression string, or after one or
     more whitespace characters.  If there are non-whitespace
     characters before the flag, the results are undefined.

``(?:...)''
     A non-grouping version of regular parentheses.  Matches whatever
     regular expression is inside the parentheses, but the substring
     matched by the group _cannot_ be retrieved after performing a
     match or referenced later in the pattern.

``(?P<NAME>...)''
     Similar to regular parentheses, but the substring matched by the
     group is accessible via the symbolic group name NAME.  Group names
     must be valid Python identifiers, and each group name must be
     defined only once within a regular expression.  A symbolic group
     is also a numbered group, just as if the group were not named.  So
     the group named 'id' in the example above can also be referenced
     as the numbered group 1.

     For example, if the pattern is "(?P<id>[a-zA-Z_]\w*)", the group
     can be referenced by its name in arguments to methods of match
     objects, such as `m.group('id')' or `m.end('id')', and also by
     name in pattern text (for example, "(?P=id)") and replacement text
     (such as `\g<id>').

``(?P=NAME)''
     Matches whatever text was matched by the earlier group named NAME.

``(?#...)''
     A comment; the contents of the parentheses are simply ignored.

``(?=...)''
     Matches if "..." matches next, but doesn't consume any of the
     string.  This is called a lookahead assertion.  For example,
     "Isaac (?=Asimov)" will match `'Isaac~'' only if it's followed by
     `'Asimov''.

``(?!...)''
     Matches if "..." doesn't match next.  This is a negative lookahead
     assertion.  For example, "Isaac (?!Asimov)" will match `'Isaac~''
     only if it's _not_ followed by `'Asimov''.

``(?<=...)''
     Matches if the current position in the string is preceded by a
     match for "..." that ends at the current position.  This is called
     a "positive lookbehind assertion".  "(?<=abc)def" will find a
     match in `abcdef', since the lookbehind will back up 3 characters
     and check if the contained pattern matches.  The contained pattern
     must only match strings of some fixed length, meaning that "abc"
     or "a|b" are allowed, but "a*" and "a{3,4}" are not.  Note that
     patterns which start with positive lookbehind assertions will never
     match at the beginning of the string being searched; you will most
     likely want to use the `search()' function rather than the
     `match()' function:

          >>> import re
          >>> m = re.search('(?<=abc)def', 'abcdef')
          >>> m.group(0)
          'def'

     This example looks for a word following a hyphen:

          >>> m = re.search('(?<=-)\w+', 'spam-egg')
          >>> m.group(0)
          'egg'

``(?<!...)''
     Matches if the current position in the string is not preceded by a
     match for "...".  This is called a "negative lookbehind
     assertion".  Similar to positive lookbehind assertions, the
     contained pattern must only match strings of some fixed length.
     Patterns which start with negative lookbehind assertions may match
     at the beginning of the string being searched.

The special sequences consist of `\' and a character from the list
below.  If the ordinary character is not on the list, then the
resulting RE will match the second character.  For example, "\$"
matches the character `$'.

``\NUMBER''
     Matches the contents of the group of the same number.  Groups are
     numbered starting from 1.  For example, "(.+) \1" matches `'the
     the'' or `'55 55'', but not `'the end'' (note the space after the
     group).  This special sequence can only be used to match one of
     the first 99 groups.  If the first digit of NUMBER is 0, or NUMBER
     is 3 octal digits long, it will not be interpreted as a group
     match, but as the character with octal value NUMBER.  Inside the
     `[' and `]' of a character class, all numeric escapes are treated
     as characters.

``\A''
     Matches only at the start of the string.

``\b''
     Matches the empty string, but only at the beginning or end of a
     word.  A word is defined as a sequence of alphanumeric or
     underscore characters, so the end of a word is indicated by
     whitespace or a non-alphanumeric, non-underscore character.  Note
     that {}`\b' is defined as the boundary between `\w' and `\W', so
     the precise set of characters deemed to be alphanumeric depends on
     the values of the `UNICODE' and `LOCALE' flags.  Inside a character
     range, "\b" represents the backspace character, for compatibility
     with Python's string literals.

``\B''
     Matches the empty string, but only when it is _not_ at the
     beginning or end of a word.  This is just the opposite of {}`\b',
     so is also subject to the settings of `LOCALE' and `UNICODE'.

``\d''
     Matches any decimal digit; this is equivalent to the set "[0-9]".

``\D''
     Matches any non-digit character; this is equivalent to the set
     "[{^}0-9]".

``\s''
     Matches any whitespace character; this is equivalent to the set "[
     \t\n\r\f\v]".

``\S''
     Matches any non-whitespace character; this is equivalent to the
     set "[^ \t\n\r\f\v]".

``\w''
     When the `LOCALE' and `UNICODE' flags are not specified, matches
     any alphanumeric character and the underscore; this is equivalent
     to the set "[a-zA-Z0-9_]".  With `LOCALE', it will match the set
     "[0-9_]" plus whatever characters are defined as alphanumeric for
     the current locale.  If `UNICODE' is set, this will match the
     characters "[0-9_]" plus whatever is classified as alphanumeric in
     the Unicode character properties database.

``\W''
     When the `LOCALE' and `UNICODE' flags are not specified, matches
     any non-alphanumeric character; this is equivalent to the set
     "[{^}a-zA-Z0-9_]".   With `LOCALE', it will match any character
     not in the set "[0-9_]", and not defined as alphanumeric for the
     current locale.  If `UNICODE' is set, this will match anything
     other than "[0-9_]" and characters marked as alphanumeric in the
     Unicode character properties database.

``\Z''
     Matches only at the end of the string.

Most of the standard escapes supported by Python string literals are
also accepted by the regular expression parser:

     \a      \b      \f      \n
     \r      \t      \v      \x
     \\

Octal escapes are included in a limited form: If the first digit is a
0, or if there are three octal digits, it is considered an octal
escape. Otherwise, it is a group reference.


File: python-lib.info,  Node: Matching vs Searching,  Next: Contents of Module re,  Prev: Regular Expression Syntax,  Up: re

Matching vs Searching
---------------------

Python offers two different primitive operations based on regular
expressions: match and search.  If you are accustomed to Perl's
semantics, the search operation is what you're looking for.  See the
`search()' function and corresponding method of compiled regular
expression objects.

Note that match may differ from search using a regular expression
beginning with `^': `^' matches only at the start of the string, or in
`MULTILINE' mode also immediately following a newline.  The "match"
operation succeeds only if the pattern matches at the start of the
string regardless of mode, or at the starting position given by the
optional POS argument regardless of whether a newline precedes it.

     re.compile("a").match("ba", 1)           # succeeds
     re.compile("^a").search("ba", 1)         # fails; 'a' not at start
     re.compile("^a").search("\na", 1)        # fails; 'a' not at start
     re.compile("^a", re.M).search("\na", 1)  # succeeds
     re.compile("^a", re.M).search("ba", 1)   # fails; no preceding \n


File: python-lib.info,  Node: Contents of Module re,  Next: Regular Expression Objects,  Prev: Matching vs Searching,  Up: re

Module Contents
---------------

The module defines the following functions and constants, and an
exception:

`compile(pattern[, flags])'
     Compile a regular expression pattern into a regular expression
     object, which can be used for matching using its `match()' and
     `search()' methods, described below.

     The expression's behaviour can be modified by specifying a FLAGS
     value.  Values can be any of the following variables, combined
     using bitwise OR (the `|' operator).

     The sequence

          prog = re.compile(pat)
          result = prog.match(str)

     is equivalent to

          result = re.match(pat, str)

     but the version using `compile()' is more efficient when the
     expression will be used several times in a single program.

`I'

`IGNORECASE'
     Perform case-insensitive matching; expressions like "[A-Z]" will
     match lowercase letters, too.  This is not affected by the current
     locale.

`L'

`LOCALE'
     Make "\w", "\W", "\b", and "\B" dependent on the current locale.

`M'

`MULTILINE'
     When specified, the pattern character `^' matches at the beginning
     of the string and at the beginning of each line (immediately
     following each newline); and the pattern character `$' matches at
     the end of the string and at the end of each line (immediately
     preceding each newline).  By default, `^' matches only at the
     beginning of the string, and `$' only at the end of the string and
     immediately before the newline (if any) at the end of the string.

`S'

`DOTALL'
     Make the `.' special character match any character at all,
     including a newline; without this flag, `.' will match anything
     _except_ a newline.

`U'

`UNICODE'
     Make "\w", "\W", "\b", and "\B" dependent on the Unicode character
     properties database.  _Added in Python version 2.0_

`X'

`VERBOSE'
     This flag allows you to write regular expressions that look nicer.
     Whitespace within the pattern is ignored, except when in a
     character class or preceded by an unescaped backslash, and, when a
     line contains a `#' neither in a character class or preceded by an
     unescaped backslash, all characters from the leftmost such `#'
     through the end of the line are ignored.

`search(pattern, string[, flags])'
     Scan through STRING looking for a location where the regular
     expression PATTERN produces a match, and return a corresponding
     `MatchObject' instance.  Return `None' if no position in the
     string matches the pattern; note that this is different from
     finding a zero-length match at some point in the string.

`match(pattern, string[, flags])'
     If zero or more characters at the beginning of STRING match the
     regular expression PATTERN, return a corresponding `MatchObject'
     instance.  Return `None' if the string does not match the pattern;
     note that this is different from a zero-length match.

     _Note:_ If you want to locate a match anywhere in STRING, use
     `search()' instead.

`split(pattern, string[, maxsplit` = 0'])'
     Split STRING by the occurrences of PATTERN.  If capturing
     parentheses are used in PATTERN, then the text of all groups in
     the pattern are also returned as part of the resulting list.  If
     MAXSPLIT is nonzero, at most MAXSPLIT splits occur, and the
     remainder of the string is returned as the final element of the
     list.  (Incompatibility note: in the original Python 1.5 release,
     MAXSPLIT was ignored.  This has been fixed in later releases.)

          >>> re.split('\W+', 'Words, words, words.')
          ['Words', 'words', 'words', '']
          >>> re.split('(\W+)', 'Words, words, words.')
          ['Words', ', ', 'words', ', ', 'words', '.', '']
          >>> re.split('\W+', 'Words, words, words.', 1)
          ['Words', 'words, words.']

     This function combines and extends the functionality of the old
     `regsub.split()' and `regsub.splitx()'.

`findall(pattern, string)'
     Return a list of all non-overlapping matches of PATTERN in STRING.
     If one or more groups are present in the pattern, return a list
     of groups; this will be a list of tuples if the pattern has more
     than one group.  Empty matches are included in the result unless
     they touch the beginning of another match.  _Added in Python
     version 1.5.2_

`finditer(pattern, string)'
     Return an iterator over all non-overlapping matches for the RE
     PATTERN in STRING.  For each match, the iterator returns a match
     object.  Empty matches are included in the result unless they
     touch the beginning of another match.  _Added in Python version
     2.2_

`sub(pattern, repl, string[, count])'
     Return the string obtained by replacing the leftmost
     non-overlapping occurrences of PATTERN in STRING by the replacement
     REPL.  If the pattern isn't found, STRING is returned unchanged.
     REPL can be a string or a function; if it is a string, any
     backslash escapes in it are processed.  That is, `\n' is converted
     to a single newline character, `\r' is converted to a linefeed,
     and so forth.  Unknown escapes such as `\j' are left alone.
     Backreferences, such as `\6', are replaced with the substring
     matched by group 6 in the pattern.  For example:

          >>> re.sub(r'def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):',
          ...        r'static PyObject*\npy_\1(void)\n{',
          ...        'def myfunc():')
          'static PyObject*\npy_myfunc(void)\n{'

     If REPL is a function, it is called for every non-overlapping
     occurrence of PATTERN.  The function takes a single match object
     argument, and returns the replacement string.  For example:

          >>> def dashrepl(matchobj):
          ....    if matchobj.group(0) == '-': return ' '
          ....    else: return '-'
          >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files')
          'pro--gram files'

     The pattern may be a string or an RE object; if you need to specify
     regular expression flags, you must use a RE object, or use embedded
     modifiers in a pattern; for example, `sub("(?i)b+", "x", "bbbb
     BBBB")' returns `'x x''.

     The optional argument COUNT is the maximum number of pattern
     occurrences to be replaced; COUNT must be a non-negative integer.
     If omitted or zero, all occurrences will be replaced.  Empty
     matches for the pattern are replaced only when not adjacent to a
     previous match, so `sub('x*', '-', 'abc')' returns `'-a-b-c-''.

     In addition to character escapes and backreferences as described
     above, `\g<name>' will use the substring matched by the group
     named `name', as defined by the "(?P<name>...)" syntax.
     `\g<number>' uses the corresponding group number; `\g<2>' is
     therefore equivalent to `\2', but isn't ambiguous in a replacement
     such as `\g<2>0'.  `\20' would be interpreted as a reference to
     group 20, not a reference to group 2 followed by the literal
     character `0'.  The backreference `\g<0>' substitutes in the
     entire substring matched by the RE.

`subn(pattern, repl, string[, count])'
     Perform the same operation as `sub()', but return a tuple
     `(NEW_STRING, NUMBER_OF_SUBS_MADE)'.

`escape(string)'
     Return STRING with all non-alphanumerics backslashed; this is
     useful if you want to match an arbitrary literal string that may
     have regular expression metacharacters in it.

`error'
     Exception raised when a string passed to one of the functions here
     is not a valid regular expression (for example, it might contain
     unmatched parentheses) or when some other error occurs during
     compilation or matching.  It is never an error if a string contains
     no match for a pattern.


File: python-lib.info,  Node: Regular Expression Objects,  Next: Match Objects,  Prev: Contents of Module re,  Up: re

Regular Expression Objects
--------------------------

Compiled regular expression objects support the following methods and
attributes:

`match(string[, pos[, endpos]])'
     If zero or more characters at the beginning of STRING match this
     regular expression, return a corresponding `MatchObject' instance.
     Return `None' if the string does not match the pattern; note that
     this is different from a zero-length match.

     _Note:_ If you want to locate a match anywhere in STRING, use
     `search()' instead.

     The optional second parameter POS gives an index in the string
     where the search is to start; it defaults to `0'.  This is not
     completely equivalent to slicing the string; the `'^'' pattern
     character matches at the real beginning of the string and at
     positions just after a newline, but not necessarily at the index
     where the search is to start.

     The optional parameter ENDPOS limits how far the string will be
     searched; it will be as if the string is ENDPOS characters long,
     so only the characters from POS to `ENDPOS - 1' will be searched
     for a match.  If ENDPOS is less than POS, no match will be found,
     otherwise, if RX is a compiled regular expression object,
     `RX.match(STRING, 0, 50)' is equivalent to `RX.match(STRING[:50],
     0)'.

`search(string[, pos[, endpos]])'
     Scan through STRING looking for a location where this regular
     expression produces a match, and return a corresponding
     `MatchObject' instance.  Return `None' if no position in the
     string matches the pattern; note that this is different from
     finding a zero-length match at some point in the string.

     The optional POS and ENDPOS parameters have the same meaning as
     for the `match()' method.

`split(string[, maxsplit` = 0'])'
     Identical to the `split()' function, using the compiled pattern.

`findall(string)'
     Identical to the `findall()' function, using the compiled pattern.

`finditer(string)'
     Identical to the `finditer()' function, using the compiled pattern.

`sub(repl, string[, count` = 0'])'
     Identical to the `sub()' function, using the compiled pattern.

`subn(repl, string[, count` = 0'])'
     Identical to the `subn()' function, using the compiled pattern.

`flags'
     The flags argument used when the RE object was compiled, or `0' if
     no flags were provided.

`groupindex'
     A dictionary mapping any symbolic group names defined by
     "(?P<ID>)" to group numbers.  The dictionary is empty if no
     symbolic groups were used in the pattern.

`pattern'
     The pattern string from which the RE object was compiled.


File: python-lib.info,  Node: Match Objects,  Next: Examples 2,  Prev: Regular Expression Objects,  Up: re

Match Objects
-------------

`MatchObject' instances support the following methods and attributes:

`expand(template)'
     Return the string obtained by doing backslash substitution on the
     template string TEMPLATE, as done by the `sub()' method.  Escapes
     such as `\n' are converted to the appropriate characters, and
     numeric backreferences (`\1', `\2') and named backreferences
     (`\g<1>', `\g<name>') are replaced by the contents of the
     corresponding group.

`group([group1, ...])'
     Returns one or more subgroups of the match.  If there is a single
     argument, the result is a single string; if there are multiple
     arguments, the result is a tuple with one item per argument.
     Without arguments, GROUP1 defaults to zero (the whole match is
     returned).  If a GROUPN argument is zero, the corresponding return
     value is the entire matching string; if it is in the inclusive
     range [1..99], it is the string matching the corresponding
     parenthesized group.  If a group number is negative or larger than
     the number of groups defined in the pattern, an `IndexError'
     exception is raised.  If a group is contained in a part of the
     pattern that did not match, the corresponding result is `None'.
     If a group is contained in a part of the pattern that matched
     multiple times, the last match is returned.

     If the regular expression uses the "(?P<NAME>...)" syntax, the
     GROUPN arguments may also be strings identifying groups by their
     group name.  If a string argument is not used as a group name in
     the pattern, an `IndexError' exception is raised.

     A moderately complicated example:

          m = re.match(r"(?P<int>\d+)\.(\d*)", '3.14')

     After performing this match, `m.group(1)' is `'3'', as is
     `m.group('int')', and `m.group(2)' is `'14''.

`groups([default])'
     Return a tuple containing all the subgroups of the match, from 1
     up to however many groups are in the pattern.  The DEFAULT
     argument is used for groups that did not participate in the match;
     it defaults to `None'.  (Incompatibility note: in the original
     Python 1.5 release, if the tuple was one element long, a string
     would be returned instead.  In later versions (from 1.5.1 on), a
     singleton tuple is returned in such cases.)

`groupdict([default])'
     Return a dictionary containing all the _named_ subgroups of the
     match, keyed by the subgroup name.  The DEFAULT argument is used
     for groups that did not participate in the match; it defaults to
     `None'.

`start([group])'

`end([group])'
     Return the indices of the start and end of the substring matched
     by GROUP; GROUP defaults to zero (meaning the whole matched
     substring).  Return `-1' if GROUP exists but did not contribute to
     the match.  For a match object M, and a group G that did
     contribute to the match, the substring matched by group G
     (equivalent to `M.group(G)') is

          m.string[m.start(g):m.end(g)]

     Note that `m.start(GROUP)' will equal `m.end(GROUP)' if GROUP
     matched a null string.  For example, after `M = re.search('b(c?)',
     'cba')', `M.start(0)' is 1, `M.end(0)' is 2, `M.start(1)' and
     `M.end(1)' are both 2, and `M.start(2)' raises an `IndexError'
     exception.

`span([group])'
     For `MatchObject' M, return the 2-tuple `(M.start(GROUP),
     M.end(GROUP))'.  Note that if GROUP did not contribute to the
     match, this is `(-1, -1)'.  Again, GROUP defaults to zero.

`pos'
     The value of POS which was passed to the `search()' or `match()'
     method of the `RegexObject'.  This is the index into the string at
     which the RE engine started looking for a match.

`endpos'
     The value of ENDPOS which was passed to the `search()' or
     `match()' method of the `RegexObject'.  This is the index into the
     string beyond which the RE engine will not go.

`lastindex'
     The integer index of the last matched capturing group, or `None'
     if no group was matched at all. For example, the expressions
     "(a)b", "((a)(b))", and "((ab))" will have `lastindex == 1' if
     applyied to the string `'ab'', while the expression "(a)(b)" will
     have `lastindex == 2', if applyied to the same string.

`lastgroup'
     The name of the last matched capturing group, or `None' if the
     group didn't have a name, or if no group was matched at all.

`re'
     The regular expression object whose `match()' or `search()' method
     produced this `MatchObject' instance.

`string'
     The string passed to `match()' or `search()'.

