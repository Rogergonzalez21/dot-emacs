This is python-lib.info, produced by makeinfo version 4.3 from
python-lib.texi.

October 3, 2003


File: python-lib.info,  Node: testtest_support,  Next: math,  Prev: test,  Up: Miscellaneous Services

Utility functions for tests
===========================

Support for Python regression tests.

The `test.test_support' module provides support for Python's regression
tests.

This module defines the following exceptions:

`TestFailed'
     Exception to be raised when a test fails.

`TestSkipped'
     Subclass of `TestFailed'.  Raised when a test is skipped.  This
     occurs when a needed resource (such as a network connection) is not
     available at the time of testing.

`ResourceDenied'
     Subclass of `TestSkipped'.  Raised when a resource (such as a
     network connection) is not available.  Raised by the `requires()'
     function.

The `test.test_support' module defines the following constants:

`verbose'
     `True' when verbose output is enabled.  Should be checked when
     more detailed information is desired about a running test.
     VERBOSE is set by `test.regrtest'.

`have_unicode'
     `True' when Unicode support is available.

`is_jython'
     `True' if the running interpreter is Jython.

`TESTFN'
     Set to the path that a temporary file may be created at.  Any
     temporary that is created should be closed and unlinked (removed).

The `test.test_support' module defines the following functions:

`forget(module_name)'
     Removes the module named MODULE_NAME from `sys.modules' and deletes
     any byte-compiled files of the module.

`is_resource_enabled(resource)'
     Returns `True' if RESOURCE is enabled and available.  The list of
     available resources is only set when `test.regrtest' is executing
     the tests.

`requires(resource[, msg])'
     Raises `ResourceDenied' if RESOURCE is not available.  MSG is the
     argument to `ResourceDenied' if it is raised.  Always returns true
     if called by a function whose `__name__' is `'__main__''.  Used
     when tests are executed by `test.regrtest'.

`findfile(filename)'
     Return the path to the file named FILENAME.  If no match is found
     FILENAME is returned.  This does not equal a failure since it
     could be the path to the file.

`run_unittest(*classes)'
     Execute `unittest.TestCase' subclasses passed to the function.
     The function scans the classes for methods starting with the prefix
     `test_' and executes the tests individually.  This is the
     preferred way to execute tests.

`run_suite(suite[, testclass])'
     Execute the `unittest.TestSuite' instance SUITE.  The optional
     argument TESTCLASS accepts one of the test classes in the suite so
     as to print out more detailed information on where the testing
     suite originated from.


File: python-lib.info,  Node: math,  Next: cmath,  Prev: testtest_support,  Up: Miscellaneous Services

Mathematical functions
======================

Mathematical functions (`sin()' etc.).

This module is always available.  It provides access to the
mathematical functions defined by the C standard.

These functions cannot be used with complex numbers; use the functions
of the same name from the `cmath' module if you require support for
complex numbers.  The distinction between functions which support
complex numbers and those which don't is made since most users do not
want to learn quite as much mathematics as required to understand
complex numbers.  Receiving an exception instead of a complex result
allows earlier detection of the unexpected complex number used as a
parameter, so that the programmer can determine how and why it was
generated in the first place.

The following functions are provided by this module.  Except when
explicitly noted otherwise, all return values are floats:

`acos(x)'
     Return the arc cosine of X.

`asin(x)'
     Return the arc sine of X.

`atan(x)'
     Return the arc tangent of X.

`atan2(y, x)'
     Return `atan(Y / X)'.

`ceil(x)'
     Return the ceiling of X as a float.

`cos(x)'
     Return the cosine of X.

`cosh(x)'
     Return the hyperbolic cosine of X.

`degrees(x)'
     Converts angle X from radians to degrees.

`exp(x)'
     Return `e**X'.

`fabs(x)'
     Return the absolute value of X.

`floor(x)'
     Return the floor of X as a float.

`fmod(x, y)'
     Return `fmod(X, Y)', as defined by the platform C library.  Note
     that the Python expression `X % Y' may not return the same result.

`frexp(x)'
     Return the mantissa and exponent of X as the pair `(M, E)'.  M is
     a float and E is an integer such that `X == M * 2**E'.  If X is
     zero, returns `(0.0, 0)', otherwise `0.5 <= abs(M) < 1'.

`hypot(x, y)'
     Return the Euclidean distance, `sqrt(X*X + Y*Y)'.

`ldexp(x, i)'
     Return `X * (2**I)'.

`log(x[, base])'
     Returns the logarithm of X to the given BASE.  If the BASE is not
     specified, returns the natural logarithm of X.  _Changed in Python
     version 2.3_

`log10(x)'
     Return the base-10 logarithm of X.

`modf(x)'
     Return the fractional and integer parts of X.  Both results carry
     the sign of X.  The integer part is returned as a float.

`pow(x, y)'
     Return `X**Y'.

`radians(x)'
     Converts angle X from degrees to radians.

`sin(x)'
     Return the sine of X.

`sinh(x)'
     Return the hyperbolic sine of X.

`sqrt(x)'
     Return the square root of X.

`tan(x)'
     Return the tangent of X.

`tanh(x)'
     Return the hyperbolic tangent of X.

Note that `frexp()' and `modf()' have a different call/return pattern
than their C equivalents: they take a single argument and return a pair
of values, rather than returning their second return value through an
`output parameter' (there is no such thing in Python).

The module also defines two mathematical constants:

`pi'
     The mathematical constant _pi_.

`e'
     The mathematical constant _e_.

_Notice:_ The `math' module consists mostly of thin wrappers around the
platform C math library functions.  Behavior in exceptional cases is
loosely specified by the C standards, and Python inherits much of its
math-function error-reporting behavior from the platform C
implementation.  As a result, the specific exceptions raised in error
cases (and even whether some arguments are considered to be exceptional
at all) are not defined in any useful cross-platform or cross-release
way.  For example, whether `math.log(0)' returns `-Inf' or raises
`ValueError' or `OverflowError' isn't defined, and in cases where
`math.log(0)' raises `OverflowError', `math.log(0L)' may raise
`ValueError' instead.

See also:
     *Note cmath:: Complex number versions of many of these functions.


File: python-lib.info,  Node: cmath,  Next: random,  Prev: math,  Up: Miscellaneous Services

Mathematical functions for complex numbers
==========================================

Mathematical functions for complex numbers.

This module is always available.  It provides access to mathematical
functions for complex numbers.  The functions are:

`acos(x)'
     Return the arc cosine of X.  There are two branch cuts: One
     extends right from 1 along the real axis to _infinity_, continuous
     from below.  The other extends left from -1 along the real axis to
     -_infinity_, continuous from above.

`acosh(x)'
     Return the hyperbolic arc cosine of X.  There is one branch cut,
     extending left from 1 along the real axis to -_infinity_,
     continuous from above.

`asin(x)'
     Return the arc sine of X.  This has the same branch cuts as
     `acos()'.

`asinh(x)'
     Return the hyperbolic arc sine of X.  There are two branch cuts,
     extending left from +-`1j' to +-_infinity_`j', both continuous
     from above.  These branch cuts should be considered a bug to be
     corrected in a future release.  The correct branch cuts should
     extend along the imaginary axis, one from `1j' up to _infinity_`j'
     and continuous from the right, and one from -`1j' down to
     -_infinity_`j' and continuous from the left.

`atan(x)'
     Return the arc tangent of X.  There are two branch cuts: One
     extends from `1j' along the imaginary axis to _infinity_`j',
     continuous from the left.  The other extends from -`1j' along the
     imaginary axis to -_infinity_`j', continuous from the left.  (This
     should probably be changed so the upper cut becomes continuous
     from the other side.)

`atanh(x)'
     Return the hyperbolic arc tangent of X.  There are two branch cuts:
     One extends from 1 along the real axis to _infinity_, continuous
     from above.  The other extends from -1 along the real axis to
     -_infinity_, continuous from above.  (This should probably be
     changed so the right cut becomes continuous from the other side.)

`cos(x)'
     Return the cosine of X.

`cosh(x)'
     Return the hyperbolic cosine of X.

`exp(x)'
     Return the exponential value `e**X'.

`log(x)'
     Return the natural logarithm of X.  There is one branch cut, from
     0 along the negative real axis to -_infinity_, continuous from
     above.

`log10(x)'
     Return the base-10 logarithm of X.  This has the same branch cut
     as `log()'.

`sin(x)'
     Return the sine of X.

`sinh(x)'
     Return the hyperbolic sine of X.

`sqrt(x)'
     Return the square root of X.  This has the same branch cut as
     `log()'.

`tan(x)'
     Return the tangent of X.

`tanh(x)'
     Return the hyperbolic tangent of X.

The module also defines two mathematical constants:

`pi'
     The mathematical constant _pi_, as a real.

`e'
     The mathematical constant _e_, as a real.

Note that the selection of functions is similar, but not identical, to
that in module `math' .  The reason for having two modules is that some
users aren't interested in complex numbers, and perhaps don't even know
what they are.  They would rather have `math.sqrt(-1)' raise an
exception than return a complex number.  Also note that the functions
defined in `cmath' always return a complex number, even if the answer
can be expressed as a real number (in which case the complex number has
an imaginary part of zero).

A note on branch cuts: They are curves along which the given function
fails to be continuous.  They are a necessary feature of many complex
functions.  It is assumed that if you need to compute with complex
functions, you will understand about branch cuts.  Consult almost any
(not too elementary) book on complex variables for enlightenment.  For
information of the proper choice of branch cuts for numerical purposes,
a good reference should be the following:

See also:
     Kahan, W:  Branch cuts for complex elementary functions; or, Much
     ado about nothings's sign bit.  In Iserles, A., and Powell, M.
     (eds.), . Clarendon Press (1987) pp165-211.


File: python-lib.info,  Node: random,  Next: whrandom,  Prev: cmath,  Up: Miscellaneous Services

Generate pseudo-random numbers
==============================

Generate pseudo-random numbers with various common distributions.

This module implements pseudo-random number generators for various
distributions.

For integers, uniform selection from a range.  For sequences, uniform
selection of a random element, a function to generate a random
permutation of a list in-place, and a function for random sampling
without replacement.

On the real line, there are functions to compute uniform, normal
(Gaussian), lognormal, negative exponential, gamma, and beta
distributions.  For generating distributions of angles, the von Mises
distribution is available.

Almost all module functions depend on the basic function `random()',
which generates a random float uniformly in the semi-open range [0.0,
1.0).  Python uses the Mersenne Twister as the core generator.  It
produces 53-bit precision floats and has a period of 2**19937-1.  The
underlying implementation in C is both fast and threadsafe.  The
Mersenne Twister is one of the most extensively tested random number
generators in existence.  However, being completely deterministic, it
is not suitable for all purposes, and is completely unsuitable for
cryptographic purposes.

The functions supplied by this module are actually bound methods of a
hidden instance of the `random.Random' class.  You can instantiate your
own instances of `Random' to get generators that don't share state.
This is especially useful for multi-threaded programs, creating a
different instance of `Random' for each thread, and using the
`jumpahead()' method to ensure that the generated sequences seen by
each thread don't overlap.

Class `Random' can also be subclassed if you want to use a different
basic generator of your own devising: in that case, override the
`random()', `seed()', `getstate()', `setstate()' and `jumpahead()'
methods.

As an example of subclassing, the `random' module provides the
`WichmannHill' class which implements an alternative generator in pure
Python.  The class provides a backward compatible way to reproduce
results from earlier versions of Python which used the Wichmann-Hill
algorithm as the core generator.  _Changed in Python version 2.3_

Bookkeeping functions:

`seed([x])'
     Initialize the basic random number generator.  Optional argument X
     can be any hashable object.  If X is omitted or `None', current
     system time is used; current system time is also used to
     initialize the generator when the module is first imported.  If X
     is not `None' or an int or long, `hash(X)' is used instead.  If X
     is an int or long, X is used directly.

`getstate()'
     Return an object capturing the current internal state of the
     generator.  This object can be passed to `setstate()' to restore
     the state.  _Added in Python version 2.1_

`setstate(state)'
     STATE should have been obtained from a previous call to
     `getstate()', and `setstate()' restores the internal state of the
     generator to what it was at the time `setstate()' was called.
     _Added in Python version 2.1_

`jumpahead(n)'
     Change the internal state to one different from and likely far
     away from the current state.  N is a non-negative integer which is
     used to scramble the current state vector.  This is most useful in
     multi-threaded programs, in conjuction with multiple instances of
     the `Random' class: `setstate()' or `seed()' can be used to force
     all instances into the same internal state, and then `jumpahead()'
     can be used to force the instances' states far apart.  _Added in
     Python version 2.1_ _Changed in Python version 2.3_

Functions for integers:

`randrange([start,] stop[, step])'
     Return a randomly selected element from `range(START, STOP,
     STEP)'.  This is equivalent to `choice(range(START, STOP, STEP))',
     but doesn't actually build a range object.  _Added in Python
     version 1.5.2_

`randint(a, b)'
     Return a random integer N such that `A <= N <= B'.

Functions for sequences:

`choice(seq)'
     Return a random element from the non-empty sequence SEQ.

`shuffle(x[, random])'
     Shuffle the sequence X in place.  The optional argument RANDOM is
     a 0-argument function returning a random float in [0.0, 1.0); by
     default, this is the function `random()'.

     Note that for even rather small `len(X)', the total number of
     permutations of X is larger than the period of most random number
     generators; this implies that most permutations of a long sequence
     can never be generated.

`sample(population, k)'
     Return a K length list of unique elements chosen from the
     population sequence.  Used for random sampling without replacement.
     _Added in Python version 2.3_

     Returns a new list containing elements from the population while
     leaving the original population unchanged.  The resulting list is
     in selection order so that all sub-slices will also be valid random
     samples.  This allows raffle winners (the sample) to be partitioned
     into grand prize and second place winners (the subslices).

     Members of the population need not be hashable or unique.  If the
     population contains repeats, then each occurrence is a possible
     selection in the sample.

     To choose a sample from a range of integers, use `xrange' as an
     argument.  This is especially fast and space efficient for
     sampling from a large population:  `sample(xrange(10000000), 60)'.

The following functions generate specific real-valued distributions.
Function parameters are named after the corresponding variables in the
distribution's equation, as used in common mathematical practice; most
of these equations can be found in any statistics text.

`random()'
     Return the next random floating point number in the range [0.0,
     1.0).

`uniform(a, b)'
     Return a random real number N such that `A <= N < B'.

`betavariate(alpha, beta)'
     Beta distribution.  Conditions on the parameters are `ALPHA > -1'
     and `BETA > -1'.  Returned values range between 0 and 1.

`cunifvariate(mean, arc)'
     Circular uniform distribution.  MEAN is the mean angle, and ARC is
     the range of the distribution, centered around the mean angle.
     Both values must be expressed in radians, and can range between 0
     and _pi_.  Returned values range between `MEAN - ARC/2' and `MEAN
     + ARC/2' and are normalized to between 0 and _pi_.

     _This is deprecated in Python 2.3.  Instead, use `(MEAN + ARC *
     (random.random() - 0.5)) % math.pi'._

`expovariate(lambd)'
     Exponential distribution.  LAMBD is 1.0 divided by the desired
     mean.  (The parameter would be called "lambda", but that is a
     reserved word in Python.)  Returned values range from 0 to
     positive infinity.

`gammavariate(alpha, beta)'
     Gamma distribution.  (_Not_ the gamma function!)  Conditions on
     the parameters are `ALPHA > 0' and `BETA > 0'.

`gauss(mu, sigma)'
     Gaussian distribution.  MU is the mean, and SIGMA is the standard
     deviation.  This is slightly faster than the `normalvariate()'
     function defined below.

`lognormvariate(mu, sigma)'
     Log normal distribution.  If you take the natural logarithm of this
     distribution, you'll get a normal distribution with mean MU and
     standard deviation SIGMA.  MU can have any value, and SIGMA must
     be greater than zero.

`normalvariate(mu, sigma)'
     Normal distribution.  MU is the mean, and SIGMA is the standard
     deviation.

`vonmisesvariate(mu, kappa)'
     MU is the mean angle, expressed in radians between 0 and 2*_pi_,
     and KAPPA is the concentration parameter, which must be greater
     than or equal to zero.  If KAPPA is equal to zero, this
     distribution reduces to a uniform random angle over the range 0 to
     2*_pi_.

`paretovariate(alpha)'
     Pareto distribution.  ALPHA is the shape parameter.

`weibullvariate(alpha, beta)'
     Weibull distribution.  ALPHA is the scale parameter and BETA is
     the shape parameter.

Alternative Generator

`WichmannHill([seed])'
     Class that implements the Wichmann-Hill algorithm as the core
     generator.  Has all of the same methods as `Random' plus the
     `whseed' method described below.  Because this class is
     implemented in pure Python, it is not threadsafe and may require
     locks between calls.  The period of the generator is
     6,953,607,871,644 which is small enough to require care that two
     independent random sequences do not overlap.

`whseed([x])'
     This is obsolete, supplied for bit-level compatibility with
     versions of Python prior to 2.1.  See `seed' for details.
     `whseed' does not guarantee that distinct integer arguments yield
     distinct internal states, and can yield no more than about 2**24
     distinct internal states in all.

See also:
     M. Matsumoto and T. Nishimura, "Mersenne Twister: A
     623-dimensionally equidistributed uniform pseudorandom number
     generator",  Vol. 8, No. 1, January pp.3-30 1998.

     Wichmann, B. A. & Hill, I. D., "Algorithm AS 183: An efficient and
     portable pseudo-random number generator",  31 (1982) 188-190.


File: python-lib.info,  Node: whrandom,  Next: bisect,  Prev: random,  Up: Miscellaneous Services

Pseudo-random number generator
==============================

Floating point pseudo-random number generator.

_This is deprecated in Python 2.1.  Use `random' instead._

_Note:_ This module was an implementation detail of the `random' module
in releases of Python prior to 2.1.  It is no longer used.  Please do
not use this module directly; use `random' instead.

This module implements a Wichmann-Hill pseudo-random number generator
class that is also named `whrandom'.  Instances of the `whrandom' class
conform to the Random Number Generator interface described in section .
They also offer the following method, specific to the Wichmann-Hill
algorithm:

`seed([x, y, z])'
     Initializes the random number generator from the integers X, Y and
     Z.  When the module is first imported, the random number is
     initialized using values derived from the current time.  If X, Y,
     and Z are either omitted or `0', the seed will be computed from
     the current system time.  If one or two of the parameters are `0',
     but not all three, the zero values are replaced by ones.  This
     causes some apparently different seeds to be equal, with the
     corresponding result on the pseudo-random series produced by the
     generator.

`choice(seq)'
     Chooses a random element from the non-empty sequence SEQ and
     returns it.

`randint(a, b)'
     Returns a random integer N such that `A<=N<=B'.

`random()'
     Returns the next random floating point number in the range [0.0
     ... 1.0).

`seed(x, y, z)'
     Initializes the random number generator from the integers X, Y and
     Z.  When the module is first imported, the random number is
     initialized using values derived from the current time.

`uniform(a, b)'
     Returns a random real number N such that `A<=N<B'.

When imported, the `whrandom' module also creates an instance of the
`whrandom' class, and makes the methods of that instance available at
the module level.  Therefore one can write either `N =
whrandom.random()' or:

     generator = whrandom.whrandom()
     N = generator.random()

Note that using separate instances of the generator leads to
independent sequences of pseudo-random numbers.

See also:
     *Note random:: Generators for various random distributions and
     documentation for the Random Number Generator interface.
     Wichmann, B. A. & Hill, I. D., "Algorithm AS 183:  An efficient
     and portable pseudo-random number generator",  31 (1982) 188-190.


File: python-lib.info,  Node: bisect,  Next: heapq,  Prev: whrandom,  Up: Miscellaneous Services

Array bisection algorithm
=========================

Array bisection algorithms for binary searching.

This module provides support for maintaining a list in sorted order
without having to sort the list after each insertion.  For long lists
of items with expensive comparison operations, this can be an
improvement over the more common approach.  The module is called
`bisect' because it uses a basic bisection algorithm to do its work.
The source code may be most useful as a working example of the
algorithm (the boundary conditions are already right!).

The following functions are provided:

`bisect_left(list, item[, lo[, hi]])'
     Locate the proper insertion point for ITEM in LIST to maintain
     sorted order.  The parameters LO and HI may be used to specify a
     subset of the list which should be considered; by default the
     entire list is used.  If ITEM is already present in LIST, the
     insertion point will be before (to the left of) any existing
     entries.  The return value is suitable for use as the first
     parameter to `LIST.insert()'.  This assumes that LIST is already
     sorted.  _Added in Python version 2.1_

`bisect_right(list, item[, lo[, hi]])'
     Similar to `bisect_left()', but returns an insertion point which
     comes after (to the right of) any existing entries of ITEM in LIST.
     _Added in Python version 2.1_

`bisect(...)'
     Alias for `bisect_right()'.

`insort_left(list, item[, lo[, hi]])'
     Insert ITEM in LIST in sorted order.  This is equivalent to
     `LIST.insert(bisect.bisect_left(LIST, ITEM, LO, HI), ITEM)'.  This
     assumes that LIST is already sorted.  _Added in Python version 2.1_

`insort_right(list, item[, lo[, hi]])'
     Similar to `insort_left()', but inserting ITEM in LIST after any
     existing entries of ITEM.  _Added in Python version 2.1_

`insort(...)'
     Alias for `insort_right()'.

* Menu:

* bisect-example::


File: python-lib.info,  Node: bisect-example,  Prev: bisect,  Up: bisect

Examples
--------

The `bisect()' function is generally useful for categorizing numeric
data.  This example uses `bisect()' to look up a letter grade for an
exam total (say) based on a set of ordered numeric breakpoints: 85 and
up is an `A', 75..84 is a `B', etc.

     >>> grades = "FEDCBA"
     >>> breakpoints = [30, 44, 66, 75, 85]
     >>> from bisect import bisect
     >>> def grade(total):
     ...           return grades[bisect(breakpoints, total)]
     ...
     >>> grade(66)
     'C'
     >>> map(grade, [33, 99, 77, 44, 12, 88])
     ['E', 'A', 'B', 'D', 'F', 'A']

The bisect module can be used with the Queue module to implement a
priority queue (example courtesy of Fredrik Lundh):

     import Queue, bisect
     
     class PriorityQueue(Queue.Queue):
         def _put(self, item):
             bisect.insort(self.queue, item)
     
     # usage
     queue = PriorityQueue(0)
     queue.put((2, "second"))
     queue.put((1, "first"))
     queue.put((3, "third"))
     priority, value = queue.get()


File: python-lib.info,  Node: heapq,  Next: array,  Prev: bisect,  Up: Miscellaneous Services

Heap queue algorithm
====================

Heap queue algorithm (a.k.a. priority queue).

_Added in Python version 2.3_

This module provides an implementation of the heap queue algorithm,
also known as the priority queue algorithm.

Heaps are arrays for which `HEAP[K] <= HEAP[2*K+1]' and `HEAP[K] <=
HEAP[2*K+2]' for all K, counting elements from zero.  For the sake of
comparison, non-existing elements are considered to be infinite.  The
interesting property of a heap is that `HEAP[0]' is always its smallest
element.

The API below differs from textbook heap algorithms in two aspects: (a)
We use zero-based indexing.  This makes the relationship between the
index for a node and the indexes for its children slightly less
obvious, but is more suitable since Python uses zero-based indexing.
(b) Our pop method returns the smallest item, not the largest (called a
"min heap" in textbooks; a "max heap" is more common in texts because
of its suitability for in-place sorting).

These two make it possible to view the heap as a regular Python list
without surprises: `HEAP[0]' is the smallest item, and `HEAP.sort()'
maintains the heap invariant!

To create a heap, use a list initialized to `[]', or you can transform
a populated list into a heap via function `heapify()'.

The following functions are provided:

`heappush(heap, item)'
     Push the value ITEM onto the HEAP, maintaining the heap invariant.

`heappop(heap)'
     Pop and return the smallest item from the HEAP, maintaining the
     heap invariant.  If the heap is empty, `IndexError' is raised.

`heapify(x)'
     Transform list X into a heap, in-place, in linear time.

`heapreplace(heap, item)'
     Pop and return the smallest item from the HEAP, and also push the
     new ITEM.  The heap size doesn't change.  If the heap is empty,
     `IndexError' is raised.  This is more efficient than `heappop()'
     followed by  `heappush()', and can be more appropriate when using
     a fixed-size heap.  Note that the value returned may be larger
     than ITEM!  That constrains reasonable uses of this routine.

Example of use:

     >>> from heapq import heappush, heappop
     >>> heap = []
     >>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
     >>> for item in data:
     ...     heappush(heap, item)
     ...
     >>> sorted = []
     >>> while heap:
     ...     sorted.append(heappop(heap))
     ...
     >>> print sorted
     [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
     >>> data.sort()
     >>> print data == sorted
     True
     >>>

* Menu:

* Theory::


File: python-lib.info,  Node: Theory,  Prev: heapq,  Up: heapq

Theory
------

(This explanation is due to François Pinard.  The Python code for this
module was contributed by Kevin O'Connor.)

Heaps are arrays for which `a[K] <= a[2*K+1]' and `a[K] <= a[2*K+2]'
for all K, counting elements from 0.  For the sake of comparison,
non-existing elements are considered to be infinite.  The interesting
property of a heap is that `a[0]' is always its smallest element.

The strange invariant above is meant to be an efficient memory
representation for a tournament.  The numbers below are K, not `a[K]':

                                        0
     
                       1                                 2
     
               3               4                5               6
     
           7       8       9       10      11      12      13      14
     
         15 16   17 18   19 20   21 22   23 24   25 26   27 28   29 30

In the tree above, each cell K is topping `2*K+1' and `2*K+2'.  In an
usual binary tournament we see in sports, each cell is the winner over
the two cells it tops, and we can trace the winner down the tree to see
all opponents s/he had.  However, in many computer applications of such
tournaments, we do not need to trace the history of a winner.  To be
more memory efficient, when a winner is promoted, we try to replace it
by something else at a lower level, and the rule becomes that a cell
and the two cells it tops contain three different items, but the top
cell "wins" over the two topped cells.

If this heap invariant is protected at all time, index 0 is clearly the
overall winner.  The simplest algorithmic way to remove it and find the
"next" winner is to move some loser (let's say cell 30 in the diagram
above) into the 0 position, and then percolate this new 0 down the
tree, exchanging values, until the invariant is re-established.  This
is clearly logarithmic on the total number of items in the tree.  By
iterating over all items, you get an O(n log n) sort.

A nice feature of this sort is that you can efficiently insert new
items while the sort is going on, provided that the inserted items are
not "better" than the last 0'th element you extracted.  This is
especially useful in simulation contexts, where the tree holds all
incoming events, and the "win" condition means the smallest scheduled
time.  When an event schedule other events for execution, they are
scheduled into the future, so they can easily go into the heap.  So, a
heap is a good structure for implementing schedulers (this is what I
used for my MIDI sequencer :-).

Various structures for implementing schedulers have been extensively
studied, and heaps are good for this, as they are reasonably speedy,
the speed is almost constant, and the worst case is not much different
than the average case.  However, there are other representations which
are more efficient overall, yet the worst cases might be terrible.

Heaps are also very useful in big disk sorts.  You most probably all
know that a big sort implies producing "runs" (which are pre-sorted
sequences, which size is usually related to the amount of CPU memory),
followed by a merging passes for these runs, which merging is often
very cleverly organised(1).  It is very important that the initial sort
produces the longest runs possible.  Tournaments are a good way to
that.  If, using all the memory available to hold a tournament, you
replace and percolate items that happen to fit the current run, you'll
produce runs which are twice the size of the memory for random input,
and much better for input fuzzily ordered.

Moreover, if you output the 0'th item on disk and get an input which
may not fit in the current tournament (because the value "wins" over
the last output value), it cannot fit in the heap, so the size of the
heap decreases.  The freed memory could be cleverly reused immediately
for progressively building a second heap, which grows at exactly the
same rate the first heap is melting.  When the first heap completely
vanishes, you switch heaps and start a new run.  Clever and quite
effective!

In a word, heaps are useful memory structures to know.  I use them in a
few applications, and I think it is good to keep a `heap' module
around. :-)

---------- Footnotes ----------

(1) The disk balancing algorithms which are current, nowadays, are more
annoying than clever, and this is a consequence of the seeking
capabilities of the disks.  On devices which cannot seek, like big tape
drives, the story was quite different, and one had to be very clever to
ensure (far in advance) that each tape movement will be the most
effective possible (that is, will best participate at "progressing" the
merge).  Some tapes were even able to read backwards, and this was also
used to avoid the rewinding time. Believe me, real good tape sorts were
quite spectacular to watch! From all times, sorting has always been a
Great Art! :-)


File: python-lib.info,  Node: array,  Next: sets,  Prev: heapq,  Up: Miscellaneous Services

Efficient arrays of numeric values
==================================

Efficient arrays of uniformly typed numeric values.

This module defines an object type which can efficiently represent an
array of basic values: characters, integers, floating point numbers.
Arrays  are sequence types and behave very much like lists, except that
the type of objects stored in them is constrained.  The type is
specified at object creation time by using a "type code", which is a
single character.  The following type codes are defined:

Type code          C Type             Python Type        Minimum size in
                                                         bytes
------             ------             ------             ------
'c'                char               character          1
'b'                signed char        int                1
'B'                unsigned char      int                1
'u'                Py_UNICODE         Unicode character  2
'h'                signed short       int                2
'H'                unsigned short     int                2
'i'                signed int         int                2
'I'                unsigned int       long               2
'l'                signed long        int                4
'L'                unsigned long      long               4
'f'                float              float              4
'd'                double             float              8

The actual representation of values is determined by the machine
architecture (strictly speaking, by the C implementation).  The actual
size can be accessed through the `itemsize' attribute.  The values
stored  for `'L'' and `'I'' items will be represented as Python long
integers when retrieved, because Python's plain integer type cannot
represent the full range of C's unsigned (long) integers.

The module defines the following type:

`array(typecode[, initializer])'
     Return a new array whose items are restricted by TYPECODE, and
     initialized from the optional INITIALIZER value, which must be a
     list or a string.  The list or string is passed to the new array's
     `fromlist()', `fromstring()', or `fromunicode()' method (see
     below) to add initial items to the array.

`ArrayType'
     Obsolete alias for `array'.

Array objects support the ordinary sequence operations of indexing,
slicing, concatenation, and multiplication.  When using slice
assignment, the assigned value must be an array object with the same
type code; in all other cases, `TypeError' is raised.  Array objects
also implement the buffer interface, and may be used wherever buffer
objects are supported.

The following data items and methods are also supported:

`typecode'
     The typecode character used to create the array.

`itemsize'
     The length in bytes of one array item in the internal
     representation.

`append(x)'
     Append a new item with value X to the end of the array.

`buffer_info()'
     Return a tuple `(ADDRESS, LENGTH)' giving the current memory
     address and the length in elements of the buffer used to hold
     array's contents.  The size of the memory buffer in bytes can be
     computed as `ARRAY.buffer_info()[1] * ARRAY.itemsize'.  This is
     occasionally useful when working with low-level (and inherently
     unsafe) I/O interfaces that require memory addresses, such as
     certain `ioctl()' operations.  The returned numbers are valid as
     long as the array exists and no length-changing operations are
     applied to it.

     _Note:_ When using array objects from code written in C or C++
     (the only way to effectively make use of this information), it
     makes more sense to use the buffer interface supported by array
     objects.  This method is maintained for backward compatibility and
     should be avoided in new code.  The buffer interface is documented
     in the .

`byteswap()'
     "Byteswap" all items of the array.  This is only supported for
     values which are 1, 2, 4, or 8 bytes in size; for other types of
     values, `RuntimeError' is raised.  It is useful when reading data
     from a file written on a machine with a different byte order.

`count(x)'
     Return the number of occurences of X in the array.

`extend(a)'
     Append array items from A to the end of the array.  The two arrays
     must have _exactly_ the same type code; if not, `TypeError' will
     be raised.

`fromfile(f, n)'
     Read N items (as machine values) from the file object F and append
     them to the end of the array.  If less than N items are available,
     `EOFError' is raised, but the items that were available are still
     inserted into the array.  F must be a real built-in file object;
     something else with a `read()' method won't do.

`fromlist(list)'
     Append items from the list.  This is equivalent to `for x in LIST:
     a.append(x)' except that if there is a type error, the array is
     unchanged.

`fromstring(s)'
     Appends items from the string, interpreting the string as an array
     of machine values (as if it had been read from a file using the
     `fromfile()' method).

`fromunicode(s)'
     Extends this array with data from the given unicode string.  The
     array must be a type 'u' array; otherwise a ValueError is raised.
     Use `array.fromstring(ustr.decode(enc))' to append Unicode data to
     an array of some other type.

`index(x)'
     Return the smallest I such that I is the index of the first
     occurence of X in the array.

`insert(i, x)'
     Insert a new item with value X in the array before position I.
     Negative values are treated as being relative to the end of the
     array.

`pop([i])'
     Removes the item with the index I from the array and returns it.
     The optional argument defaults to `-1', so that by default the
     last item is removed and returned.

`read(f, n)'
     _This is deprecated in Python 1.5.1.  Use the `fromfile()' method._
     Read N items (as machine values) from the file object F and append
     them to the end of the array.  If less than N items are available,
     `EOFError' is raised, but the items that were available are still
     inserted into the array.  F must be a real built-in file object;
     something else with a `read()' method won't do.

`remove(x)'
     Remove the first occurence of X from the array.

`reverse()'
     Reverse the order of the items in the array.

`tofile(f)'
     Write all items (as machine values) to the file object F.

`tolist()'
     Convert the array to an ordinary list with the same items.

`tostring()'
     Convert the array to an array of machine values and return the
     string representation (the same sequence of bytes that would be
     written to a file by the `tofile()' method.)

`tounicode()'
     Convert the array to a unicode string.  The array must be a type
     'u' array; otherwise a ValueError is raised.  Use
     array.tostring().decode(enc) to obtain a unicode string from an
     array of some other type.

`write(f)'
     _This is deprecated in Python 1.5.1.  Use the `tofile()' method._
     Write all items (as machine values) to the file object F.

When an array object is printed or converted to a string, it is
represented as `array(TYPECODE, INITIALIZER)'.  The INITIALIZER is
omitted if the array is empty, otherwise it is a string if the TYPECODE
is `'c'', otherwise it is a list of numbers.  The string is guaranteed
to be able to be converted back to an array with the same type and
value using reverse quotes (```'), so long as the `array()' function
has been imported using `from array import array'.  Examples:

     array('l')
     array('c', 'hello world')
     array('u', u'hello \textbackslash u2641')
     array('l', [1, 2, 3, 4, 5])
     array('d', [1.0, 2.0, 3.14])

See also:
     *Note struct:: Packing and unpacking of heterogeneous binary data.
     *Note xdrlib:: Packing and unpacking of External Data
     Representation (XDR) data as used in some remote procedure call
     systems.  `The Numerical Python Manual'{The Numeric Python
     extension (NumPy) defines another array type; see
     <http://numpy.sourceforge.net/> for further information about
     Numerical Python.  (A PDF version of the NumPy manual is available
     at <http://numpy.sourceforge.net/numdoc/numdoc.pdf>).}


File: python-lib.info,  Node: sets,  Next: itertools,  Prev: array,  Up: Miscellaneous Services

Unordered collections of unique elements
========================================

Implementation of sets of unique elements.

_Added in Python version 2.3_

The `sets' module provides classes for constructing and manipulating
unordered collections of unique elements.  Common uses include
membership testing, removing duplicates from a sequence, and computing
standard math operations on sets such as intersection, union,
difference, and symmetric difference.

Like other collections, sets support `X in SET', `len(SET)', and `for X
in SET'.  Being an unordered collection, sets do not record element
position or order of insertion.  Accordingly, sets do not support
indexing, slicing, or other sequence-like behavior.

Most set applications use the `Set' class which provides every set
method except for `__hash__()'. For advanced applications requiring a
hash method, the `ImmutableSet' class adds a `__hash__()' method but
omits methods which alter the contents of the set. Both `Set' and
`ImmutableSet' derive from `BaseSet', an abstract class useful for
determining whether something is a set: `isinstance(OBJ, BaseSet)'.

The set classes are implemented using dictionaries.  As a result, sets
cannot contain mutable elements such as lists or dictionaries.
However, they can contain immutable collections such as tuples or
instances of `ImmutableSet'.  For convenience in implementing sets of
sets, inner sets are automatically converted to immutable form, for
example, `Set([Set(['dog'])])' is transformed to
`Set([ImmutableSet(['dog'])])'.

`Set([iterable])'
     Constructs a new empty `Set' object.  If the optional ITERABLE
     parameter is supplied, updates the set with elements obtained from
     iteration.  All of the elements in ITERABLE should be immutable or
     be transformable to an immutable using the protocol described in
     section~*Note itertools::.

`ImmutableSet([iterable])'
     Constructs a new empty `ImmutableSet' object.  If the optional
     ITERABLE parameter is supplied, updates the set with elements
     obtained from iteration.  All of the elements in ITERABLE should
     be immutable or be transformable to an immutable using the
     protocol described in section~*Note itertools::.

     Because `ImmutableSet' objects provide a `__hash__()' method, they
     can be used as set elements or as dictionary keys.  `ImmutableSet'
     objects do not have methods for adding or removing elements, so
     all of the elements must be known when the constructor is called.

* Menu:

* Set Objects::
* Example 5::
* Protocol for automatic conversion to immutable::


File: python-lib.info,  Node: Set Objects,  Next: Example 5,  Prev: sets,  Up: sets

Set Objects
-----------

Instances of `Set' and `ImmutableSet' both provide the following
operations:

Operation                Equivalent               Result
------                   -----                    -----
len(S)                                            cardinality of set S
X in S                                            test X for membership
                                                  in S
X not in S                                        test X for
                                                  non-membership in S
S.issubset(T)            `S <= T'                 test whether every
                                                  element in S is in T
S.issuperset(T)          `S >= T'                 test whether every
                                                  element in T is in S
S.union(T)               S | T                    new set with elements
                                                  from both S and T
S.intersection(T)        S & T                    new set with elements
                                                  common to S and T
S.difference(T)          S - T                    new set with elements
                                                  in S but not in T
S.symmetric_difference(T)S ^ T                    new set with elements
                                                  in either S or T but
                                                  not both
S.copy()                                          new set with a shallow
                                                  copy of S

Note, this non-operator versions of `union()', `intersection()',
`difference()', and `symmetric_difference()' will accept any iterable
as an argument.  In contrast, their operator based counterparts require
their arguments to be sets.  This precludes error-prone constructions
like `Set('abc') & 'cbs'' in favor of the more readable
`Set('abc').intersection('cbs')'.  _Changed in Python version 2.3.1_

In addition, both `Set' and `ImmutableSet' support set to set
comparisons.  Two sets are equal if and only if every element of each
set is contained in the other (each is a subset of the other).  A set
is less than another set if and only if the first set is a proper
subset of the second set (is a subset, but is not equal).  A set is
greater than another set if and only if the first set is a proper
superset of the second set (is a superset, but is not equal).

The subset and equality comparisons do not generalize to a complete
ordering function.  For example, any two disjoint sets are not equal and
are not subsets of each other, so _all_ of the following return
`False':  `A<B', `A==B', or `A>B'.  Accordingly, sets do not implement
the `__cmp__' method.

Since sets only define partial ordering (subset relationships), the
output of the `list.sort()' method is undefined for lists of sets.

The following table lists operations available in `ImmutableSet' but
not found in `Set':

Operation                            Result
------                               -----
hash(S)                              returns a hash value for S

The following table lists operations available in `Set' but not found
in `ImmutableSet':

Operation                Equivalent               Result
------                   -----                    -----
S.union_update(T)        S |= T                   return set S with
                                                  elements added from T
S.intersection_update(T) S &= T                   return set S keeping
                                                  only elements also
                                                  found in T
S.difference_update(T)   S -= T                   return set S after
                                                  removing elements found
                                                  in T
S.symmetric_difference_update(T)S ^= T                   return set S with
                                                  elements from S or T
                                                  but not both
S.add(X)                                          add element X to set S
S.remove(X)                                       remove X from set S;
                                                  raises KeyError if not
                                                  present
S.discard(X)                                      removes X from set S if
                                                  present
S.pop()                                           remove and return an
                                                  arbitrary element from
                                                  S; raises KeyError if
                                                  empty
S.clear()                                         remove all elements
                                                  from set S

_Changed in Python version 2.3.1_

Note, this non-operator versions of `union_update()',
`intersection_update()', `difference_update()', and
`symmetric_difference_update()' will accept any iterable as an argument.
_Changed in Python version 2.3.1_

