This is python-lib.info, produced by makeinfo version 4.3 from
python-lib.texi.

October 3, 2003


File: python-lib.info,  Node: Warning Categories,  Next: Warnings Filter,  Prev: warnings,  Up: warnings

Warning Categories
------------------

There are a number of built-in exceptions that represent warning
categories.  This categorization is useful to be able to filter out
groups of warnings.  The following warnings category classes are
currently defined:

Class                                Description
------                               -----
Warning                              This is the base class of all
                                     warning category classes.  It is a
                                     subclass of `Exception'.
UserWarning                          The default category for `warn()'.
DeprecationWarning                   Base category for warnings about
                                     deprecated features.
SyntaxWarning                        Base category for warnings about
                                     dubious syntactic features.
RuntimeWarning                       Base category for warnings about
                                     dubious runtime features.
FutureWarning                        Base category for warnings about
                                     constructs that will change
                                     semantically in the future.

While these are technically built-in exceptions, they are documented
here, because conceptually they belong to the warnings mechanism.

User code can define additional warning categories by subclassing one
of the standard warning categories.  A warning category must always be
a subclass of the `Warning' class.


File: python-lib.info,  Node: Warnings Filter,  Next: Available Functions,  Prev: Warning Categories,  Up: warnings

The Warnings Filter
-------------------

The warnings filter controls whether warnings are ignored, displayed,
or turned into errors (raising an exception).

Conceptually, the warnings filter maintains an ordered list of filter
specifications; any specific warning is matched against each filter
specification in the list in turn until a match is found; the match
determines the disposition of the match.  Each entry is a tuple of the
form (ACTION, MESSAGE, CATEGORY, MODULE, LINENO), where:

   * ACTION is one of the following strings:

     Value                              Disposition
     ------                             -----
     "error"                            turn matching warnings into
                                        exceptions
     "ignore"                           never print matching warnings
     "always"                           always print matching warnings
     "default"                          print the first occurrence of
                                        matching warnings for each
                                        location where the warning is
                                        issued
     "module"                           print the first occurrence of
                                        matching warnings for each module
                                        where the warning is issued
     "once"                             print only the first occurrence
                                        of matching warnings, regardless
                                        of location

   * MESSAGE is a string containing a regular expression that the
     warning message must match (the match is compiled to always be
     case-insensitive)

   * CATEGORY is a class (a subclass of `Warning') of which the warning
     category must be a subclass in order to match

   * MODULE is a string containing a regular expression that the module
     name must match (the match is compiled to be case-sensitive)

   * LINENO is an integer that the line number where the warning
     occurred must match, or `0' to match all line numbers


Since the `Warning' class is derived from the built-in `Exception'
class, to turn a warning into an error we simply raise
`category(message)'.

The warnings filter is initialized by `-W' options passed to the Python
interpreter command line.  The interpreter saves the arguments for all
`-W' options without interpretation in `sys.warnoptions'; the
`warnings' module parses these when it is first imported (invalid
options are ignored, after printing a message to `sys.stderr').


File: python-lib.info,  Node: Available Functions,  Prev: Warnings Filter,  Up: warnings

Available Functions
-------------------

`warn(message[, category[, stacklevel]])'
     Issue a warning, or maybe ignore it or raise an exception.  The
     CATEGORY argument, if given, must be a warning category class (see
     above); it defaults to `UserWarning'.  Alternatively MESSAGE can
     be a `Warning' instance, in which case CATEGORY will be ignored
     and `message.__class__' will be used.  In this case the message
     text will be `str(message)'. This function raises an exception if
     the particular warning issued is changed into an error by the
     warnings filter see above.  The STACKLEVEL argument can be used by
     wrapper functions written in Python, like this:

          def deprecation(message):
              warnings.warn(message, DeprecationWarning, stacklevel=2)

     This makes the warning refer to `deprecation()''s caller, rather
     than to the source of `deprecation()' itself (since the latter
     would defeat the purpose of the warning message).

`warn_explicit(message, category, filename, lineno[, module[, registry]])'
     This is a low-level interface to the functionality of `warn()',
     passing in explicitly the message, category, filename and line
     number, and optionally the module name and the registry (which
     should be the `__warningregistry__' dictionary of the module).
     The module name defaults to the filename with `.py' stripped; if
     no registry is passed, the warning is never suppressed.  MESSAGE
     must be a string and CATEGORY a subclass of `Warning' or MESSAGE
     may be a `Warning' instance, in which case CATEGORY will be
     ignored.

`showwarning(message, category, filename, lineno[, file])'
     Write a warning to a file.  The default implementation calls
     `formatwarning(MESSAGE, CATEGORY, FILENAME, LINENO)' and writes
     the resulting string to FILE, which defaults to `sys.stderr'.  You
     may replace this function with an alternative implementation by
     assigning to `warnings.showwarning'.

`formatwarning(message, category, filename, lineno)'
     Format a warning the standard way.  This returns a string  which
     may contain embedded newlines and ends in a newline.

`filterwarnings(action[, message[, category[, module[, lineno[, append]]]]])'
     Insert an entry into the list of warnings filters.  The entry is
     inserted at the front by default; if APPEND is true, it is
     inserted at the end.  This checks the types of the arguments,
     compiles the message and module regular expressions, and inserts
     them as a tuple in front of the warnings filter.  Entries inserted
     later override entries inserted earlier, if both match a
     particular warning.  Omitted arguments default to a value that
     matches everything.

`resetwarnings()'
     Reset the warnings filter.  This discards the effect of all
     previous calls to `filterwarnings()', including that of the `-W'
     command line options.


File: python-lib.info,  Node: imp,  Next: pkgutil,  Prev: warnings,  Up: Python Runtime Services

Access the `import' internals
=============================

Access the implementation of the `import' statement.

This  module provides an interface to the mechanisms used to implement
the `import' statement.  It defines the following constants and
functions:

`get_magic()'
     Return the magic string value used to recognize byte-compiled code
     files (`.pyc' files).  (This value may be different for each
     Python version.)

`get_suffixes()'
     Return a list of triples, each describing a particular type of
     module.  Each triple has the form `(SUFFIX, MODE, TYPE)', where
     SUFFIX is a string to be appended to the module name to form the
     filename to search for, MODE is the mode string to pass to the
     built-in `open()' function to open the file (this can be `'r'' for
     text files or `'rb'' for binary files), and TYPE is the file type,
     which has one of the values `PY_SOURCE', `PY_COMPILED', or
     `C_EXTENSION', described below.

`find_module(name[, path])'
     Try to find the module NAME on the search path PATH.  If PATH is a
     list of directory names, each directory is searched for files with
     any of the suffixes returned by `get_suffixes()' above.  Invalid
     names in the list are silently ignored (but all list items must be
     strings).  If PATH is omitted or `None', the list of directory
     names given by `sys.path' is searched, but first it searches a few
     special places: it tries to find a built-in module with the given
     name (`C_BUILTIN'), then a frozen module (`PY_FROZEN'), and on
     some systems some other places are looked in as well (on the Mac,
     it looks for a resource (`PY_RESOURCE'); on Windows, it looks in
     the registry which may point to a specific file).

     If search is successful, the return value is a triple `(FILE,
     PATHNAME, DESCRIPTION)' where FILE is an open file object
     positioned at the beginning, PATHNAME is the pathname of the file
     found, and DESCRIPTION is a triple as contained in the list
     returned by `get_suffixes()' describing the kind of module found.
     If the module does not live in a file, the returned FILE is
     `None', FILENAME is the empty string, and the DESCRIPTION tuple
     contains empty strings for its suffix and mode; the module type is
     as indicate in parentheses above.  If the search is unsuccessful,
     `ImportError' is raised.  Other exceptions indicate problems with
     the arguments or environment.

     This function does not handle hierarchical module names (names
     containing dots).  In order to find P.M, that is, submodule M of
     package P, use `find_module()' and `load_module()' to find and
     load package P, and then use `find_module()' with the PATH
     argument set to `P.__path__'.  When P itself has a dotted name,
     apply this recipe recursively.

`load_module(name, file, filename, description)'
     Load a module that was previously found by `find_module()' (or by
     an otherwise conducted search yielding compatible results).  This
     function does more than importing the module: if the module was
     already imported, it is equivalent to a `reload()' !  The NAME
     argument indicates the full module name (including the package
     name, if this is a submodule of a package).  The FILE argument is
     an open file, and FILENAME is the corresponding file name; these
     can be `None' and `''', respectively, when the module is not being
     loaded from a file.  The DESCRIPTION argument is a tuple, as would
     be returned by `get_suffixes()', describing what kind of module
     must be loaded.

     If the load is successful, the return value is the module object;
     otherwise, an exception (usually `ImportError') is raised.

     *Important:* the caller is responsible for closing the FILE
     argument, if it was not `None', even when an exception is raised.
     This is best done using a `try' ... `finally' statement.

`new_module(name)'
     Return a new empty module object called NAME.  This object is
     _not_ inserted in `sys.modules'.

`lock_held()'
     Return `True' if the import lock is currently held, else `False'.
     On platforms without threads, always return `False'.

     On platforms with threads, a thread executing an import holds an
     internal lock until the import is complete.  This lock blocks
     other threads from doing an import until the original import
     completes, which in turn prevents other threads from seeing
     incomplete module objects constructed by the original thread while
     in the process of completing its import (and the imports, if any,
     triggered by that).

`acquire_lock()'
     Acquires the interpreter's import lock for the current thread.
     This lock should be used by import hooks to ensure thread-safety
     when importing modules.  On platforms without threads, this
     function does nothing.  _Added in Python version 2.3_

`release_lock()'
     Release the interpreter's import lock.  On platforms without
     threads, this function does nothing.  _Added in Python version 2.3_

The following constants with integer values, defined in this module,
are used to indicate the search result of `find_module()'.

`PY_SOURCE'
     The module was found as a source file.

`PY_COMPILED'
     The module was found as a compiled code object file.

`C_EXTENSION'
     The module was found as dynamically loadable shared library.

`PY_RESOURCE'
     The module was found as a Macintosh resource.  This value can only
     be returned on a Macintosh.

`PKG_DIRECTORY'
     The module was found as a package directory.

`C_BUILTIN'
     The module was found as a built-in module.

`PY_FROZEN'
     The module was found as a frozen module (see `init_frozen()').

The following constant and functions are obsolete; their functionality
is available through `find_module()' or `load_module()'.  They are kept
around for backward compatibility:

`SEARCH_ERROR'
     Unused.

`init_builtin(name)'
     Initialize the built-in module called NAME and return its module
     object.  If the module was already initialized, it will be
     initialized _again_.  A few modules cannot be initialized twice --
     attempting to initialize these again will raise an `ImportError'
     exception.  If there is no built-in module called NAME, `None' is
     returned.

`init_frozen(name)'
     Initialize the frozen module called NAME and return its module
     object.  If the module was already initialized, it will be
     initialized _again_.  If there is no frozen module called NAME,
     `None' is returned.  (Frozen modules are modules written in Python
     whose compiled byte-code object is incorporated into a
     custom-built Python interpreter by Python's `freeze' utility.  See
     `Tools/freeze/' for now.)

`is_builtin(name)'
     Return `1' if there is a built-in module called NAME which can be
     initialized again.  Return `-1' if there is a built-in module
     called NAME which cannot be initialized again (see
     `init_builtin()').  Return `0' if there is no built-in module
     called NAME.

`is_frozen(name)'
     Return `True' if there is a frozen module (see `init_frozen()')
     called NAME, or `False' if there is no such module.

`load_compiled(name, pathname, file)'
     Load and initialize a module implemented as a byte-compiled code
     file and return its module object.  If the module was already
     initialized, it will be initialized _again_.  The NAME argument is
     used to create or access a module object.  The PATHNAME argument
     points to the byte-compiled code file.  The FILE argument is the
     byte-compiled code file, open for reading in binary mode, from the
     beginning.  It must currently be a real file object, not a
     user-defined class emulating a file.

`load_dynamic(name, pathname[, file])'
     Load and initialize a module implemented as a dynamically loadable
     shared library and return its module object.  If the module was
     already initialized, it will be initialized _again_.  Some modules
     don't like that and may raise an exception.  The PATHNAME argument
     must point to the shared library.  The NAME argument is used to
     construct the name of the initialization function: an external C
     function called `initNAME()' in the shared library is called.  The
     optional FILE argument is ignored.  (Note: using shared libraries
     is highly system dependent, and not all systems support it.)

`load_source(name, pathname, file)'
     Load and initialize a module implemented as a Python source file
     and return its module object.  If the module was already
     initialized, it will be initialized _again_.  The NAME argument is
     used to create or access a module object.  The PATHNAME argument
     points to the source file.  The FILE argument is the source file,
     open for reading as text, from the beginning.  It must currently
     be a real file object, not a user-defined class emulating a file.
     Note that if a properly matching byte-compiled file (with suffix
     `.pyc' or `.pyo') exists, it will be used instead of parsing the
     given source file.

* Menu:

* Examples::


File: python-lib.info,  Node: Examples,  Prev: imp,  Up: imp

Examples
--------

The following function emulates what was the standard import statement
up to Python 1.4 (no hierarchical module names).  (This
_implementation_ wouldn't work in that version, since `find_module()'
has been extended and `load_module()' has been added in 1.4.)

     import imp
     import sys
     
     def __import__(name, globals=None, locals=None, fromlist=None):
         # Fast path: see if the module has already been imported.
         try:
             return sys.modules[name]
         except KeyError:
             pass
     
         # If any of the following calls raises an exception,
         # there's a problem we can't handle -- let the caller handle it.
     
         fp, pathname, description = imp.find_module(name)
     
         try:
             return imp.load_module(name, fp, pathname, description)
         finally:
             # Since we may exit via an exception, close fp explicitly.
             if fp:
                 fp.close()

A more complete example that implements hierarchical module names and
includes a `reload()'  function can be found in the module `knee' .  The
`knee' module can be found in `Demo/imputil/' in the Python source
distribution.


File: python-lib.info,  Node: pkgutil,  Next: code,  Prev: imp,  Up: Python Runtime Services

Package extension utility
=========================

Utilities to support extension of packages.

_Added in Python version 2.3_

_Notice:_ [warning] This is an experimental module.  It may be
withdrawn or completely changed up to an including the release of
Python 2.3 beta 1.

This module provides a single function:

`extend_path(path, name)'
     Extend the search path for the modules which comprise a package.
     Intended use is to place the following code in a package's
     `__init__.py':

          from pkgutil import extend_path
          __path__ = extend_path(__path__, __name__)

     This will add to the package's `__path__' all subdirectories of
     directories on `sys.path' named after the package.  This is useful
     if one wants to distribute different parts of a single logical
     package as multiple directories.

     It also looks for `*.pkg' files beginning where `*' matches the
     NAME argument.  This feature is similar to `*.pth' files (see the
     `site' module for more information), except that it doesn't
     special-case lines starting with `import'.  A `*.pkg' file is
     trusted at face value: apart from checking for duplicates, all
     entries found in a `*.pkg' file are added to the path, regardless
     of whether they exist the filesystem.  (This is a feature.)

     If the input path is not a list (as is the case for frozen
     packages) it is returned unchanged.  The input path is not
     modified; an extended copy is returned.  Items are only appended
     to the copy at the end.

     It is assumed that `sys.path' is a sequence.  Items of `sys.path'
     that are not (Unicode or 8-bit) strings referring to existing
     directories are ignored.  Unicode items on `sys.path' that cause
     errors when used as filenames may cause this function to raise an
     exception (in line with `os.path.isdir()' behavior).


File: python-lib.info,  Node: code,  Next: codeop,  Prev: pkgutil,  Up: Python Runtime Services

Interpreter base classes
========================

Base classes for interactive Python interpreters.

The `code' module provides facilities to implement read-eval-print
loops in Python.  Two classes and convenience functions are included
which can be used to build applications which provide an interactive
interpreter prompt.

`InteractiveInterpreter([locals])'
     This class deals with parsing and interpreter state (the user's
     namespace); it does not deal with input buffering or prompting or
     input file naming (the filename is always passed in explicitly).
     The optional LOCALS argument specifies the dictionary in which
     code will be executed; it defaults to a newly created dictionary
     with key `'__name__'' set to `'__console__'' and key `'__doc__''
     set to `None'.

`InteractiveConsole([locals[, filename]])'
     Closely emulate the behavior of the interactive Python interpreter.
     This class builds on `InteractiveInterpreter' and adds prompting
     using the familiar `sys.ps1' and `sys.ps2', and input buffering.

`interact([banner[, readfunc[, local]]])'
     Convenience function to run a read-eval-print loop.  This creates a
     new instance of `InteractiveConsole' and sets READFUNC to be used
     as the `raw_input()' method, if provided.  If LOCAL is provided,
     it is passed to the `InteractiveConsole' constructor for use as
     the default namespace for the interpreter loop.  The `interact()'
     method of the instance is then run with BANNER passed as the banner
     to use, if provided.  The console object is discarded after use.

`compile_command(source[, filename[, symbol]])'
     This function is useful for programs that want to emulate Python's
     interpreter main loop (a.k.a. the read-eval-print loop).  The
     tricky part is to determine when the user has entered an
     incomplete command that can be completed by entering more text (as
     opposed to a complete command or a syntax error).  This function
     _almost_ always makes the same decision as the real interpreter
     main loop.

     SOURCE is the source string; FILENAME is the optional filename
     from which source was read, defaulting to `'<input>''; and SYMBOL
     is the optional grammar start symbol, which should be either
     `'single'' (the default) or `'eval''.

     Returns a code object (the same as `compile(SOURCE, FILENAME,
     SYMBOL)') if the command is complete and valid; `None' if the
     command is incomplete; raises `SyntaxError' if the command is
     complete and contains a syntax error, or raises `OverflowError' or
     `ValueError' if the command cotains an invalid literal.

* Menu:

* Interactive Interpreter Objects::
* Interactive Console Objects::


File: python-lib.info,  Node: Interactive Interpreter Objects,  Next: Interactive Console Objects,  Prev: code,  Up: code

Interactive Interpreter Objects
-------------------------------

`runsource(source[, filename[, symbol]])'
     Compile and run some source in the interpreter.  Arguments are the
     same as for `compile_command()'; the default for FILENAME is
     `'<input>'', and for SYMBOL is `'single''.  One several things can
     happen:

        * The input is incorrect; `compile_command()' raised an
          exception (`SyntaxError' or `OverflowError').  A syntax
          traceback will be printed by calling the `showsyntaxerror()'
          method.  `runsource()' returns `False'.

        * The input is incomplete, and more input is required;
          `compile_command()' returned `None'.  `runsource()' returns
          `True'.

        * The input is complete; `compile_command()' returned a code
          object.  The code is executed by calling the `runcode()'
          (which also handles run-time exceptions, except for
          `SystemExit').  `runsource()' returns `False'.

     The return value can be used to decide whether to use `sys.ps1' or
     `sys.ps2' to prompt the next line.

`runcode(code)'
     Execute a code object.  When an exception occurs,
     `showtraceback()' is called to display a traceback.  All
     exceptions are caught except `SystemExit', which is allowed to
     propagate.

     A note about `KeyboardInterrupt': this exception may occur
     elsewhere in this code, and may not always be caught.  The caller
     should be prepared to deal with it.

`showsyntaxerror([filename])'
     Display the syntax error that just occurred.  This does not display
     a stack trace because there isn't one for syntax errors.  If
     FILENAME is given, it is stuffed into the exception instead of the
     default filename provided by Python's parser, because it always
     uses `'<string>'' when reading from a string.  The output is
     written by the `write()' method.

`showtraceback()'
     Display the exception that just occurred.  We remove the first
     stack item because it is within the interpreter object
     implementation.  The output is written by the `write()' method.

`write(data)'
     Write a string to the standard error stream (`sys.stderr').
     Derived classes should override this to provide the appropriate
     output handling as needed.


File: python-lib.info,  Node: Interactive Console Objects,  Prev: Interactive Interpreter Objects,  Up: code

Interactive Console Objects
---------------------------

The `InteractiveConsole' class is a subclass of
`InteractiveInterpreter', and so offers all the methods of the
interpreter objects as well as the following additions.

`interact([banner])'
     Closely emulate the interactive Python console.  The optional
     banner argument specify the banner to print before the first
     interaction; by default it prints a banner similar to the one
     printed by the standard Python interpreter, followed by the class
     name of the console object in parentheses (so as not to confuse
     this with the real interpreter - since it's so close!).

`push(line)'
     Push a line of source text to the interpreter.  The line should
     not have a trailing newline; it may have internal newlines.  The
     line is appended to a buffer and the interpreter's `runsource()'
     method is called with the concatenated contents of the buffer as
     source.  If this indicates that the command was executed or
     invalid, the buffer is reset; otherwise, the command is
     incomplete, and the buffer is left as it was after the line was
     appended.  The return value is `True' if more input is required,
     `False' if the line was dealt with in some way (this is the same as
     `runsource()').

`resetbuffer()'
     Remove any unhandled source text from the input buffer.

`raw_input([prompt])'
     Write a prompt and read a line.  The returned line does not include
     the trailing newline.  When the user enters the `EOF' key sequence,
     `EOFError' is raised.  The base implementation uses the built-in
     function `raw_input()'; a subclass may replace this with a
     different implementation.


File: python-lib.info,  Node: codeop,  Next: pprint,  Prev: code,  Up: Python Runtime Services

Compile Python code
===================

Compile (possibly incomplete) Python code.

The `codeop' module provides utilities upon which the Python
read-eval-print loop can be emulated, as is done in the `code' module.
As a result, you probably don't want to use the module directly; if you
want to include such a loop in your program you probably want to use
the `code' module instead.

There are two parts to this job:

  1. Being able to tell if a line of input completes a Python
     statement: in short, telling whether to print ``>`>'>~' or
     ``...~'' next.

  2. Remembering which future statements the user has entered, so
     subsequent input can be compiled with these in effect.

The `codeop' module provides a way of doing each of these things, and a
way of doing them both.

To do just the former:

`compile_command(source[, filename[, symbol]])'
     Tries to compile SOURCE, which should be a string of Python code
     and return a code object if SOURCE is valid Python code. In that
     case, the filename attribute of the code object will be FILENAME,
     which defaults to `'<input>''.  Returns `None' if SOURCE is _not_
     valid Python code, but is a prefix of valid Python code.

     If there is a problem with SOURCE, an exception will be raised.
     `SyntaxError' is raised if there is invalid Python syntax, and
     `OverflowError' or `ValueError' if there is an invalid literal.

     The SYMBOL argument determines whether SOURCE is compiled as a
     statement (`'single'', the default) or as an expression
     (`'eval'').  Any other value will cause `ValueError' to be raised.

     *Caveat:* It is possible (but not likely) that the parser stops
     parsing with a successful outcome before reaching the end of the
     source; in this case, trailing symbols may be ignored instead of
     causing an error.  For example, a backslash followed by two
     newlines may be followed by arbitrary garbage.  This will be fixed
     once the API for the parser is better.

`Compile()'
     Instances of this class have `__call__()' methods indentical in
     signature to the built-in function `compile()', but with the
     difference that if the instance compiles program text containing a
     `__future__' statement, the instance 'remembers' and compiles all
     subsequent program texts with the statement in force.

`CommandCompiler()'
     Instances of this class have `__call__()' methods identical in
     signature to `compile_command()'; the difference is that if the
     instance compiles program text containing a `__future__'
     statement, the instance 'remembers' and compiles all subsequent
     program texts with the statement in force.

A note on version compatibility: the `Compile' and `CommandCompiler'
are new in Python 2.2.  If you want to enable the future-tracking
features of 2.2 but also retain compatibility with 2.1 and earlier
versions of Python you can either write

     try:
         from codeop import CommandCompiler
         compile_command = CommandCompiler()
         del CommandCompiler
     except ImportError:
         from codeop import compile_command

which is a low-impact change, but introduces possibly unwanted global
state into your program, or you can write:

     try:
         from codeop import CommandCompiler
     except ImportError:
         def CommandCompiler():
             from codeop import compile_command
             return compile_command

and then call `CommandCompiler' every time you need a fresh compiler
object.


File: python-lib.info,  Node: pprint,  Next: repr,  Prev: codeop,  Up: Python Runtime Services

Data pretty printer
===================

Data pretty printer.

The `pprint' module provides a capability to "pretty-print" arbitrary
Python data structures in a form which can be used as input to the
interpreter.  If the formatted structures include objects which are not
fundamental Python types, the representation may not be loadable.  This
may be the case if objects such as files, sockets, classes, or
instances are included, as well as many other builtin objects which are
not representable as Python constants.

The formatted representation keeps objects on a single line if it can,
and breaks them onto multiple lines if they don't fit within the
allowed width.  Construct `PrettyPrinter' objects explicitly if you
need to adjust the width constraint.

The `pprint' module defines one class:

`PrettyPrinter(...)'
     Construct a `PrettyPrinter' instance.  This constructor
     understands several keyword parameters.  An output stream may be
     set using the STREAM keyword; the only method used on the stream
     object is the file protocol's `write()' method.  If not specified,
     the `PrettyPrinter' adopts `sys.stdout'.  Three additional
     parameters may be used to control the formatted representation.
     The keywords are INDENT, DEPTH, and WIDTH.  The amount of
     indentation added for each recursive level is specified by INDENT;
     the default is one.  Other values can cause output to look a
     little odd, but can make nesting easier to spot.  The number of
     levels which may be printed is controlled by DEPTH; if the data
     structure being printed is too deep, the next contained level is
     replaced by `...'.  By default, there is no constraint on the
     depth of the objects being formatted.  The desired output width is
     constrained using the WIDTH parameter; the default is eighty
     characters.  If a structure cannot be formatted within the
     constrained width, a best effort will be made.

          >>> import pprint, sys
          >>> stuff = sys.path[:]
          >>> stuff.insert(0, stuff[:])
          >>> pp = pprint.PrettyPrinter(indent=4)
          >>> pp.pprint(stuff)
          [   [   '',
                  '/usr/local/lib/python1.5',
                  '/usr/local/lib/python1.5/test',
                  '/usr/local/lib/python1.5/sunos5',
                  '/usr/local/lib/python1.5/sharedmodules',
                  '/usr/local/lib/python1.5/tkinter'],
              '',
              '/usr/local/lib/python1.5',
              '/usr/local/lib/python1.5/test',
              '/usr/local/lib/python1.5/sunos5',
              '/usr/local/lib/python1.5/sharedmodules',
              '/usr/local/lib/python1.5/tkinter']
          >>>
          >>> import parser
          >>> tup = parser.ast2tuple(
          ...     parser.suite(open('pprint.py').read()))[1][1][1]
          >>> pp = pprint.PrettyPrinter(depth=6)
          >>> pp.pprint(tup)
          (266, (267, (307, (287, (288, (...))))))

The `PrettyPrinter' class supports several derivative functions:

`pformat(object)'
     Return the formatted representation of OBJECT as a string.  The
     default parameters for formatting are used.

`pprint(object[, stream])'
     Prints the formatted representation of OBJECT on STREAM, followed
     by a newline.  If STREAM is omitted, `sys.stdout' is used.  This
     may be used in the interactive interpreter instead of a `print'
     statement for inspecting values.  The default parameters for
     formatting are used.

          >>> stuff = sys.path[:]
          >>> stuff.insert(0, stuff)
          >>> pprint.pprint(stuff)
          [<Recursion on list with id=869440>,
           '',
           '/usr/local/lib/python1.5',
           '/usr/local/lib/python1.5/test',
           '/usr/local/lib/python1.5/sunos5',
           '/usr/local/lib/python1.5/sharedmodules',
           '/usr/local/lib/python1.5/tkinter']

`isreadable(object)'
     Determine if the formatted representation of OBJECT is "readable,"
     or can be used to reconstruct the value using `eval()' .  This
     always returns false for recursive objects.

          >>> pprint.isreadable(stuff)
          0

`isrecursive(object)'
     Determine if OBJECT requires a recursive representation.

One more support function is also defined:

`saferepr(object)'
     Return a string representation of OBJECT, protected against
     recursive data structures.  If the representation of OBJECT
     exposes a recursive entry, the recursive reference will be
     represented as `<Recursion on TYPENAME with id=NUMBER>'.  The
     representation is not otherwise formatted.

     >>> pprint.saferepr(stuff)
     "[<Recursion on list with id=682968>, '', '/usr/local/lib/python1.5', '/usr/loca
     l/lib/python1.5/test', '/usr/local/lib/python1.5/sunos5', '/usr/local/lib/python
     1.5/sharedmodules', '/usr/local/lib/python1.5/tkinter']"

* Menu:

* PrettyPrinter Objects::


File: python-lib.info,  Node: PrettyPrinter Objects,  Prev: pprint,  Up: pprint

PrettyPrinter Objects
---------------------

`PrettyPrinter' instances have the following methods:

`pformat(object)'
     Return the formatted representation of OBJECT.  This takes into
     Account the options passed to the `PrettyPrinter' constructor.

`pprint(object)'
     Print the formatted representation of OBJECT on the configured
     stream, followed by a newline.

The following methods provide the implementations for the corresponding
functions of the same names.  Using these methods on an instance is
slightly more efficient since new `PrettyPrinter' objects don't need to
be created.

`isreadable(object)'
     Determine if the formatted representation of the object is
     "readable," or can be used to reconstruct the value using `eval()'
     .  Note that this returns false for recursive objects.  If the
     DEPTH parameter of the `PrettyPrinter' is set and the object is
     deeper than allowed, this returns false.

`isrecursive(object)'
     Determine if the object requires a recursive representation.

This method is provided as a hook to allow subclasses to modify the way
objects are converted to strings.  The default implementation uses the
internals of the `saferepr()' implementation.

`format(object, context, maxlevels, level)'
     Returns three values: the formatted version of OBJECT as a string,
     a flag indicating whether the result is readable, and a flag
     indicating whether recursion was detected.  The first argument is
     the object to be presented.  The second is a dictionary which
     contains the `id()' of objects that are part of the current
     presentation context (direct and indirect containers for OBJECT
     that are affecting the presentation) as the keys; if an object
     needs to be presented which is already represented in CONTEXT, the
     third return value should be true.  Recursive calls to the
     `format()' method should add additionaly entries for containers to
     this dictionary.  The fourth argument, MAXLEVELS, gives the
     requested limit to recursion; this will be `0' if there is no
     requested limit.  This argument should be passed unmodified to
     recursive calls.  The fourth argument, LEVEL gives the current
     level; recursive calls should be passed a value less than that of
     the current call.  _Added in Python version 2.3_


File: python-lib.info,  Node: repr,  Next: new,  Prev: pprint,  Up: Python Runtime Services

Alternate `repr()' implementation
=================================

Alternate `repr()' implementation with size limits.

The `repr' module provides a means for producing object representations
with limits on the size of the resulting strings.  This is used in the
Python debugger and may be useful in other contexts as well.

This module provides a class, an instance, and a function:

`Repr()'
     Class which provides formatting services useful in implementing
     functions similar to the built-in `repr()'; size limits for
     different object types are added to avoid the generation of
     representations which are excessively long.

`aRepr'
     This is an instance of `Repr' which is used to provide the
     `repr()' function described below.  Changing the attributes of
     this object will affect the size limits used by `repr()' and the
     Python debugger.

`repr(obj)'
     This is the `repr()' method of `aRepr'.  It returns a string
     similar to that returned by the built-in function of the same
     name, but with limits on most sizes.

* Menu:

* Repr Objects::
* Subclassing Repr Objects::


File: python-lib.info,  Node: Repr Objects,  Next: Subclassing Repr Objects,  Prev: repr,  Up: repr

Repr Objects
------------

`Repr' instances provide several members which can be used to provide
size limits for the representations of different object types, and
methods which format specific object types.

`maxlevel'
     Depth limit on the creation of recursive representations.  The
     default is `6'.

`maxdict'

`maxlist'

`maxtuple'
     Limits on the number of entries represented for the named object
     type.  The default for `maxdict' is `4', for the others, `6'.

`maxlong'
     Maximum number of characters in the representation for a long
     integer.  Digits are dropped from the middle.  The default is `40'.

`maxstring'
     Limit on the number of characters in the representation of the
     string.  Note that the "normal" representation of the string is
     used as the character source: if escape sequences are needed in the
     representation, these may be mangled when the representation is
     shortened.  The default is `30'.

`maxother'
     This limit is used to control the size of object types for which no
     specific formatting method is available on the `Repr' object.  It
     is applied in a similar manner as `maxstring'.  The default is
     `20'.

`repr(obj)'
     The equivalent to the built-in `repr()' that uses the formatting
     imposed by the instance.

`repr1(obj, level)'
     Recursive implementation used by `repr()'.  This uses the type of
     OBJ to determine which formatting method to call, passing it OBJ
     and LEVEL.  The type-specific methods should call `repr1()' to
     perform recursive formatting, with `LEVEL - 1' for the value of
     LEVEL in the recursive call.

`repr_TYPE(obj, level)'
     Formatting methods for specific types are implemented as methods
     with a name based on the type name.  In the method name, TYPE is
     replaced by `string.join(string.split(type(OBJ).__name__, '_'))'.
     Dispatch to these methods is handled by `repr1()'.  Type-specific
     methods which need to recursively format a value should call
     `self.repr1(SUBOBJ, LEVEL - 1)'.


File: python-lib.info,  Node: Subclassing Repr Objects,  Prev: Repr Objects,  Up: repr

Subclassing Repr Objects
------------------------

The use of dynamic dispatching by `Repr.repr1()' allows subclasses of
`Repr' to add support for additional built-in object types or to modify
the handling of types already supported.  This example shows how
special support for file objects could be added:

     import repr
     import sys
     
     class MyRepr(repr.Repr):
         def repr_file(self, obj, level):
             if obj.name in ['<stdin>', '<stdout>', '<stderr>']:
                 return obj.name
             else:
                 return `obj`
     
     aRepr = MyRepr()
     print aRepr.repr(sys.stdin)          # prints '<stdin>'


File: python-lib.info,  Node: new,  Next: site,  Prev: repr,  Up: Python Runtime Services

Creation of runtime internal objects
====================================

Interface to the creation of runtime implementation objects.

The `new' module allows an interface to the interpreter object creation
functions. This is for use primarily in marshal-type functions, when a
new object needs to be created "magically" and not by using the regular
creation functions. This module provides a low-level interface to the
interpreter, so care must be exercised when using this module.

The `new' module defines the following functions:

`instance(class[, dict])'
     This function creates an instance of CLASS with dictionary DICT
     without calling the `__init__()' constructor.  If DICT is omitted
     or `None', a new, empty dictionary is created for the new
     instance.  Note that there are no guarantees that the object will
     be in a consistent state.

`instancemethod(function, instance, class)'
     This function will return a method object, bound to INSTANCE, or
     unbound if INSTANCE is `None'.  FUNCTION must be callable.

`function(code, globals[, name[, argdefs]])'
     Returns a (Python) function with the given code and globals. If
     NAME is given, it must be a string or `None'.  If it is a string,
     the function will have the given name, otherwise the function name
     will be taken from `CODE.co_name'.  If ARGDEFS is given, it must
     be a tuple and will be used to determine the default values of
     parameters.

`code(argcount, nlocals, stacksize, flags, codestring, constants, names, varnames, filename, name, firstlineno, lnotab)'
     This function is an interface to the `PyCode_New()' C function.

`module(name)'
     This function returns a new module object with name NAME.  NAME
     must be a string.

`classobj(name, baseclasses, dict)'
     This function returns a new class object, with name NAME, derived
     from BASECLASSES (which should be a tuple of classes) and with
     namespace DICT.


File: python-lib.info,  Node: site,  Next: user,  Prev: new,  Up: Python Runtime Services

Site-specific configuration hook
================================

A standard way to reference site-specific modules.

*This module is automatically imported during initialization.*

In earlier versions of Python (up to and including 1.5a3), scripts or
modules that needed to use site-specific modules would place `import
site' somewhere near the top of their code.  This is no longer
necessary.

This will append site-specific paths to the module search path.

It starts by constructing up to four directories from a head and a tail
part.  For the head part, it uses `sys.prefix' and `sys.exec_prefix';
empty heads are skipped.  For the tail part, it uses the empty string
(on Macintosh or Windows) or it uses first
`lib/python2.3/site-packages' and then `lib/site-python' (on UNIX).
For each of the distinct head-tail combinations, it sees if it refers
to an existing directory, and if so, adds it to `sys.path' and also
inspects the newly added path for configuration files.

A path configuration file is a file whose name has the form
`PACKAGE.pth'; its contents are additional items (one per line) to be
added to `sys.path'.  Non-existing items are never added to `sys.path',
but no check is made that the item refers to a directory (rather than a
file).  No item is added to `sys.path' more than once.  Blank lines and
lines beginning with `#' are skipped.  Lines starting with `import' are
executed.

For example, suppose `sys.prefix' and `sys.exec_prefix' are set to
`/usr/local'.  The Python 2.3.2 library is then installed in
`/usr/local/lib/python2.3' (where only the first three characters of
`sys.version' are used to form the installation path name).  Suppose
this has a subdirectory `/usr/local/lib/python2.3/site-packages' with
three subsubdirectories, `foo', `bar' and `spam', and two path
configuration files, `foo.pth' and `bar.pth'.  Assume `foo.pth'
contains the following:

     # foo package configuration
     
     foo
     bar
     bletch

and `bar.pth' contains:

     # bar package configuration
     
     bar

Then the following directories are added to `sys.path', in this order:

     /usr/local/lib/python2.3/site-packages/bar
     /usr/local/lib/python2.3/site-packages/foo

Note that `bletch' is omitted because it doesn't exist; the `bar'
directory precedes the `foo' directory because `bar.pth' comes
alphabetically before `foo.pth'; and `spam' is omitted because it is
not mentioned in either path configuration file.

After these path manipulations, an attempt is made to import a module
named `sitecustomize' , which can perform arbitrary site-specific
customizations.  If this import fails with an `ImportError' exception,
it is silently ignored.

Note that for some non-UNIX systems, `sys.prefix' and `sys.exec_prefix'
are empty, and the path manipulations are skipped; however the import of
`sitecustomize'  is still attempted.


File: python-lib.info,  Node: user,  Next: __builtin__,  Prev: site,  Up: Python Runtime Services

User-specific configuration hook
================================

A standard way to reference user-specific modules.

As a policy, Python doesn't run user-specified code on startup of
Python programs.  (Only interactive sessions execute the script
specified in the `PYTHONSTARTUP' environment variable if it exists).

However, some programs or sites may find it convenient to allow users
to have a standard customization file, which gets run when a program
requests it.  This module implements such a mechanism.  A program that
wishes to use the mechanism must execute the statement

     import user

The `user' module looks for a file `.pythonrc.py' in the user's home
directory and if it can be opened, executes it (using `execfile()' ) in
its own (the module `user''s) global namespace.  Errors during this
phase are not caught; that's up to the program that imports the `user'
module, if it wishes.  The home directory is assumed to be named by the
`HOME' environment variable; if this is not set, the current directory
is used.

The user's `.pythonrc.py' could conceivably test for `sys.version' if
it wishes to do different things depending on the Python version.

A warning to users: be very conservative in what you place in your
`.pythonrc.py' file.  Since you don't know which programs will use it,
changing the behavior of standard modules or functions is generally not
a good idea.

A suggestion for programmers who wish to use this mechanism: a simple
way to let users specify options for your package is to have them
define variables in their `.pythonrc.py' file that you test in your
module.  For example, a module `spam' that has a verbosity level can
look for a variable `user.spam_verbose', as follows:

     import user
     try:
         verbose = user.spam_verbose  # user's verbosity preference
     except AttributeError:
         verbose = 0                  # default verbosity

Programs with extensive customization needs are better off reading a
program-specific customization file.

Programs with security or privacy concerns should _not_ import this
module; a user can easily break into a program by placing arbitrary
code in the `.pythonrc.py' file.

Modules for general use should _not_ import this module; it may
interfere with the operation of the importing program.

See also:
     *Note site:: Site-wide customization mechanism.

