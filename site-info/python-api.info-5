This is python-api.info, produced by makeinfo version 4.3 from
python-api.texi.

October 3, 2003


File: python-api.info,  Node: Dictionary Objects,  Prev: Mapping Objects,  Up: Mapping Objects

Dictionary Objects
------------------

`PyDictObject'
     This subtype of `PyObject' represents a Python dictionary object.

`PyTypeObject PyDict_Type'
     This instance of `PyTypeObject' represents the Python dictionary
     type.  This is exposed to Python programs as `types.DictType' and
     `types.DictionaryType'.

`int PyDict_Check(PyObject *p)'
     Returns true if its argument is a `PyDictObject'.

`PyObject* PyDict_New()'
     Returns a new empty dictionary, or `NULL' on failure.

`PyObject* PyDictProxy_New(PyObject *dict)'
     Return a proxy object for a mapping which enforces read-only
     behavior.  This is normally used to create a proxy to prevent
     modification of the dictionary for non-dynamic class types.
     _Added in Python version 2.2_

`void PyDict_Clear(PyObject *p)'
     Empties an existing dictionary of all key-value pairs.

`PyObject* PyDict_Copy(PyObject *p)'
     Returns a new dictionary that contains the same key-value pairs as
     P.  _Added in Python version 1.6_

`int PyDict_SetItem(PyObject *p, PyObject *key, PyObject *val)'
     Inserts VALUE into the dictionary P with a key of KEY.  KEY must
     be hashable; if it isn't, `TypeError' will be raised.  Returns `0'
     on success or `-1' on failure.

`int PyDict_SetItemString(PyObject *p, char *key, PyObject *val)'
     Inserts VALUE into the dictionary P using KEY as a key. KEY should
     be a `char*'.  The key object is created using
     `PyString_FromString(KEY)'. Returns `0' on success or `-1' on
     failure.

`int PyDict_DelItem(PyObject *p, PyObject *key)'
     Removes the entry in dictionary P with key KEY.  KEY must be
     hashable; if it isn't, `TypeError' is raised.  Returns `0' on
     success or `-1' on failure.

`int PyDict_DelItemString(PyObject *p, char *key)'
     Removes the entry in dictionary P which has a key specified by the
     string KEY.  Returns `0' on success or `-1' on failure.

`PyObject* PyDict_GetItem(PyObject *p, PyObject *key)'
     Returns the object from dictionary P which has a key KEY.  Returns
     `NULL' if the key KEY is not present, but _without_ setting an
     exception.

`PyObject* PyDict_GetItemString(PyObject *p, char *key)'
     This is the same as `PyDict_GetItem()', but KEY is specified as a
     `char*', rather than a `PyObject*'.

`PyObject* PyDict_Items(PyObject *p)'
     Returns a `PyListObject' containing all the items from the
     dictionary, as in the dictinoary method `items()' (see the ).

`PyObject* PyDict_Keys(PyObject *p)'
     Returns a `PyListObject' containing all the keys from the
     dictionary, as in the dictionary method `keys()' (see the ).

`PyObject* PyDict_Values(PyObject *p)'
     Returns a `PyListObject' containing all the values from the
     dictionary P, as in the dictionary method `values()' (see the ).

`int PyDict_Size(PyObject *p)'
     Returns the number of items in the dictionary.  This is equivalent
     to `len(P)' on a dictionary.

`int PyDict_Next(PyObject *p, int *ppos, PyObject **pkey, PyObject **pvalue)'
     Iterate over all key-value pairs in the dictionary P.  The `int'
     referred to by PPOS must be initialized to `0' prior to the first
     call to this function to start the iteration; the function returns
     true for each pair in the dictionary, and false once all pairs
     have been reported.  The parameters PKEY and PVALUE should either
     point to `PyObject*' variables that will be filled in with each
     key and value, respectively, or may be `NULL'.  Any references
     returned through them are borrowed.

     For example:

          PyObject *key, *value;
          int pos = 0;
          
          while (PyDict_Next(self->dict, &pos, &key, &value)) {
              /* do something interesting with the values... */
              ...
          }

     The dictionary P should not be mutated during iteration.  It is
     safe (since Python 2.1) to modify the values of the keys as you
     iterate over the dictionary, but only so long as the set of keys
     does not change.  For example:

          PyObject *key, *value;
          int pos = 0;
          
          while (PyDict_Next(self->dict, &pos, &key, &value)) {
              int i = PyInt_AS_LONG(value) + 1;
              PyObject *o = PyInt_FromLong(i);
              if (o == NULL)
                  return -1;
              if (PyDict_SetItem(self->dict, key, o) < 0) {
                  Py_DECREF(o);
                  return -1;
              }
              Py_DECREF(o);
          }

`int PyDict_Merge(PyObject *a, PyObject *b, int override)'
     Iterate over mapping object B adding key-value pairs to dictionary
     A.  B may be a dictionary, or any object supporting
     `PyMapping_Keys()' and `PyObject_GetItem()'.  If OVERRIDE is true,
     existing pairs in A will be replaced if a matching key is found in
     B, otherwise pairs will only be added if there is not a matching
     key in A.  Return `0' on success or `-1' if an exception was
     raised.  _Added in Python version 2.2_

`int PyDict_Update(PyObject *a, PyObject *b)'
     This is the same as `PyDict_Merge(A, B, 1)' in C, or `A.update(B)'
     in Python.  Return `0' on success or `-1' if an exception was
     raised.  _Added in Python version 2.2_

`int PyDict_MergeFromSeq2(PyObject *a, PyObject *seq2, int override)'
     Update or merge into dictionary A, from the key-value pairs in
     SEQ2.  SEQ2 must be an iterable object producing iterable objects
     of length 2, viewed as key-value pairs.  In case of duplicate
     keys, the last wins if OVERRIDE is true, else the first wins.
     Return `0' on success or `-1' if an exception was raised.
     Equivalent Python (except for the return value):

          def PyDict_MergeFromSeq2(a, seq2, override):
              for key, value in seq2:
                  if override or key not in a:
                      a[key] = value

     _Added in Python version 2.2_


File: python-api.info,  Node: Other Objects,  Prev: Mapping Objects,  Up: Concrete Objects Layer

Other Objects
=============

* Menu:

* File Objects::
* Instance Objects::
* Method Objects::
* Module Objects::
* Iterator Objects::
* Descriptor Objects::
* Slice Objects::
* Weak Reference Objects::
* CObjects::
* Cell Objects::


File: python-api.info,  Node: File Objects,  Next: Instance Objects,  Prev: Other Objects,  Up: Other Objects

File Objects
------------

Python's built-in file objects are implemented entirely on the `FILE*'
support from the C standard library.  This is an implementation detail
and may change in future releases of Python.

`PyFileObject'
     This subtype of `PyObject' represents a Python file object.

`PyTypeObject PyFile_Type'
     This instance of `PyTypeObject' represents the Python file type.
     This is exposed to Python programs as `types.FileType'.

`int PyFile_Check(PyObject *p)'
     Returns true if its argument is a `PyFileObject' or a subtype of
     `PyFileObject'.  _Changed in Python version 2.2_

`int PyFile_CheckExact(PyObject *p)'
     Returns true if its argument is a `PyFileObject', but not a
     subtype of `PyFileObject'.  _Added in Python version 2.2_

`PyObject* PyFile_FromString(char *filename, char *mode)'
     On success, returns a new file object that is opened on the file
     given by FILENAME, with a file mode given by MODE, where MODE has
     the same semantics as the standard C routine `fopen()' .  On
     failure, returns `NULL'.

`PyObject* PyFile_FromFile(FILE *fp, char *name, char *mode, int (*close)(FILE*))'
     Creates a new `PyFileObject' from the already-open standard C file
     pointer, FP.  The function CLOSE will be called when the file
     should be closed.  Returns `NULL' on failure.

`FILE* PyFile_AsFile(PyFileObject *p)'
     Returns the file object associated with P as a `FILE*'.

`PyObject* PyFile_GetLine(PyObject *p, int n)'
     Equivalent to `P.readline([N])', this function reads one line from
     the object P.  P may be a file object or any object with a
     `readline()' method.  If N is `0', exactly one line is read,
     regardless of the length of the line.  If N is greater than `0',
     no more than N bytes will be read from the file; a partial line
     can be returned.  In both cases, an empty string is returned if
     the end of the file is reached immediately.  If N is less than `0',
     however, one line is read regardless of length, but `EOFError' is
     raised if the end of the file is reached immediately.

`PyObject* PyFile_Name(PyObject *p)'
     Returns the name of the file specified by P as a string object.

`void PyFile_SetBufSize(PyFileObject *p, int n)'
     Available on systems with `setvbuf()' only.  This should only be
     called immediately after file object creation.

`int PyFile_Encoding(PyFileObject *p, char *enc)'
     Set the file's encoding for Unicode output to ENC. Return 1 on
     success and 0 on failure.  _Added in Python version 2.3_

`int PyFile_SoftSpace(PyObject *p, int newflag)'
     This function exists for internal use by the interpreter.  Sets the
     `softspace' attribute of P to NEWFLAG and returns the previous
     value.  P does not have to be a file object for this function to
     work properly; any object is supported (thought its only
     interesting if the `softspace' attribute can be set).  This
     function clears any errors, and will return `0' as the previous
     value if the attribute either does not exist or if there were
     errors in retrieving it.  There is no way to detect errors from
     this function, but doing so should not be needed.

`int PyFile_WriteObject(PyObject *obj, PyFileObject *p, int flags)'
     Writes object OBJ to file object P.  The only supported flag for
     FLAGS is `Py_PRINT_RAW' ; if given, the `str()' of the object is
     written instead of the `repr()'.  Returns `0' on success or `-1' on
     failure; the appropriate exception will be set.

`int PyFile_WriteString(const char *s, PyFileObject *p)'
     Writes string S to file object P.  Returns `0' on success or `-1'
     on failure; the appropriate exception will be set.


File: python-api.info,  Node: Instance Objects,  Next: Method Objects,  Prev: File Objects,  Up: Other Objects

Instance Objects
----------------

There are very few functions specific to instance objects.

`PyTypeObject PyInstance_Type'
     Type object for class instances.

`int PyInstance_Check(PyObject *obj)'
     Returns true if OBJ is an instance.

`PyObject* PyInstance_New(PyObject *class, PyObject *arg, PyObject *kw)'
     Create a new instance of a specific class.  The parameters ARG and
     KW are used as the positional and keyword parameters to the
     object's constructor.

`PyObject* PyInstance_NewRaw(PyObject *class, PyObject *dict)'
     Create a new instance of a specific class without calling it's
     constructor.  CLASS is the class of new object.  The DICT
     parameter will be used as the object's `__dict__'; if `NULL', a
     new dictionary will be created for the instance.


File: python-api.info,  Node: Method Objects,  Next: Module Objects,  Prev: Instance Objects,  Up: Other Objects

Method Objects
--------------

There are some useful functions that are useful for working with method
objects.

`PyTypeObject PyMethod_Type'
     This instance of `PyTypeObject' represents the Python method type.
     This is exposed to Python programs as `types.MethodType'.

`int PyMethod_Check(PyObject *o)'
     Return true if O is a method object (has type `PyMethod_Type').
     The parameter must not be `NULL'.

`PyObject* PyMethod_New(PyObject *func. PyObject *self, PyObject *class)'
     Return a new method object, with FUNC being any callable object;
     this is the function that will be called when the method is
     called.  If this method should be bound to an instance, SELF
     should be the instance and CLASS should be the class of SELF,
     otherwise SELF should be `NULL' and CLASS should be the class
     which provides the unbound method..

`PyObject* PyMethod_Class(PyObject *meth)'
     Return the class object from which the method METH was created; if
     this was created from an instance, it will be the class of the
     instance.

`PyObject* PyMethod_GET_CLASS(PyObject *meth)'
     Macro version of `PyMethod_Class()' which avoids error checking.

`PyObject* PyMethod_Function(PyObject *meth)'
     Return the function object associated with the method METH.

`PyObject* PyMethod_GET_FUNCTION(PyObject *meth)'
     Macro version of `PyMethod_Function()' which avoids error checking.

`PyObject* PyMethod_Self(PyObject *meth)'
     Return the instance associated with the method METH if it is
     bound, otherwise return `NULL'.

`PyObject* PyMethod_GET_SELF(PyObject *meth)'
     Macro version of `PyMethod_Self()' which avoids error checking.


File: python-api.info,  Node: Module Objects,  Next: Iterator Objects,  Prev: Method Objects,  Up: Other Objects

Module Objects
--------------

There are only a few functions special to module objects.

`PyTypeObject PyModule_Type'
     This instance of `PyTypeObject' represents the Python module type.
     This is exposed to Python programs as `types.ModuleType'.

`int PyModule_Check(PyObject *p)'
     Returns true if P is a module object, or a subtype of a module
     object.  _Changed in Python version 2.2_

`int PyModule_CheckExact(PyObject *p)'
     Returns true if P is a module object, but not a subtype of
     `PyModule_Type'.  _Added in Python version 2.2_

`PyObject* PyModule_New(char *name)'
     Return a new module object with the `__name__' attribute set to
     NAME.  Only the module's `__doc__' and `__name__' attributes are
     filled in; the caller is responsible for providing a `__file__'
     attribute.

`PyObject* PyModule_GetDict(PyObject *module)'
     Return the dictionary object that implements MODULE's namespace;
     this object is the same as the `__dict__' attribute of the module
     object.  This function never fails.  It is recommended extensions
     use other `PyModule_*()' and `PyObject_*()' functions rather than
     directly manipulate a module's `__dict__'.

`char* PyModule_GetName(PyObject *module)'
     Return MODULE's `__name__' value.  If the module does not provide
     one, or if it is not a string, `SystemError' is raised and `NULL'
     is returned.

`char* PyModule_GetFilename(PyObject *module)'
     Return the name of the file from which MODULE was loaded using
     MODULE's `__file__' attribute.  If this is not defined, or if it
     is not a string, raise `SystemError' and return `NULL'.

`int PyModule_AddObject(PyObject *module, char *name, PyObject *value)'
     Add an object to MODULE as NAME.  This is a convenience function
     which can be used from the module's initialization function.  This
     steals a reference to VALUE.  Returns `-1' on error, `0' on
     success.  _Added in Python version 2.0_

`int PyModule_AddIntConstant(PyObject *module, char *name, int value)'
     Add an integer constant to MODULE as NAME.  This convenience
     function can be used from the module's initialization function.
     Returns `-1' on error, `0' on success.  _Added in Python version
     2.0_

`int PyModule_AddStringConstant(PyObject *module, char *name, char *value)'
     Add a string constant to MODULE as NAME.  This convenience
     function can be used from the module's initialization function.
     The string VALUE must be null-terminated.  Returns `-1' on error,
     `0' on success.  _Added in Python version 2.0_


File: python-api.info,  Node: Iterator Objects,  Next: Descriptor Objects,  Prev: Module Objects,  Up: Other Objects

Iterator Objects
----------------

Python provides two general-purpose iterator objects.  The first, a
sequence iterator, works with an arbitrary sequence supporting the
`__getitem__()' method.  The second works with a callable object and a
sentinel value, calling the callable for each item in the sequence, and
ending the iteration when the sentinel value is returned.

`PyTypeObject PySeqIter_Type'
     Type object for iterator objects returned by `PySeqIter_New()' and
     the one-argument form of the `iter()' built-in function for
     built-in sequence types.  _Added in Python version 2.2_

`int PySeqIter_Check(op)'
     Return true if the type of OP is `PySeqIter_Type'.  _Added in
     Python version 2.2_

`PyObject* PySeqIter_New(PyObject *seq)'
     Return an iterator that works with a general sequence object, SEQ.
     The iteration ends when the sequence raises `IndexError' for the
     subscripting operation.  _Added in Python version 2.2_

`PyTypeObject PyCallIter_Type'
     Type object for iterator objects returned by `PyCallIter_New()'
     and the two-argument form of the `iter()' built-in function.
     _Added in Python version 2.2_

`int PyCallIter_Check(op)'
     Return true if the type of OP is `PyCallIter_Type'.  _Added in
     Python version 2.2_

`PyObject* PyCallIter_New(PyObject *callable, PyObject *sentinel)'
     Return a new iterator.  The first parameter, CALLABLE, can be any
     Python callable object that can be called with no parameters; each
     call to it should return the next item in the iteration.  When
     CALLABLE returns a value equal to SENTINEL, the iteration will be
     terminated.  _Added in Python version 2.2_


File: python-api.info,  Node: Descriptor Objects,  Next: Slice Objects,  Prev: Iterator Objects,  Up: Other Objects

Descriptor Objects
------------------

"Descriptors" are objects that describe some attribute of an object.
They are found in the dictionary of type objects.

`PyTypeObject PyProperty_Type'
     The type object for the built-in descriptor types.  _Added in
     Python version 2.2_

`PyObject* PyDescr_NewGetSet(PyTypeObject *type, PyGetSetDef *getset)'
     _Added in Python version 2.2_

`PyObject* PyDescr_NewMember(PyTypeObject *type, PyMemberDef *meth)'
     _Added in Python version 2.2_

`PyObject* PyDescr_NewMethod(PyTypeObject *type, PyMethodDef *meth)'
     _Added in Python version 2.2_

`PyObject* PyDescr_NewWrapper(PyTypeObject *type, struct wrapperbase *wrapper, void *wrapped)'
     _Added in Python version 2.2_

`int PyDescr_IsData(PyObject *descr)'
     Returns true if the descriptor objects DESCR describes a data
     attribute, or false if it describes a method.  DESCR must be a
     descriptor object; there is no error checking.  _Added in Python
     version 2.2_

`PyObject* PyWrapper_New(PyObject *, PyObject *)'
     _Added in Python version 2.2_


File: python-api.info,  Node: Slice Objects,  Next: Weak Reference Objects,  Prev: Descriptor Objects,  Up: Other Objects

Slice Objects
-------------

`PyTypeObject PySlice_Type'
     The type object for slice objects.  This is the same as
     `types.SliceType'.

`int PySlice_Check(PyObject *ob)'
     Returns true if OB is a slice object; OB must not be `NULL'.

`PyObject* PySlice_New(PyObject *start, PyObject *stop, PyObject *step)'
     Return a new slice object with the given values.  The START, STOP,
     and STEP parameters are used as the values of the slice object
     attributes of the same names.  Any of the values may be `NULL', in
     which case the `None' will be used for the corresponding
     attribute.  Returns `NULL' if the new object could not be
     allocated.

`int PySlice_GetIndices(PySliceObject *slice, int length, int *start, int *stop, int *step)'
     Retrieve the start, stop and step indices from the slice object
     SLICE, assuming a sequence of length LENGTH. Treats indices
     greater than LENGTH as errors.

     Returns 0 on success and -1 on error with no exception set (unless
     one of the indices was not `None' and failed to be converted to an
     integer, in which case -1 is returned with an exception set).

     You probably do not want to use this function.  If you want to use
     slice objects in versions of Python prior to 2.3, you would
     probably do well to incorporate the source of
     `PySlice_GetIndicesEx', suitably renamed, in the source of your
     extension.

`int PySlice_GetIndicesEx(PySliceObject *slice, int length, int *start, int *stop, int *step,  int *slicelength)'
     Usable replacement for `PySlice_GetIndices'.  Retrieve the start,
     stop, and step indices from the slice object SLICE assuming a
     sequence of length LENGTH, and store the length of the slice in
     SLICELENGTH.  Out of bounds indices are clipped in a manner
     consistent with the handling of normal slices.

     Returns 0 on success and -1 on error with exception set.

     _Added in Python version 2.3_


File: python-api.info,  Node: Weak Reference Objects,  Next: CObjects,  Prev: Slice Objects,  Up: Other Objects

Weak Reference Objects
----------------------

Python supports _weak references_ as first-class objects.  There are
two specific object types which directly implement weak references.
The first is a simple reference object, and the second acts as a proxy
for the original object as much as it can.

`int PyWeakref_Check(ob)'
     Return true if OB is either a reference or proxy object.  _Added
     in Python version 2.2_

`int PyWeakref_CheckRef(ob)'
     Return true if OB is a reference object.  _Added in Python version
     2.2_

`int PyWeakref_CheckProxy(ob)'
     Return true if OB is a proxy object.  _Added in Python version 2.2_

`PyObject* PyWeakref_NewRef(PyObject *ob, PyObject *callback)'
     Return a weak reference object for the object OB.  This will
     always return a new reference, but is not guaranteed to create a
     new object; an existing reference object may be returned.  The
     second parameter, CALLBACK, can be a callable object that receives
     notification when OB is garbage collected; it should accept a
     single paramter, which will be the weak reference object itself.
     CALLBACK may also be `None' or `NULL'.  If OB is not a
     weakly-referencable object, or if CALLBACK is not callable,
     `None', or `NULL', this will return `NULL' and raise `TypeError'.
     _Added in Python version 2.2_

`PyObject* PyWeakref_NewProxy(PyObject *ob, PyObject *callback)'
     Return a weak reference proxy object for the object OB.  This will
     always return a new reference, but is not guaranteed to create a
     new object; an existing proxy object may be returned.  The second
     parameter, CALLBACK, can be a callable object that receives
     notification when OB is garbage collected; it should accept a
     single paramter, which will be the weak reference object itself.
     CALLBACK may also be `None' or `NULL'.  If OB is not a
     weakly-referencable object, or if CALLBACK is not callable,
     `None', or `NULL', this will return `NULL' and raise `TypeError'.
     _Added in Python version 2.2_

`PyObject* PyWeakref_GetObject(PyObject *ref)'
     Returns the referenced object from a weak reference, REF.  If the
     referent is no longer live, returns `None'.  _Added in Python
     version 2.2_

`PyObject* PyWeakref_GET_OBJECT(PyObject *ref)'
     Similar to `PyWeakref_GetObject()', but implemented as a macro
     that does no error checking.  _Added in Python version 2.2_


File: python-api.info,  Node: CObjects,  Next: Cell Objects,  Prev: Weak Reference Objects,  Up: Other Objects

CObjects
--------

Refer to _Extending and Embedding the Python Interpreter_,
section~1.12, "Providing a C API for an Extension Module," for more
information on using these objects.

`PyCObject'
     This subtype of `PyObject' represents an opaque value, useful for
     C extension modules who need to pass an opaque value (as a `void*'
     pointer) through Python code to other C code.  It is often used to
     make a C function pointer defined in one module available to other
     modules, so the regular import mechanism can be used to access C
     APIs defined in dynamically loaded modules.

`int PyCObject_Check(PyObject *p)'
     Returns true if its argument is a `PyCObject'.

`PyObject* PyCObject_FromVoidPtr(void* cobj, void (*destr)(void *))'
     Creates a `PyCObject' from the `void *'COBJ.  The DESTR function
     will be called when the object is reclaimed, unless it is `NULL'.

`PyObject* PyCObject_FromVoidPtrAndDesc(void* cobj, void* desc, void (*destr)(void *, void *))'
     Creates a `PyCObject' from the `void *'COBJ.  The DESTR function
     will be called when the object is reclaimed.  The DESC argument
     can be used to pass extra callback data for the destructor
     function.

`void* PyCObject_AsVoidPtr(PyObject* self)'
     Returns the object `void *' that the `PyCObject' SELF was created
     with.

`void* PyCObject_GetDesc(PyObject* self)'
     Returns the description `void *' that the `PyCObject' SELF was
     created with.


File: python-api.info,  Node: Cell Objects,  Prev: CObjects,  Up: Other Objects

Cell Objects
------------

"Cell" objects are used to implement variables referenced by multiple
scopes.  For each such variable, a cell object is created to store the
value; the local variables of each stack frame that references the
value contains a reference to the cells from outer scopes which also
use that variable.  When the value is accessed, the value contained in
the cell is used instead of the cell object itself.  This
de-referencing of the cell object requires support from the generated
byte-code; these are not automatically de-referenced when accessed.
Cell objects are not likely to be useful elsewhere.

`PyCellObject'
     The C structure used for cell objects.

`PyTypeObject PyCell_Type'
     The type object corresponding to cell objects

`int PyCell_Check(ob)'
     Return true if OB is a cell object; OB must not be `NULL'.

`PyObject* PyCell_New(PyObject *ob)'
     Create and return a new cell object containing the value OB.  The
     parameter may be `NULL'.

`PyObject* PyCell_Get(PyObject *cell)'
     Return the contents of the cell CELL.

`PyObject* PyCell_GET(PyObject *cell)'
     Return the contents of the cell CELL, but without checking that
     CELL is non-`NULL' and a cell object.

`int PyCell_Set(PyObject *cell, PyObject *value)'
     Set the contents of the cell object CELL to VALUE.  This releases
     the reference to any current content of the cell.  VALUE may be
     `NULL'.  CELL must be non-`NULL'; if it is not a cell object, `-1'
     will be returned.  On success, `0' will be returned.

`void PyCell_SET(PyObject *cell, PyObject *value)'
     Sets the value of the cell object CELL to VALUE.  No reference
     counts are adjusted, and no checks are made for safety; CELL must
     be non-`NULL' and must be a cell object.


File: python-api.info,  Node: Initialization,  Next: Memory Management,  Prev: Concrete Objects Layer,  Up: Top

Initialization, Finalization, and Threads
*****************************************

`void Py_Initialize()'
     Initialize the Python interpreter.  In an application embedding
     Python, this should be called before using any other Python/C API
     functions; with the exception of `Py_SetProgramName()' ,
     `PyEval_InitThreads()' , `PyEval_ReleaseLock()' , and
     `PyEval_AcquireLock()' .  This initializes the table of loaded
     modules (`sys.modules'), and creates the fundamental modules
     `__builtin__' , `__main__'  and `sys' .  It also initializes the
     module search  path (`sys.path').  It does not set `sys.argv'; use
     `PySys_SetArgv()'  for that.  This is a no-op when called for a
     second time (without calling `Py_Finalize()'  first).  There is no
     return value; it is a fatal error if the initialization fails.

`int Py_IsInitialized()'
     Return true (nonzero) when the Python interpreter has been
     initialized, false (zero) if not.  After `Py_Finalize()' is
     called, this returns false until `Py_Initialize()' is called again.

`void Py_Finalize()'
     Undo all initializations made by `Py_Initialize()' and subsequent
     use of Python/C API functions, and destroy all sub-interpreters
     (see `Py_NewInterpreter()' below) that were created and not yet
     destroyed since the last call to `Py_Initialize()'.  Ideally, this
     frees all memory allocated by the Python interpreter.  This is a
     no-op when called for a second time (without calling
     `Py_Initialize()' again first).  There is no return value; errors
     during finalization are ignored.

     This function is provided for a number of reasons.  An embedding
     application might want to restart Python without having to restart
     the application itself.  An application that has loaded the Python
     interpreter from a dynamically loadable library (or DLL) might want
     to free all memory allocated by Python before unloading the DLL.
     During a hunt for memory leaks in an application a developer might
     want to free all memory allocated by Python before exiting from
     the application.

     *Bugs and caveats:* The destruction of modules and objects in
     modules is done in random order; this may cause destructors
     (`__del__()' methods) to fail when they depend on other objects
     (even functions) or modules.  Dynamically loaded extension modules
     loaded by Python are not unloaded.  Small amounts of memory
     allocated by the Python interpreter may not be freed (if you find a
     leak, please report it).  Memory tied up in circular references
     between objects is not freed.  Some memory allocated by extension
     modules may not be freed.  Some extensions may not work properly if
     their initialization routine is called more than once; this can
     happen if an application calls `Py_Initialize()' and
     `Py_Finalize()' more than once.

`PyThreadState* Py_NewInterpreter()'
     Create a new sub-interpreter.  This is an (almost) totally separate
     environment for the execution of Python code.  In particular, the
     new interpreter has separate, independent versions of all imported
     modules, including the fundamental modules `__builtin__' ,
     `__main__'  and `sys' .  The table of loaded modules
     (`sys.modules') and the module search path (`sys.path') are also
     separate.  The new environment has no `sys.argv' variable.  It has
     new standard I/O stream file objects `sys.stdin', `sys.stdout' and
     `sys.stderr' (however these refer to the same underlying `FILE'
     structures in the C library).

     The return value points to the first thread state created in the
     new sub-interpreter.  This thread state is made the current thread
     state.  Note that no actual thread is created; see the discussion
     of thread states below.  If creation of the new interpreter is
     unsuccessful, `NULL' is returned; no exception is set since the
     exception state is stored in the current thread state and there may
     not be a current thread state.  (Like all other Python/C API
     functions, the global interpreter lock must be held before calling
     this function and is still held when it returns; however, unlike
     most other Python/C API functions, there needn't be a current
     thread state on entry.)

     Extension modules are shared between (sub-)interpreters as follows:
     the first time a particular extension is imported, it is
     initialized normally, and a (shallow) copy of its module's
     dictionary is squirreled away.  When the same extension is
     imported by another (sub-)interpreter, a new module is initialized
     and filled with the contents of this copy; the extension's `init'
     function is not called.  Note that this is different from what
     happens when an extension is imported after the interpreter has
     been completely re-initialized by calling `Py_Finalize()'  and
     `Py_Initialize()' ; in that case, the extension's `initMODULE'
     function _is_ called again.

     *Bugs and caveats:* Because sub-interpreters (and the main
     interpreter) are part of the same process, the insulation between
     them isn't perfect -- for example, using low-level file operations
     like `os.close()' they can (accidentally or maliciously) affect
     each other's open files.  Because of the way extensions are shared
     between (sub-)interpreters, some extensions may not work properly;
     this is especially likely when the extension makes use of (static)
     global variables, or when the extension manipulates its module's
     dictionary after its initialization.  It is possible to insert
     objects created in one sub-interpreter into a namespace of another
     sub-interpreter; this should be done with great care to avoid
     sharing user-defined functions, methods, instances or classes
     between sub-interpreters, since import operations executed by such
     objects may affect the wrong (sub-)interpreter's dictionary of
     loaded modules.  (XXX This is a hard-to-fix bug that will be
     addressed in a future release.)

`void Py_EndInterpreter(PyThreadState *tstate)'
     Destroy the (sub-)interpreter represented by the given thread
     state.  The given thread state must be the current thread state.
     See the discussion of thread states below.  When the call returns,
     the current thread state is `NULL'.  All thread states associated
     with this interpreted are destroyed.  (The global interpreter lock
     must be held before calling this function and is still held when it
     returns.)  `Py_Finalize()'  will destroy all sub-interpreters that
     haven't been explicitly destroyed at that point.

`void Py_SetProgramName(char *name)'
     This function should be called before `Py_Initialize()'  is called
     for the first time, if it is called at all.  It tells the
     interpreter the value of the `argv[0]' argument to the `main()'
     function of the program.  This is used by `Py_GetPath()'  and some
     other functions below to find the Python run-time libraries
     relative to the interpreter executable.  The default value is
     `'python''.  The argument should point to a zero-terminated
     character string in static storage whose contents will not change
     for the duration of the program's execution.  No code in the Python
     interpreter will change the contents of this storage.

`char* Py_GetProgramName()'
     Return the program name set with `Py_SetProgramName()' , or the
     default.  The returned string points into static storage; the
     caller should not modify its value.

`char* Py_GetPrefix()'
     Return the _prefix_ for installed platform-independent files.
     This is derived through a number of complicated rules from the
     program name set with `Py_SetProgramName()' and some environment
     variables; for example, if the program name is
     `'/usr/local/bin/python'', the prefix is `'/usr/local''.  The
     returned string points into static storage; the caller should not
     modify its value.  This corresponds to the `prefix' variable in
     the top-level `Makefile' and the `--prefix' argument to the
     `configure' script at build time.  The value is available to
     Python code as `sys.prefix'.  It is only useful on UNIX.  See also
     the next function.

`char* Py_GetExecPrefix()'
     Return the _exec-prefix_ for installed platform-_de_pendent files.
     This is derived through a number of complicated rules from the
     program name set with `Py_SetProgramName()' and some environment
     variables; for example, if the program name is
     `'/usr/local/bin/python'', the exec-prefix is `'/usr/local''.  The
     returned string points into static storage; the caller should not
     modify its value.  This corresponds to the `exec_prefix' variable
     in the top-level `Makefile' and the `--exec-prefix' argument to the
     `configure' script at build  time.  The value is available to
     Python code as `sys.exec_prefix'.  It is only useful on UNIX.

     Background: The exec-prefix differs from the prefix when platform
     dependent files (such as executables and shared libraries) are
     installed in a different directory tree.  In a typical
     installation, platform dependent files may be installed in the
     `/usr/local/plat' subtree while platform independent may be
     installed in `/usr/local'.

     Generally speaking, a platform is a combination of hardware and
     software families, e.g.  Sparc machines running the Solaris 2.x
     operating system are considered the same platform, but Intel
     machines running Solaris 2.x are another platform, and Intel
     machines running Linux are yet another platform.  Different major
     revisions of the same operating system generally also form
     different platforms.  Non-UNIX operating systems are a different
     story; the installation strategies on those systems are so
     different that the prefix and exec-prefix are meaningless, and set
     to the empty string.  Note that compiled Python bytecode files are
     platform independent (but not independent from the Python version
     by which they were compiled!).

     System administrators will know how to configure the `mount' or
     `automount' programs to share `/usr/local' between platforms while
     having `/usr/local/plat' be a different filesystem for each
     platform.

`char* Py_GetProgramFullPath()'
     Return the full program name of the Python executable; this is
     computed as a side-effect of deriving the default module search
     path from the program name (set by `Py_SetProgramName()'  above).
     The returned string points into static storage; the caller should
     not modify its value.  The value is available to Python code as
     `sys.executable'.

`char* Py_GetPath()'
     Return the default module search path; this is computed from the
     program name (set by `Py_SetProgramName()' above) and some
     environment variables.  The returned string consists of a series of
     directory names separated by a platform dependent delimiter
     character.  The delimiter character is `:' on UNIX, `;' on
     Windows, and `\n' (the ASCII newline character) on Macintosh.  The
     returned string points into static storage; the caller should not
     modify its value.  The value is available to Python code as the
     list `sys.path' , which may be modified to change the future
     search path for loaded modules.

`const char* Py_GetVersion()'
     Return the version of this Python interpreter.  This is a string
     that looks something like

          "1.5 (#67, Dec 31 1997, 22:34:28) [GCC 2.7.2.2]"

     The first word (up to the first space character) is the current
     Python version; the first three characters are the major and minor
     version separated by a period.  The returned string points into
     static storage; the caller should not modify its value.  The value
     is available to Python code as `sys.version'.

`const char* Py_GetPlatform()'
     Return the platform identifier for the current platform.  On UNIX,
     this is formed from the "official" name of the operating system,
     converted to lower case, followed by the major revision number;
     e.g., for Solaris 2.x, which is also known as SunOS 5.x, the value
     is `'sunos5''.  On Macintosh, it is `'mac''.  On Windows, it is
     `'win''.  The returned string points into static storage; the
     caller should not modify its value.  The value is available to
     Python code as `sys.platform'.

`const char* Py_GetCopyright()'
     Return the official copyright string for the current Python
     version, for example

     `'Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam''

     The returned string points into static storage; the caller should
     not modify its value.  The value is available to Python code as
     `sys.copyright'.

`const char* Py_GetCompiler()'
     Return an indication of the compiler used to build the current
     Python version, in square brackets, for example:

          "[GCC 2.7.2.2]"

     The returned string points into static storage; the caller should
     not modify its value.  The value is available to Python code as
     part of the variable `sys.version'.

`const char* Py_GetBuildInfo()'
     Return information about the sequence number and build date and
     time of the current Python interpreter instance, for example

          "#67, Aug  1 1997, 22:34:28"

     The returned string points into static storage; the caller should
     not modify its value.  The value is available to Python code as
     part of the variable `sys.version'.

`int PySys_SetArgv(int argc, char **argv)'
     Set `sys.argv' based on ARGC and ARGV.  These parameters are
     similar to those passed to the program's `main()'  function with
     the difference that the first entry should refer to the script
     file to be executed rather than the executable hosting the Python
     interpreter.  If there isn't a script that will be run, the first
     entry in ARGV can be an empty string.  If this function fails to
     initialize `sys.argv', a fatal condition is signalled using
     `Py_FatalError()' .

* Menu:

* Thread State and the Global Interpreter Lock::
* Profiling and Tracing::
* Advanced Debugger Support::

