This is python-dist.info, produced by makeinfo version 4.3 from
python-dist.texi.


File: python-dist.info,  Node: Creating Built Distributions,  Next: Registering with the Package Index,  Prev: Creating a Source Distribution,  Up: Top

Creating Built Distributions
****************************

A "built distribution" is what you're probably used to thinking of
either as a "binary package" or an "installer" (depending on your
background).  It's not necessarily binary, though, because it might
contain only Python source code and/or byte-code; and we don't call it a
package, because that word is already spoken for in Python.  (And
"installer" is a term specific to the Windows world.  *do Mac people
use it?*)

A built distribution is how you make life as easy as possible for
installers of your module distribution: for users of RPM-based Linux
systems, it's a binary RPM; for Windows users, it's an executable
installer; for Debian-based Linux users, it's a Debian package; and so
forth.  Obviously, no one person will be able to create built
distributions for every platform under the sun, so the Distutils are
designed to enable module developers to concentrate on their
specialty--writing code and creating source distributions--while an
intermediary species called _packagers_ springs up to turn source
distributions into built distributions for as many platforms as there
are packagers.

Of course, the module developer could be his own packager; or the
packager could be a volunteer "out there" somewhere who has access to a
platform which the original developer does not; or it could be software
periodically grabbing new source distributions and turning them into
built distributions for as many platforms as the software has access
to.  Regardless of who they are, a packager uses the setup script and
the `bdist' command family to generate built distributions.

As a simple example, if I run the following command in the Distutils
source tree:

     python setup.py bdist

then the Distutils builds my module distribution (the Distutils itself
in this case), does a "fake" installation (also in the `build'
directory), and creates the default type of built distribution for my
platform.  The default format for built distributions is a "dumb" tar
file on UNIX, and a simple executable installer on Windows.  (That tar
file is considered "dumb" because it has to be unpacked in a specific
location to work.)

Thus, the above command on a UNIX system creates
`Distutils-1.0.`PLAT'.tar.gz'; unpacking this tarball from the right
place installs the Distutils just as though you had downloaded the
source distribution and run `python setup.py install'.  (The "right
place" is either the root of the filesystem or Python's `PREFIX'
directory, depending on the options given to the `bdist_dumb' command;
the default is to make dumb distributions relative to `PREFIX'.)

Obviously, for pure Python distributions, this isn't any simpler than
just running `python setup.py install'--but for non-pure distributions,
which include extensions that would need to be compiled, it can mean
the difference between someone being able to use your extensions or
not.  And creating "smart" built distributions, such as an RPM package
or an executable installer for Windows, is far more convenient for
users even if your distribution doesn't include any extensions.

The `bdist' command has a `--formats' option, similar to the `sdist'
command, which you can use to select the types of built distribution to
generate: for example,

     python setup.py bdist --format=zip

would, when run on a UNIX system, create
`Distutils-1.0.`PLAT'.zip'--again, this archive would be unpacked from
the root directory to install the Distutils.

The available formats for built distributions are:
Format                   Description              Notes
------                   -----                    -----
gztar                    gzipped tar file         (1),(3)
                         (`.tar.gz')              
ztar                     compressed tar file      (3)
                         (`.tar.Z')               
tar                      tar file (`.tar')        (3)
zip                      zip file (`.zip')        (4)
rpm                      RPM                      (5)
pkgtool                  Solaris `pkgtool'        
sdux                     HP-UX `swinstall'        
rpm                      RPM                      (5)
wininst                  self-extracting ZIP      (2),(4)
                         file for Windows         

Notes:
`(1)'
     default on UNIX

`(2)'
     default on Windows *to-do!*

`(3)'
     requires external utilities: `tar' and possibly one of `gzip',
     `bzip2', or `compress'

`(4)'
     requires either external `zip' utility or `zipfile' module (part
     of the standard Python library since Python~1.6)

`(5)'
     requires external `rpm' utility, version 3.0.4 or better (use `rpm
     --version' to find out which version you have)

You don't have to use the `bdist' command with the `--formats' option;
you can also use the command that directly implements the format you're
interested in.  Some of these `bdist' "sub-commands" actually generate
several similar formats; for instance, the `bdist_dumb' command
generates all the "dumb" archive formats (`tar', `ztar', `gztar', and
`zip'), and `bdist_rpm' generates both binary and source RPMs.  The
`bdist' sub-commands, and the formats generated by each, are:
Command                              Formats
------                               -----
bdist_dumb                           tar, ztar, gztar, zip
bdist_rpm                            rpm, srpm
bdist_wininst                        wininst

The following sections give details on the individual `bdist_*'
commands.

* Menu:

* Creating dumb built distributions::
* Creating RPM packages::
* Creating Windows Installers::


File: python-dist.info,  Node: Creating dumb built distributions,  Next: Creating RPM packages,  Prev: Creating Built Distributions,  Up: Creating Built Distributions

Creating dumb built distributions
=================================

*Need to document absolute vs. prefix-relative packages here, but first
I have to implement it!*


File: python-dist.info,  Node: Creating RPM packages,  Next: Creating Windows Installers,  Prev: Creating dumb built distributions,  Up: Creating Built Distributions

Creating RPM packages
=====================

The RPM format is used by many popular Linux distributions, including
Red Hat, SuSE, and Mandrake.  If one of these (or any of the other
RPM-based Linux distributions) is your usual environment, creating RPM
packages for other users of that same distribution is trivial.
Depending on the complexity of your module distribution and differences
between Linux distributions, you may also be able to create RPMs that
work on different RPM-based distributions.

The usual way to create an RPM of your module distribution is to run the
`bdist_rpm' command:

     python setup.py bdist_rpm

or the `bdist' command with the `--format' option:

     python setup.py bdist --formats=rpm

The former allows you to specify RPM-specific options; the latter allows
you to easily specify multiple formats in one run.  If you need to do
both, you can explicitly specify multiple `bdist_*' commands and their
options:

     python setup.py bdist_rpm --packager="John Doe <jdoe@python.net>" \
                     bdist_wininst --target_version="2.0"

Creating RPM packages is driven by a `.spec' file, much as using the
Distutils is driven by the setup script.  To make your life easier, the
`bdist_rpm' command normally creates a `.spec' file based on the
information you supply in the setup script, on the command line, and in
any Distutils configuration files.  Various options and sections in the
`.spec' file are derived from options in the setup script as follows:
RPM `.spec' file option or section   Distutils setup script option
------                               -----
Name                                 `name'
Summary (in preamble)                `description'
Version                              `version'
Vendor                               `author' and `author_email', or \&
                                     `maintainer' and `maintainer_email'
Copyright                            `licence'
Url                                  `url'
%description (section)               `long_description'

Additionally, there many options in `.spec' files that don't have
corresponding options in the setup script.  Most of these are handled
through options to the `bdist_rpm' command as follows:
RPM `.spec' file option  `bdist_rpm' option       default value
or section                                        
------                   -----                    -----
Release                  `release'                "1"
Group                    `group'                  "Development/Libraries"
Vendor                   `vendor'                 (see above)
Packager                 `packager'               (none)
Provides                 `provides'               (none)
Requires                 `requires'               (none)
Conflicts                `conflicts'              (none)
Obsoletes                `obsoletes'              (none)
Distribution             `distribution_name'      (none)
BuildRequires            `build_requires'         (none)
Icon                     `icon'                   (none)

Obviously, supplying even a few of these options on the command-line
would be tedious and error-prone, so it's usually best to put them in
the setup configuration file, `setup.cfg'--see section~*Note Writing
the Setup Configuration File::.  If you distribute or package many
Python module distributions, you might want to put options that apply
to all of them in your personal Distutils configuration file
(`~/.pydistutils.cfg').

There are three steps to building a binary RPM package, all of which are
handled automatically by the Distutils:
  1. create a `.spec' file, which describes the package (analogous to
     the Distutils setup script; in fact, much of the information in the
     setup script winds up in the `.spec' file)

  2. create the source RPM

  3. create the "binary" RPM (which may or may not contain binary code,
     depending on whether your module distribution contains Python
     extensions)
     Normally, RPM bundles the last two steps together; when you use the
Distutils, all three steps are typically bundled together.

If you wish, you can separate these three steps.  You can use the
`--spec-only' option to make `bdist_rpm' just create the `.spec' file
and exit; in this case, the `.spec' file will be written to the
"distribution directory"--normally `dist/', but customizable with the
`--dist-dir' option.  (Normally, the `.spec' file winds up deep in the
"build tree," in a temporary directory created by `bdist_rpm'.)

*this isn't implemented yet--is it needed?!* You can also specify a
custom `.spec' file with the `--spec-file' option; used in conjunction
with `--spec-only', this gives you an opportunity to customize the
`.spec' file manually:

     > python setup.py bdist_rpm --spec-only
     # ...edit dist/FooBar-1.0.spec
     > python setup.py bdist_rpm --spec-file=dist/FooBar-1.0.spec

(Although a better way to do this is probably to override the standard
`bdist_rpm' command with one that writes whatever else you want to the
`.spec' file.)


File: python-dist.info,  Node: Creating Windows Installers,  Prev: Creating RPM packages,  Up: Creating Built Distributions

Creating Windows Installers
===========================

Executable installers are the natural format for binary distributions
on Windows.  They display a nice graphical user interface, display some
information about the module distribution to be installed taken from
the metadata in the setup script, let the user select a few options,
and start or cancel the installation.

Since the metadata is taken from the setup script, creating Windows
installers is usually as easy as running:

     python setup.py bdist_wininst

or the `bdist' command with the `--formats' option:

     python setup.py bdist --formats=wininst

If you have a pure module distribution (only containing pure Python
modules and packages), the resulting installer will be version
independent and have a name like `foo-1.0.win32.exe'.  These installers
can even be created on UNIX or MacOS platforms.

If you have a non-pure distribution, the extensions can only be created
on a Windows platform, and will be Python version dependent.  The
installer filename will reflect this and now has the form
`foo-1.0.win32-py2.0.exe'.  You have to create a separate installer for
every Python version you want to support.

The installer will try to compile pure modules into bytecode after
installation on the target system in normal and optimizing mode.  If
you don't want this to happen for some reason, you can run the
`bdist_wininst' command with the `--no-target-compile' and/or the
`--no-target-optimize' option.

By default the installer will display the cool "Python Powered" logo
when it is run, but you can also supply your own bitmap which must be a
Windows `.bmp' file with the `--bitmap' option.

The installer will also display a large title on the desktop background
window when it is run, which is constructed from the name of your
distribution and the version number.  This can be changed to another
text by using the `--title' option.

The installer file will be written to the "distribution directory" --
normally `dist/', but customizable with the `--dist-dir' option.

* Menu:

* Postinstallation script::


File: python-dist.info,  Node: Postinstallation script,  Prev: Creating Windows Installers,  Up: Creating Windows Installers

The Postinstallation script
---------------------------

Starting with Python 2.3, a postinstallation script can be specified
which the `--install-script' option.  The basename of the script must
be specified, and the script filename must also be listed in the
scripts argument to the setup function.

This script will be run at installation time on the target system after
all the files have been copied, with argv[1] set to '-install', and
again at uninstallation time before the files are removed with argv[1]
set to '-remove'.

The installation script runs embedded in the windows installer, every
output (sys.stdout, sys.stderr) is redirected into a buffer and will be
displayed in the GUI after the script has finished.

Some functions especially useful in this context are available in the
installation script.

     dir_created(pathname)
     file_created(pathname)

These functions should be called when a directory or file is created by
the postinstall script at installation time.  It will register the
pathname with the uninstaller, so that it will be removed when the
distribution is uninstalled.  To be safe, directories are only removed
if they are empty.

     get_special_folder_path(csidl_string)

This function can be used to retrieve special folder locations on
Windows like the Start Menu or the Desktop.  It returns the full path
to the folder.  'csidl_string' must be one of the following strings:

     "CSIDL_APPDATA"
     
     "CSIDL_COMMON_STARTMENU"
     "CSIDL_STARTMENU"
     
     "CSIDL_COMMON_DESKTOPDIRECTORY"
     "CSIDL_DESKTOPDIRECTORY"
     
     "CSIDL_COMMON_STARTUP"
     "CSIDL_STARTUP"
     
     "CSIDL_COMMON_PROGRAMS"
     "CSIDL_PROGRAMS"
     
     "CSIDL_FONTS"

If the folder cannot be retrieved, OSError is raised.

Which folders are available depends on the exact Windows version, and
probably also the configuration. For details refer to Microsoft's
documentation of the `SHGetSpecialFolderPath' function.

     create_shortcut(target, description, filename[, arguments[,
                     workdir[, iconpath[, iconindex]]]])

This function creates a shortcut.  TARGET is the path to the program to
be started by the shortcut.  DESCRIPTION is the description of the
sortcut.  FILENAME is the title of the shortcut that the user will see.
ARGUMENTS specifies the command line arguments, if any.  WORKDIR is the
working directory for the program.  ICONPATH is the file containing the
icon for the shortcut, and ICONINDEX is the index of the icon in the
file ICONPATH.  Again, for details consult the Microsoft documentation
for the `IShellLink' interface.


File: python-dist.info,  Node: Registering with the Package Index,  Next: Examples,  Prev: Creating Built Distributions,  Up: Top

Registering with the Package Index
**********************************

The Python Package Index (PyPI) holds meta-data describing distributions
packaged with distutils. The distutils command `register' is used to
submit your distribution's meta-data to the index. It is invoked as
follows:

     python setup.py register

Distutils will respond with the following prompt:

     running register
     We need to know who you are, so please choose either:
      1. use your existing login,
      2. register as a new user,
      3. have the server generate a new password for you (and email it to you), or
      4. quit
     Your selection [default 1]:

Note: if your username and password are saved locally, you will not see
this menu.

If you have not registered with PyPI, then you will need to do so now.
You should choose option 2, and enter your details as required. Soon
after submitting your details, you will receive an email which will be
used to confirm your registration.

Once you are registered, you may choose option 1 from the menu. You will
be prompted for your PyPI username and password, and `register' will
then submit your meta-data to the index.

You may submit any number of versions of your distribution to the
index. If you alter the meta-data for a particular version, you may
submit it again and the index will be updated.

PyPI holds a record for each (name, version) combination submitted. The
first user to submit information for a given name is designated the
Owner of that name. They may submit changes through the `register'
command or through the web interface. They may also designate other
users as Owners or Maintainers. Maintainers may edit the package
information, but not designate other Owners or Maintainers.

By default PyPI will list all versions of a given package. To hide
certain versions, the Hidden property should be set to yes. This must
be edited through the web interface.


File: python-dist.info,  Node: Examples,  Next: Reference,  Prev: Registering with the Package Index,  Up: Top

Examples
********

* Menu:

* Pure Python distribution by module::
* Pure Python distribution by package::
* Single extension module::


File: python-dist.info,  Node: Pure Python distribution by module,  Next: Pure Python distribution by package,  Prev: Examples,  Up: Examples

Pure Python distribution (by module)
====================================

If you're just distributing a couple of modules, especially if they
don't live in a particular package, you can specify them individually
using the `py_modules' option in the setup script.

In the simplest case, you'll have two files to worry about: a setup
script and the single module you're distributing, `foo.py' in this
example:
     <root>/
             setup.py
             foo.py

(In all diagrams in this section, `<root>' will refer to the
distribution root directory.)  A minimal setup script to describe this
situation would be:
     from distutils.core import setup
     setup(name = "foo", version = "1.0",
           py_modules = ["foo"])

Note that the name of the distribution is specified independently with
the `name' option, and there's no rule that says it has to be the same
as the name of the sole module in the distribution (although that's
probably a good convention to follow).  However, the distribution name
is used to generate filenames, so you should stick to letters, digits,
underscores, and hyphens.

Since `py_modules' is a list, you can of course specify multiple
modules, eg. if you're distributing modules `foo' and `bar', your setup
might look like this:
     <root>/
             setup.py
             foo.py
             bar.py

and the setup script might be
     from distutils.core import setup
     setup(name = "foobar", version = "1.0",
           py_modules = ["foo", "bar"])

You can put module source files into another directory, but if you have
enough modules to do that, it's probably easier to specify modules by
package rather than listing them individually.


File: python-dist.info,  Node: Pure Python distribution by package,  Next: Single extension module,  Prev: Pure Python distribution by module,  Up: Examples

Pure Python distribution (by package)
=====================================

If you have more than a couple of modules to distribute, especially if
they are in multiple packages, it's probably easier to specify whole
packages rather than individual modules.  This works even if your
modules are not in a package; you can just tell the Distutils to process
modules from the root package, and that works the same as any other
package (except that you don't have to have an `__init__.py' file).

The setup script from the last example could also be written as
     from distutils.core import setup
     setup(name = "foobar", version = "1.0",
           packages = [""])

(The empty string stands for the root package.)

If those two files are moved into a subdirectory, but remain in the root
package, e.g.:
     <root>/
             setup.py
             src/      foo.py
                       bar.py

then you would still specify the root package, but you have to tell the
Distutils where source files in the root package live:
     from distutils.core import setup
     setup(name = "foobar", version = "1.0",
           package_dir = {"": "src"},
           packages = [""])

More typically, though, you will want to distribute multiple modules in
the same package (or in sub-packages).  For example, if the `foo' and
`bar' modules belong in package `foobar', one way to layout your source
tree is
     <root>/
             setup.py
             foobar/
                      __init__.py
                      foo.py
                      bar.py

This is in fact the default layout expected by the Distutils, and the
one that requires the least work to describe in your setup script:
     from distutils.core import setup
     setup(name = "foobar", version = "1.0",
           packages = ["foobar"])

If you want to put modules in directories not named for their package,
then you need to use the `package_dir' option again.  For example, if
the `src' directory holds modules in the `foobar' package:
     <root>/
             setup.py
             src/
                      __init__.py
                      foo.py
                      bar.py

an appropriate setup script would be
     from distutils.core import setup
     setup(name = "foobar", version = "1.0",
           package_dir = {"foobar" : "src"},
           packages = ["foobar"])

Or, you might put modules from your main package right in the
distribution root:
     <root>/
             setup.py
             __init__.py
             foo.py
             bar.py

in which case your setup script would be
     from distutils.core import setup
     setup(name = "foobar", version = "1.0",
           package_dir = {"foobar" : ""},
           packages = ["foobar"])

(The empty string also stands for the current directory.)

If you have sub-packages, they must be explicitly listed in `packages',
but any entries in `package_dir' automatically extend to sub-packages.
(In other words, the Distutils does _not_ scan your source tree, trying
to figure out which directories correspond to Python packages by
looking for `__init__.py' files.)  Thus, if the default layout grows a
sub-package:
     <root>/
             setup.py
             foobar/
                      __init__.py
                      foo.py
                      bar.py
                      subfoo/
                                __init__.py
                                blah.py

then the corresponding setup script would be
     from distutils.core import setup
     setup(name = "foobar", version = "1.0",
           packages = ["foobar", "foobar.subfoo"])

(Again, the empty string in `package_dir' stands for the current
directory.)


File: python-dist.info,  Node: Single extension module,  Prev: Pure Python distribution by package,  Up: Examples

Single extension module
=======================

Extension modules are specified using the `ext_modules' option.
`package_dir' has no effect on where extension source files are found;
it only affects the source for pure Python modules.  The simplest case,
a single extension module in a single C source file, is:
     <root>/
             setup.py
             foo.c

If the `foo' extension belongs in the root package, the setup script
for this could be
     from distutils.core import setup
     setup(name = "foobar", version = "1.0",
           ext_modules = [Extension("foo", ["foo.c"])])

If the extension actually belongs in a package, say `foopkg', then

With exactly the same source tree layout, this extension can be put in
the `foopkg' package simply by changing the name of the extension:
     from distutils.core import setup
     setup(name = "foobar", version = "1.0",
           ext_modules = [Extension("foopkg.foo", ["foo.c"])])


File: python-dist.info,  Node: Reference,  Next: distutilssysconfig,  Prev: Examples,  Up: Top

Reference
*********

* Menu:

* Installing modules the install command family::
* Creating a source distribution the sdist command::


File: python-dist.info,  Node: Installing modules the install command family,  Next: Creating a source distribution the sdist command,  Prev: Reference,  Up: Reference

Installing modules: the `install' command family
================================================

The install command ensures that the build commands have been run and
then runs the subcommands `install_lib', `install_data' and
`install_scripts'.

* Menu:

* install_data::
* install_scripts::


File: python-dist.info,  Node: install_data,  Next: install_scripts,  Prev: Installing modules the install command family,  Up: Installing modules the install command family

`install_data'
--------------

This command installs all data files provided with the distribution.


File: python-dist.info,  Node: install_scripts,  Prev: install_data,  Up: Installing modules the install command family

`install_scripts'
-----------------

This command installs all (Python) scripts in the distribution.


File: python-dist.info,  Node: Creating a source distribution the sdist command,  Prev: Installing modules the install command family,  Up: Reference

Creating a source distribution: the `sdist' command
===================================================

*fragment moved down from above: needs context!*

The manifest template commands are:
Command                              Description
------                               -----
include PAT1 PAT2 ...                include all files matching any of
                                     the listed patterns
exclude PAT1 PAT2 ...                exclude all files matching any of
                                     the listed patterns
recursive-include DIR PAT1 PAT2 ...  include all files under DIR
                                     matching any of the listed patterns
recursive-exclude DIR PAT1 PAT2 ...  exclude all files under DIR
                                     matching any of the listed patterns
global-include PAT1 PAT2 ...         include all files anywhere in the
                                     source tree matching\& any of the
                                     listed patterns
global-exclude PAT1 PAT2 ...         exclude all files anywhere in the
                                     source tree matching\& any of the
                                     listed patterns
prune DIR                            exclude all files under DIR
graft DIR                            include all files under DIR

The patterns here are UNIX-style "glob" patterns: `*' matches any
sequence of regular filename characters, `?' matches any single regular
filename character, and `[RANGE]' matches any of the characters in
RANGE (e.g., `a-z', `a-zA-Z', `a-f0-9_.').  The definition of "regular
filename character" is platform-specific: on UNIX it is anything except
slash; on Windows anything except backslash or colon; on MacOS anything
except colon.

*Windows and MacOS support not there yet*


File: python-dist.info,  Node: distutilssysconfig,  Next: Function-Method-Variable Index,  Prev: Reference,  Up: Top

System configuration information
********************************

Low-level access to configuration information of the Python interpreter.

The `distutils.sysconfig' module provides access to Python's low-level
configuration information.  The specific configuration variables
available depend heavily on the platform and configuration.  The
specific variables depend on the build process for the specific version
of Python being run; the variables are those found in the `Makefile'
and configuration header that are installed with Python on UNIX
systems.  The configuration header is called `pyconfig.h' for Python
versions starting with 2.2, and `config.h' for earlier versions of
Python.

Some additional functions are provided which perform some useful
manipulations for other parts of the `distutils' package.

`PREFIX'
     The result of `os.path.normpath(sys.prefix)'.

`EXEC_PREFIX'
     The result of `os.path.normpath(sys.exec_prefix)'.

`get_config_var(name)'
     Return the value of a single variable.  This is equivalent to
     `get_config_vars().get(NAME)'.

`get_config_vars(...)'
     Return a set of variable definitions.  If there are no arguments,
     this returns a dictionary mapping names of configuration variables
     to values.  If arguments are provided, they should be strings, and
     the return value will be a sequence giving the associated values.
     If a given name does not have a corresponding value, `None' will
     be included for that variable.

`get_config_h_filename()'
     Return the full path name of the configuration header.  For UNIX,
     this will be the header generated by the `configure' script; for
     other platforms the header will have been supplied directly by the
     Python source distribution.  The file is a platform-specific text
     file.

`get_makefile_filename()'
     Return the full path name of the `Makefile' used to build Python.
     For UNIX, this will be a file generated by the `configure' script;
     the meaning for other platforms will vary.  The file is a
     platform-specific text file, if it exists.  This function is only
     useful on POSIX platforms.

`get_python_inc([plat_specific[, prefix]])'
     Return the directory for either the general or platform-dependent C
     include files.  If PLAT_SPECIFIC is true, the platform-dependent
     include directory is returned; if false or omitted, the
     platform-independent directory is returned.  If PREFIX is given,
     it is used as either the prefix instead of `PREFIX', or as the
     exec-prefix instead of `EXEC_PREFIX' if PLAT_SPECIFIC is true.

`get_python_lib([plat_specific[, standard_lib[, prefix]]])'
     Return the directory for either the general or platform-dependent
     library installation.  If PLAT_SPECIFIC is true, the
     platform-dependent include directory is returned; if false or
     omitted, the platform-independent directory is returned.  If
     PREFIX is given, it is used as either the prefix instead of
     `PREFIX', or as the exec-prefix instead of `EXEC_PREFIX' if
     PLAT_SPECIFIC is true.  If STANDARD_LIB is true, the directory for
     the standard library is returned rather than the directory for the
     installation of third-party extensions.

The following function is only intended for use within the `distutils'
package.

`customize_compiler(compiler)'
     Do any platform-specific customization of a
     `distutils.ccompiler.CCompiler' instance.

     This function is only needed on UNIX at this time, but should be
     called consistently to support forward-compatibility.  It inserts
     the information that varies across UNIX flavors and is stored in
     Python's `Makefile'.  This information includes the selected
     compiler, compiler and linker options, and the extension used by
     the linker for shared objects.

This function is even more special-purpose, and should only be used
from Python's own build procedures.

`set_python_build()'
     Inform the `distutils.sysconfig' module that it is being used as
     part of the build process for Python.  This changes a lot of
     relative locations for files, allowing them to be located in the
     build area rather than in an installed Python.


File: python-dist.info,  Node: Function-Method-Variable Index,  Next: Miscellaneous Index,  Prev: distutilssysconfig,  Up: Top

Function, Method, and Variable Index
************************************

* Menu:

* customize_compiler:                    distutilssysconfig.
* EXEC_PREFIX:                           distutilssysconfig.
* get_config_h_filename:                 distutilssysconfig.
* get_config_var:                        distutilssysconfig.
* get_config_vars:                       distutilssysconfig.
* get_makefile_filename:                 distutilssysconfig.
* get_python_inc:                        distutilssysconfig.
* get_python_lib:                        distutilssysconfig.
* PREFIX:                                distutilssysconfig.
* set_python_build:                      distutilssysconfig.


File: python-dist.info,  Node: Miscellaneous Index,  Prev: Function-Method-Variable Index,  Up: Top

Miscellaneous Index
*******************

* Menu:

* distutils.sysconfig:                   distutilssysconfig.


