This is python-lib.info, produced by makeinfo version 4.3 from
python-lib.texi.

October 3, 2003


File: python-lib.info,  Node: datetime,  Next: time,  Prev: popen2,  Up: Generic Operating System Services

Basic date and time types
=========================

Basic date and time types.

_Added in Python version 2.3_

The `datetime' module supplies classes for manipulating dates and times
in both simple and complex ways.  While date and time arithmetic is
supported, the focus of the implementation is on efficient member
extraction for output formatting and manipulation.

There are two kinds of date and time objects: "naive" and "aware".
This distinction refers to whether the object has any notion of time
zone, daylight saving time, or other kind of algorithmic or political
time adjustment.  Whether a naive `datetime' object represents
Coordinated Universal Time (UTC), local time, or time in some other
timezone is purely up to the program, just like it's up to the program
whether a particular number represents meters, miles, or mass.  Naive
`datetime' objects are easy to understand and to work with, at the cost
of ignoring some aspects of reality.

For applications requiring more, `datetime' and `time' objects have an
optional time zone information member, `tzinfo', that can contain an
instance of a subclass of the abstract `tzinfo' class.  These `tzinfo'
objects capture information about the offset from UTC time, the time
zone name, and whether Daylight Saving Time is in effect.  Note that no
concrete `tzinfo' classes are supplied by the `datetime' module.
Supporting timezones at whatever level of detail is required is up to
the application.  The rules for time adjustment across the world are
more political than rational, and there is no standard suitable for
every application.

The `datetime' module exports the following constants:

`MINYEAR'
     The smallest year number allowed in a `date' or `datetime' object.
     `MINYEAR' is `1'.

`MAXYEAR'
     The largest year number allowed in a `date' or `datetime' object.
     `MAXYEAR' is `9999'.

See also:
     *Note calendar:: General calendar related functions.  *Note time::
     Time access and conversions.

* Menu:

* Available Types::
* timedelta Objects::
* date Objects::
* datetime Objects::
* time Objects::
* tzinfo Objects::
* strftime Behavior::


File: python-lib.info,  Node: Available Types,  Next: timedelta Objects,  Prev: datetime,  Up: datetime

Available Types
---------------

`date'
     An idealized naive date, assuming the current Gregorian calendar
     always was, and always will be, in effect.  Attributes: `year',
     `month', and `day'.

`time'
     An idealized time, independent of any particular day, assuming
     that every day has exactly 24*60*60 seconds (there is no notion of
     "leap seconds" here).  Attributes: `hour', `minute', `second',
     `microsecond', and `tzinfo'.

`datetime'
     A combination of a date and a time.  Attributes: `year', `month',
     `day', `hour', `minute', `second', `microsecond', and `tzinfo'.

`timedelta'
     A duration expressing the difference between two `date', `time',
     or `datetime' instances to microsecond resolution.

`tzinfo'
     An abstract base class for time zone information objects.  These
     are used by the  `datetime' and `time' classes to provide a
     customizable notion of time adjustment (for example, to account
     for time zone and/or daylight saving time).

Objects of these types are immutable.

Objects of the `date' type are always naive.

An object D of type `time' or `datetime' may be naive or aware.  D is
aware if `D.tzinfo' is not `None' and `D.tzinfo.utcoffset(D)' does not
return `None'.  If `D.tzinfo' is `None', or if `D.tzinfo' is not `None'
but `D.tzinfo.utcoffset(D)' returns `None', D is naive.

The distinction between naive and aware doesn't apply to `timedelta'
objects.

Subclass relationships:

     object
         timedelta
         tzinfo
         time
         date
             datetime


File: python-lib.info,  Node: timedelta Objects,  Next: date Objects,  Prev: Available Types,  Up: datetime

`timedelta' Objects
-------------------

A `timedelta' object represents a duration, the difference between two
dates or times.

`timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)'
     All arguments are optional.  Arguments may be ints, longs, or
     floats, and may be positive or negative.

     Only DAYS, SECONDS and MICROSECONDS are stored internally.
     Arguments are converted to those units:

        * A millisecond is converted to 1000 microseconds.

        * A minute is converted to 60 seconds.

        * An hour is converted to 3600 seconds.

        * A week is converted to 7 days.

     and days, seconds and microseconds are then normalized so that the
     representation is unique, with

        * `0 <= MICROSECONDS < 1000000'

        * `0 <= SECONDS < 3600*24' (the number of seconds in one day)

        * `-999999999 <= DAYS <= 999999999'

     If any argument is a float and there are fractional microseconds,
     the fractional microseconds left over from all arguments are
     combined and their sum is rounded to the nearest microsecond.  If
     no argument is a float, the conversion and normalization processes
     are exact (no information is lost).

     If the normalized value of days lies outside the indicated range,
     `OverflowError' is raised.

     Note that normalization of negative values may be surprising at
     first.  For example,

          >>> d = timedelta(microseconds=-1)
          >>> (d.days, d.seconds, d.microseconds)
          (-1, 86399, 999999)

Class attributes are:

`min'
     The most negative `timedelta' object, `timedelta(-999999999)'.

`max'
     The most positive `timedelta' object, `timedelta(days=999999999,
     hours=23, minutes=59, seconds=59, microseconds=999999)'.

`resolution'
     The smallest possible difference between non-equal `timedelta'
     objects, `timedelta(microseconds=1)'.

Note that, because of normalization, `timedelta.max' >
`-timedelta.min'.  `-timedelta.max' is not representable as a
`timedelta' object.

Instance attributes (read-only):

Attribute                            Value
------                               -----
days                                 Between -999999999 and 999999999
                                     inclusive
seconds                              Between 0 and 86399 inclusive
microseconds                         Between 0 and 999999 inclusive

Supported operations:

Operation                            Result
------                               -----
T1 = T2 + T3                         Sum of T2 and T3. Afterwards T1-T2
                                     == T3 and T1-T3 == T2 are true. (1)
T1 = T2 - T3                         Difference of T2 and T3. Afterwards
                                     T1 == T2 - T3 and T2 == T1 + T3 are
                                     true. (1)
T1 = T2 * I or T1 = I * T2           Delta multiplied by an integer or
                                     long. Afterwards T1 // i == T2 is
                                     true, provided `i != 0'.
                                     In general, T1 * i == T1 * (i-1) +
                                     T1 is true. (1)
T1 = T2 // I                         The floor is computed and the
                                     remainder (if any) is thrown away.
                                     (3)
+T1                                  Returns a `timedelta' object with
                                     the same value. (2)
-T1                                  equivalent to `timedelta'(-T1.DAYS,
                                     -T1.SECONDS, -T1.MICROSECONDS), and
                                     to T1* -1. (1)(4)
abs(T)                               equivalent to +T when `t.days >=
                                     0', and to -T when `t.days < 0'. (2)

Notes:

`(1)'
     This is exact, but may overflow.

`(2)'
     This is exact, and cannot overflow.

`(3)'
     Division by 0 raises `ZeroDivisionError'.

`(4)'
     -TIMEDELTA.MAX is not representable as a `timedelta' object.

In addition to the operations listed above `timedelta' objects support
certain additions and subtractions with `date' and `datetime' objects
(see below).

Comparisons of `timedelta' objects are supported with the `timedelta'
object representing the smaller duration considered to be the smaller
timedelta.  In order to stop mixed-type comparisons from falling back
to the default comparison by object address, when a `timedelta' object
is compared to an object of a different type, `TypeError' is raised
unless the comparison is `==' or `!='.  The latter cases return `False'
or `True', respectively.

`timedelta' objects are hashable (usable as dictionary keys), support
efficient pickling, and in Boolean contexts, a `timedelta' object is
considered to be true if and only if it isn't equal to `timedelta(0)'.


File: python-lib.info,  Node: date Objects,  Next: datetime Objects,  Prev: timedelta Objects,  Up: datetime

`date' Objects
--------------

A `date' object represents a date (year, month and day) in an idealized
calendar, the current Gregorian calendar indefinitely extended in both
directions.  January 1 of year 1 is called day number 1, January 2 of
year 1 is called day number 2, and so on.  This matches the definition
of the "proleptic Gregorian" calendar in Dershowitz and Reingold's book
, where it's the base calendar for all computations.  See the book for
algorithms for converting between proleptic Gregorian ordinals and many
other calendar systems.

`date(year, month, day)'
     All arguments are required.  Arguments may be ints or longs, in the
     following ranges:

        * `MINYEAR <= YEAR <= MAXYEAR'

        * `1 <= MONTH <= 12'

        * `1 <= DAY <= number of days in the given month and year'

     If an argument outside those ranges is given, `ValueError' is
     raised.

Other constructors, all class methods:

`today()'
     Return the current local date.  This is equivalent to
     `date.fromtimestamp(time.time())'.

`fromtimestamp(timestamp)'
     Return the local date corresponding to the POSIX timestamp, such
     as is returned by `time.time()'.  This may raise `ValueError', if
     the timestamp is out of the range of values supported by the
     platform C `localtime()' function.  It's common for this to be
     restricted to years from 1970 through 2038.  Note that on
     non-POSIX systems that include leap seconds in their notion of a
     timestamp, leap seconds are ignored by `fromtimestamp()'.

`fromordinal(ordinal)'
     Return the date corresponding to the proleptic Gregorian ordinal,
     where January 1 of year 1 has ordinal 1.  `ValueError' is raised
     unless `1 <= ORDINAL <= date.max.toordinal()'.  For any date D,
     `date.fromordinal(D.toordinal()) == D'.

Class attributes:

`min'
     The earliest representable date, `date(MINYEAR, 1, 1)'.

`max'
     The latest representable date, `date(MAXYEAR, 12, 31)'.

`resolution'
     The smallest possible difference between non-equal date objects,
     `timedelta(days=1)'.

Instance attributes (read-only):

`year'
     Between `MINYEAR' and `MAXYEAR' inclusive.

`month'
     Between 1 and 12 inclusive.

`day'
     Between 1 and the number of days in the given month of the given
     year.

Supported operations:

Operation                            Result
------                               -----
DATE2 = DATE1 + TIMEDELTA            DATE2 is `TIMEDELTA.days' days
                                     removed from DATE1.  (1)
DATE2 = DATE1 - TIMEDELTA            Computes DATE2 such that `DATE2 +
                                     TIMEDELTA == DATE1'. (2)
TIMEDELTA = DATE1 - DATE2            (3)
DATE1<DATE2                          DATE1 is considered less than DATE2
                                     when DATE1 precedes DATE2 in time.
                                     (4)

Notes:
`(1)'
     DATE2 is moved forward in time if `TIMEDELTA.days > 0', or
     backward if `TIMEDELTA.days < 0'.  Afterward `DATE2 - DATE1 ==
     TIMEDELTA.days'.  `TIMEDELTA.seconds' and `TIMEDELTA.microseconds'
     are ignored.  `OverflowError' is raised if `DATE2.year' would be
     smaller than `MINYEAR' or larger than `MAXYEAR'.

`(2)'
     This isn't quite equivalent to date1 + (-timedelta), because
     -timedelta in isolation can overflow in cases where date1 -
     timedelta does not.  `TIMEDELTA.seconds' and
     `TIMEDELTA.microseconds' are ignored.

`(3)'
     This is exact, and cannot overflow.  timedelta.seconds and
     timedelta.microseconds are 0, and date2 + timedelta == date1 after.

`(4)'
     In other words, `date1 < date2' if and only if `DATE1.toordinal()
     < DATE2.toordinal()'.  In order to stop comparison from falling
     back to the default scheme of comparing object addresses, date
     comparison normally raises `TypeError' if the other comparand
     isn't also a `date' object.  However, `NotImplemented' is returned
     instead if the other comparand has a `timetuple' attribute.  This
     hook gives other kinds of date objects a chance at implementing
     mixed-type comparison.  If not, when a `date' object is compared
     to an object of a different type, `TypeError' is raised unless the
     comparison is `==' or `!='.  The latter cases return `False' or
     `True', respectively.

Dates can be used as dictionary keys. In Boolean contexts, all `date'
objects are considered to be true.

Instance methods:

`replace(year, month, day)'
     Return a date with the same value, except for those members given
     new values by whichever keyword arguments are specified.  For
     example, if `d == date(2002, 12, 31)', then `d.replace(day=26) ==
     date(2000, 12, 26)'.

`timetuple()'
     Return a `time.struct_time' such as returned by
     `time.localtime()'.  The hours, minutes and seconds are 0, and the
     DST flag is -1.  `D.timetuple()' is equivalent to
     `time.struct_time((D.year, D.month, D.day, 0, 0, 0,  D.weekday(),
     D.toordinal() - date(D.year, 1, 1).toordinal() + 1, -1))'

`toordinal()'
     Return the proleptic Gregorian ordinal of the date, where January 1
     of year 1 has ordinal 1.  For any `date' object D,
     `date.fromordinal(D.toordinal()) == D'.

`weekday()'
     Return the day of the week as an integer, where Monday is 0 and
     Sunday is 6.  For example, `date(2002, 12, 4).weekday() == 2', a
     Wednesday.  See also `isoweekday()'.

`isoweekday()'
     Return the day of the week as an integer, where Monday is 1 and
     Sunday is 7.  For example, `date(2002, 12, 4).isoweekday() == 3', a
     Wednesday.  See also `weekday()', `isocalendar()'.

`isocalendar()'
     Return a 3-tuple, (ISO year, ISO week number, ISO weekday).

     The ISO calendar is a widely used variant of the Gregorian
     calendar.  See
     <http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm> for a good
     explanation.

     The ISO year consists of 52 or 53 full weeks, and where a week
     starts on a Monday and ends on a Sunday.  The first week of an ISO
     year is the first (Gregorian) calendar week of a year containing a
     Thursday.  This is called week number 1, and the ISO year of that
     Thursday is the same as its Gregorian year.

     For example, 2004 begins on a Thursday, so the first week of ISO
     year 2004 begins on Monday, 29 Dec 2003 and ends on Sunday, 4 Jan
     2004, so that `date(2003, 12, 29).isocalendar() == (2004, 1, 1)'
     and `date(2004, 1, 4).isocalendar() == (2004, 1, 7)'.

`isoformat()'
     Return a string representing the date in ISO 8601 format,
     'YYYY-MM-DD'.  For example, `date(2002, 12, 4).isoformat() ==
     '2002-12-04''.

`__str__()'
     For a date D, `str(D)' is equivalent to `D.isoformat()'.

`ctime()'
     Return a string representing the date, for example date(2002, 12,
     4).ctime() == 'Wed Dec  4 00:00:00 2002'.  `D.ctime()' is
     equivalent to `time.ctime(time.mktime(D.timetuple()))' on
     platforms where the native C `ctime()' function (which
     `time.ctime()' invokes, but which `date.ctime()' does not invoke)
     conforms to the C standard.

`strftime(format)'
     Return a string representing the date, controlled by an explicit
     format string.  Format codes referring to hours, minutes or seconds
     will see 0 values.  See the section on `strftime()' behavior.


File: python-lib.info,  Node: datetime Objects,  Next: time Objects,  Prev: date Objects,  Up: datetime

`datetime' Objects
------------------

A `datetime' object is a single object containing all the information
from a `date' object and a `time' object.  Like a `date' object,
`datetime' assumes the current Gregorian calendar extended in both
directions; like a time object, `datetime' assumes there are exactly
3600*24 seconds in every day.

Constructor:

`datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None)'
     The year, month and day arguments are required.  TZINFO may be
     `None', or an instance of a `tzinfo' subclass.  The remaining
     arguments may be ints or longs, in the following ranges:

        * `MINYEAR <= YEAR <= MAXYEAR'

        * `1 <= MONTH <= 12'

        * `1 <= DAY <= number of days in the given month and year'

        * `0 <= HOUR < 24'

        * `0 <= MINUTE < 60'

        * `0 <= SECOND < 60'

        * `0 <= MICROSECOND < 1000000'

     If an argument outside those ranges is given, `ValueError' is
     raised.

Other constructors, all class methods:

`today()'
     Return the current local datetime, with `tzinfo' `None'.  This is
     equivalent to `datetime.fromtimestamp(time.time())'.  See also
     `now()', `fromtimestamp()'.

`now(tz=None)()'
     Return the current local date and time.  If optional argument TZ
     is `None' or not specified, this is like `today()', but, if
     possible, supplies more precision than can be gotten from going
     through a `time.time()' timestamp (for example, this may be
     possible on platforms supplying the C `gettimeofday()' function).

     Else TZ must be an instance of a class `tzinfo' subclass, and the
     current date and time are converted to TZ's time zone.  In this
     case the result is equivalent to
     `TZ.fromutc(datetime.utcnow().replace(tzinfo=TZ))'.  See also
     `today()', `utcnow()'.

`utcnow()'
     Return the current UTC date and time, with `tzinfo' `None'.  This
     is like `now()', but returns the current UTC date and time, as a
     naive `datetime' object.  See also `now()'.

`fromtimestamp(timestamp, tz=None)'
     Return the local date and time corresponding to the POSIX
     timestamp, such as is returned by `time.time()'.  If optional
     argument TZ is `None' or not specified, the timestamp is converted
     to the platform's local date and time, and the returned `datetime'
     object is naive.

     Else TZ must be an instance of a class `tzinfo' subclass, and the
     timestamp is converted to TZ's time zone.  In this case the result
     is equivalent to
     `TZ.fromutc(datetime.utcfromtimestamp(TIMESTAMP).replace(tzinfo=TZ))'.

     `fromtimestamp()' may raise `ValueError', if the timestamp is out
     of the range of values supported by the platform C `localtime()'
     or `gmtime()' functions.  It's common for this to be restricted to
     years in 1970 through 2038.  Note that on non-POSIX systems that
     include leap seconds in their notion of a timestamp, leap seconds
     are ignored by `fromtimestamp()', and then it's possible to have
     two timestamps differing by a second that yield identical
     `datetime' objects.  See also `utcfromtimestamp()'.

`utcfromtimestamp(timestamp)'
     Return the UTC `datetime' corresponding to the POSIX timestamp,
     with `tzinfo' `None'.  This may raise `ValueError', if the
     timestamp is out of the range of values supported by the platform
     C `gmtime()' function.  It's common for this to be restricted to
     years in 1970 through 2038.  See also `fromtimestamp()'.

`fromordinal(ordinal)'
     Return the `datetime' corresponding to the proleptic Gregorian
     ordinal, where January 1 of year 1 has ordinal 1.  `ValueError' is
     raised unless `1 <= ordinal <= datetime.max.toordinal()'.  The
     hour, minute, second and microsecond of the result are all 0, and
     `tzinfo' is `None'.

`combine(date, time)'
     Return a new `datetime' object whose date members are equal to the
     given `date' object's, and whose time and `tzinfo' members are
     equal to the given `time' object's.  For any `datetime' object D,
     `D == datetime.combine(D.date(), D.timetz())'.  If date is a
     `datetime' object, its time and `tzinfo' members are ignored.

Class attributes:

`min'
     The earliest representable `datetime', `datetime(MINYEAR, 1, 1,
     tzinfo=None)'.

`max'
     The latest representable `datetime', `datetime(MAXYEAR, 12, 31,
     23, 59, 59, 999999, tzinfo=None)'.

`resolution'
     The smallest possible difference between non-equal `datetime'
     objects, `timedelta(microseconds=1)'.

Instance attributes (read-only):

`year'
     Between `MINYEAR' and `MAXYEAR' inclusive.

`month'
     Between 1 and 12 inclusive.

`day'
     Between 1 and the number of days in the given month of the given
     year.

`hour'
     In `range(24)'.

`minute'
     In `range(60)'.

`second'
     In `range(60)'.

`microsecond'
     In `range(1000000)'.

`tzinfo'
     The object passed as the TZINFO argument to the `datetime'
     constructor, or `None' if none was passed.

Supported operations:

Operation                            Result
------                               -----
DATETIME2 = DATETIME1 + TIMEDELTA    (1)
DATETIME2 = DATETIME1 - TIMEDELTA    (2)
TIMEDELTA = DATETIME1 - DATETIME2    (3)
DATETIME1 < DATETIME2                Compares `datetime' to `datetime'.
                                     (4)

`(1)'
     datetime2 is a duration of timedelta removed from datetime1, moving
     forward in time if `TIMEDELTA.days' > 0, or backward if
     `TIMEDELTA.days' < 0.  The result has the same `tzinfo' member as
     the input datetime, and datetime2 - datetime1 == timedelta after.
     `OverflowError' is raised if datetime2.year would be smaller than
     `MINYEAR' or larger than `MAXYEAR'.  Note that no time zone
     adjustments are done even if the input is an aware object.

`(2)'
     Computes the datetime2 such that datetime2 + timedelta ==
     datetime1.  As for addition, the result has the same `tzinfo'
     member as the input datetime, and no time zone adjustments are
     done even if the input is aware.  This isn't quite equivalent to
     datetime1 + (-timedelta), because -timedelta in isolation can
     overflow in cases where datetime1 - timedelta does not.

`(3)'
     Subtraction of a `datetime' from a `datetime' is defined only if
     both operands are naive, or if both are aware.  If one is aware
     and the other is naive, `TypeError' is raised.

     If both are naive, or both are aware and have the same `tzinfo'
     member, the `tzinfo' members are ignored, and the result is a
     `timedelta' object T such that `DATETIME2 + T == DATETIME1'.  No
     time zone adjustments are done in this case.

     If both are aware and have different `tzinfo' members, `a-b' acts
     as if A and B were first converted to naive UTC datetimes first.
     The result is `(A.replace(tzinfo=None) - A.utcoffset()) -
     (B.replace(tzinfo=None) - B.utcoffset())' except that the
     implementation never overflows.

`(4)'
     DATETIME1 is considered less than DATETIME2 when DATETIME1
     precedes DATETIME2 in time.

     If one comparand is naive and the other is aware, `TypeError' is
     raised.  If both comparands are aware, and have the same `tzinfo'
     member, the common `tzinfo' member is ignored and the base
     datetimes are compared.  If both comparands are aware and have
     different `tzinfo' members, the comparands are first adjusted by
     subtracting their UTC offsets (obtained from `self.utcoffset()').
     _Note:_ In order to stop comparison from falling back to the
     default scheme of comparing object addresses, datetime comparison
     normally raises `TypeError' if the other comparand isn't also a
     `datetime' object.  However, `NotImplemented' is returned instead
     if the other comparand has a `timetuple' attribute.  This hook
     gives other kinds of date objects a chance at implementing
     mixed-type comparison.  If not, when a `datetime' object is
     compared to an object of a different type, `TypeError' is raised
     unless the comparison is `==' or `!='.  The latter cases return
     `False' or `True', respectively.

`datetime' objects can be used as dictionary keys. In Boolean contexts,
all `datetime' objects are considered to be true.

Instance methods:

`date()'
     Return `date' object with same year, month and day.

`time()'
     Return `time' object with same hour, minute, second and
     microsecond.  `tzinfo' is `None'.  See also method `timetz()'.

`timetz()'
     Return `time' object with same hour, minute, second, microsecond,
     and tzinfo members.  See also method `time()'.

`replace(year=, month=, day=, hour=, minute=, second=, microsecond=, tzinfo=)'
     Return a datetime with the same members, except for those members
     given new values by whichever keyword arguments are specified.
     Note that `tzinfo=None' can be specified to create a naive
     datetime from an aware datetime with no conversion of date and
     time members.

`astimezone(tz)'
     Return a `datetime' object with new `tzinfo' member TZ, adjusting
     the date and time members so the result is the same UTC time as
     SELF, but in TZ's local time.

     TZ must be an instance of a `tzinfo' subclass, and its
     `utcoffset()' and `dst()' methods must not return `None'.  SELF
     must be aware (`SELF.tzinfo' must not be `None', and
     `SELF.utcoffset()' must not return `None').

     If `SELF.tzinfo' is TZ, `SELF.astimezone(TZ)' is equal to SELF:  no
     adjustment of date or time members is performed.  Else the result
     is local time in time zone TZ, representing the same UTC time as
     SELF:  after `ASTZ = DT.astimezone(TZ)', `ASTZ - ASTZ.utcoffset()'
     will usually have the same date and time members as `DT -
     DT.utcoffset()'.  The discussion of class `tzinfo' explains the
     cases at Daylight Saving Time transition boundaries where this
     cannot be achieved (an issue only if TZ models both standard and
     daylight time).

     If you merely want to attach a time zone object TZ to a datetime
     DT without adjustment of date and time members, use
     `DT.replace(tzinfo=TZ)'.  If you merely want to remove the time
     zone object from an aware datetime DT without conversion of date
     and time members, use `DT.replace(tzinfo=None)'.

     Note that the default `tzinfo.fromutc()' method can be overridden
     in a `tzinfo' subclass to affect the result returned by
     `astimezone()'.  Ignoring error cases, `astimezone()' acts like:

            def astimezone(self, tz):
                if self.tzinfo is tz:
                    return self
                # Convert self to UTC, and attach the new time zone object.
                utc = (self - self.utcoffset()).replace(tzinfo=tz)
                # Convert from UTC to tz's local time.
                return tz.fromutc(utc)

`utcoffset()'
     If `tzinfo' is `None', returns `None', else returns
     `SELF.tzinfo.utcoffset(SELF)', and raises an exception if the
     latter doesn't return `None', or a `timedelta' object representing
     a whole number of minutes with magnitude less than one day.

`dst()'
     If `tzinfo' is `None', returns `None', else returns
     `SELF.tzinfo.dst(SELF)', and raises an exception if the latter
     doesn't return `None', or a `timedelta' object representing a
     whole number of minutes with magnitude less than one day.

`tzname()'
     If `tzinfo' is `None', returns `None', else returns
     `SELF.tzinfo.tzname(SELF)', raises an exception if the latter
     doesn't return `None' or a string object,

`timetuple()'
     Return a `time.struct_time' such as returned by `time.localtime()'.
     `D.timetuple()' is equivalent to `time.struct_time((D.year,
     D.month, D.day, D.hour, D.minute, D.second, D.weekday(),
     D.toordinal() - date(D.year, 1, 1).toordinal() + 1, dst))' The
     `tm_isdst' flag of the result is set according to the `dst()'
     method:  if `tzinfo' is `None' or `dst()' returns `None',
     `tm_isdst' is set to  `-1'; else if `dst()' returns a non-zero
     value, `tm_isdst' is set to `1'; else `tm_isdst' is set to `0'.

`utctimetuple()'
     If `datetime' instance D is naive, this is the same as
     `D.timetuple()' except that `tm_isdst' is forced to 0 regardless
     of what `d.dst()' returns.  DST is never in effect for a UTC time.

     If D is aware, D is normalized to UTC time, by subtracting
     `D.utcoffset()', and a `time.struct_time' for the normalized time
     is returned.  `tm_isdst' is forced to 0.  Note that the result's
     `tm_year' member may be `MINYEAR'-1 or `MAXYEAR'+1, if D.year was
     `MINYEAR' or `MAXYEAR' and UTC adjustment spills over a year
     boundary.

`toordinal()'
     Return the proleptic Gregorian ordinal of the date.  The same as
     `self.date().toordinal()'.

`weekday()'
     Return the day of the week as an integer, where Monday is 0 and
     Sunday is 6.  The same as `self.date().weekday()'.  See also
     `isoweekday()'.

`isoweekday()'
     Return the day of the week as an integer, where Monday is 1 and
     Sunday is 7.  The same as `self.date().isoweekday()'.  See also
     `weekday()', `isocalendar()'.

`isocalendar()'
     Return a 3-tuple, (ISO year, ISO week number, ISO weekday).  The
     same as `self.date().isocalendar()'.

`isoformat(sep='T')'
     Return a string representing the date and time in ISO 8601 format,
     YYYY-MM-DDTHH:MM:SS.mmmmmm or, if `microsecond' is 0,
     YYYY-MM-DDTHH:MM:SS

     If `utcoffset()' does not return `None', a 6-character string is
     appended, giving the UTC offset in (signed) hours and minutes:
     YYYY-MM-DDTHH:MM:SS.mmmmmm+HH:MM or, if `microsecond' is 0
     YYYY-MM-DDTHH:MM:SS+HH:MM

     The optional argument SEP (default `'T'') is a one-character
     separator, placed between the date and time portions of the
     result.  For example,

          >>> from datetime import tzinfo, timedelta, datetime
          >>> class TZ(tzinfo):
          ...     def utcoffset(self, dt): return timedelta(minutes=-399)
          ...
          >>> datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')
          '2002-12-25 00:00:00-06:39'

`__str__()'
     For a `datetime' instance D, `str(D)' is equivalent to
     `D.isoformat(' ')'.

`ctime()'
     Return a string representing the date and time, for example
     `datetime(2002, 12, 4, 20, 30, 40).ctime() == 'Wed Dec  4 20:30:40
     2002''.  `d.ctime()' is equivalent to
     `time.ctime(time.mktime(d.timetuple()))' on platforms where the
     native C `ctime()' function (which `time.ctime()' invokes, but
     which `datetime.ctime()' does not invoke) conforms to the C
     standard.

`strftime(format)'
     Return a string representing the date and time, controlled by an
     explicit format string.  See the section on `strftime()' behavior.


File: python-lib.info,  Node: time Objects,  Next: tzinfo Objects,  Prev: datetime Objects,  Up: datetime

`time' Objects
--------------

A time object represents a (local) time of day, independent of any
particular day, and subject to adjustment via a `tzinfo' object.

`time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None)'
     All arguments are optional.  TZINFO may be `None', or an instance
     of a `tzinfo' subclass.  The remaining arguments may be ints or
     longs, in the following ranges:

        * `0 <= HOUR < 24'

        * `0 <= MINUTE < 60'

        * `0 <= SECOND < 60'

        * `0 <= MICROSECOND < 1000000'.

     If an argument outside those ranges is given, `ValueError' is
     raised.

Class attributes:

`min'
     The earliest representable `time', `time(0, 0, 0, 0)'.

`max'
     The latest representable `time', `time(23, 59, 59, 999999)'.

`resolution'
     The smallest possible difference between non-equal `time' objects,
     `timedelta(microseconds=1)', although note that arithmetic on
     `time' objects is not supported.

Instance attributes (read-only):

`hour'
     In `range(24)'.

`minute'
     In `range(60)'.

`second'
     In `range(60)'.

`microsecond'
     In `range(1000000)'.

`tzinfo'
     The object passed as the tzinfo argument to the `time'
     constructor, or `None' if none was passed.

Supported operations:

   * comparison of `time' to `time', where A is considered less than B
     when A precedes B in time.  If one comparand is naive and the
     other is aware, `TypeError' is raised.  If both comparands are
     aware, and have the same `tzinfo' member, the common `tzinfo'
     member is ignored and the base times are compared.  If both
     comparands are aware and have different `tzinfo' members, the
     comparands are first adjusted by subtracting their UTC offsets
     (obtained from `self.utcoffset()').  In order to stop mixed-type
     comparisons from falling back to the default comparison by object
     address, when a `time' object is compared to an object of a
     different type, `TypeError' is raised unless the comparison is
     `==' or `!='.  The latter cases return `False' or `True',
     respectively.

   * hash, use as dict key

   * efficient pickling

   * in Boolean contexts, a `time' object is considered to be true if
     and only if, after converting it to minutes and subtracting
     `utcoffset()' (or `0' if that's `None'), the result is non-zero.

Instance methods:

{replace}(hour=, minute=, second=, microsecond=, tzinfo=)
`1(2)'
     turn a `time' with the same value, except for those members given
     new values by whichever keyword arguments are specified.  Note that
     `tzinfo=None' can be specified to create a naive `time' from an
     aware `time', without conversion of the time members.

`isoformat()'
     Return a string representing the time in ISO 8601 format,
     HH:MM:SS.mmmmmm or, if self.microsecond is 0, HH:MM:SS If
     `utcoffset()' does not return `None', a 6-character string is
     appended, giving the UTC offset in (signed) hours and minutes:
     HH:MM:SS.mmmmmm+HH:MM or, if self.microsecond is 0, HH:MM:SS+HH:MM

`__str__()'
     For a time T, `str(T)' is equivalent to `T.isoformat()'.

`strftime(format)'
     Return a string representing the time, controlled by an explicit
     format string.  See the section on `strftime()' behavior.

`utcoffset()'
     If `tzinfo' is `None', returns `None', else returns
     `SELF.tzinfo.utcoffset(None)', and raises an exception if the
     latter doesn't return `None' or a `timedelta' object representing
     a whole number of minutes with magnitude less than one day.

`dst()'
     If `tzinfo' is `None', returns `None', else returns
     `SELF.tzinfo.dst(None)', and raises an exception if the latter
     doesn't return `None', or a `timedelta' object representing a
     whole number of minutes with magnitude less than one day.

`tzname()'
     If `tzinfo' is `None', returns `None', else returns
     `SELF.tzinfo.tzname(None)', or raises an exception if the latter
     doesn't return `None' or a string object.


File: python-lib.info,  Node: tzinfo Objects,  Next: strftime Behavior,  Prev: time Objects,  Up: datetime

`tzinfo' Objects
----------------

`tzinfo' is an abstract base clase, meaning that this class should not
be instantiated directly.  You need to derive a concrete subclass, and
(at least) supply implementations of the standard `tzinfo' methods
needed by the `datetime' methods you use.  The `datetime' module does
not supply any concrete subclasses of `tzinfo'.

An instance of (a concrete subclass of) `tzinfo' can be passed to the
constructors for `datetime' and `time' objects.  The latter objects
view their members as being in local time, and the `tzinfo' object
supports methods revealing offset of local time from UTC, the name of
the time zone, and DST offset, all relative to a date or time object
passed to them.

Special requirement for pickling:  A `tzinfo' subclass must have an
`__init__' method that can be called with no arguments, else it can be
pickled but possibly not unpickled again.  This is a technical
requirement that may be relaxed in the future.

A concrete subclass of `tzinfo' may need to implement the following
methods.  Exactly which methods are needed depends on the uses made of
aware `datetime' objects.  If in doubt, simply implement all of them.

`utcoffset(self, dt)'
     Return offset of local time from UTC, in minutes east of UTC.  If
     local time is west of UTC, this should be negative.  Note that this
     is intended to be the total offset from UTC; for example, if a
     `tzinfo' object represents both time zone and DST adjustments,
     `utcoffset()' should return their sum.  If the UTC offset isn't
     known, return `None'.  Else the value returned must be a
     `timedelta' object specifying a whole number of minutes in the
     range -1439 to 1439 inclusive (1440 = 24*60; the magnitude of the
     offset must be less than one day).  Most implementations of
     `utcoffset()' will probably look like one of these two:

              return CONSTANT                 # fixed-offset class
              return CONSTANT + self.dst(dt)  # daylight-aware class

     If `utcoffset()' does not return `None', `dst()' should not return
     `None' either.

     The default implementation of `utcoffset()' raises
     `NotImplementedError'.

`dst(self, dt)'
     Return the daylight saving time (DST) adjustment, in minutes east
     of UTC, or `None' if DST information isn't known.  Return
     `timedelta(0)' if DST is not in effect.  If DST is in effect,
     return the offset as a `timedelta' object (see `utcoffset()' for
     details).  Note that DST offset, if applicable, has already been
     added to the UTC offset returned by `utcoffset()', so there's no
     need to consult `dst()' unless you're interested in obtaining DST
     info separately.  For example, `datetime.timetuple()' calls its
     `tzinfo' member's `dst()' method to determine how the `tm_isdst'
     flag should be set, and `tzinfo.fromutc()' calls `dst()' to
     account for DST changes when crossing time zones.

     An instance TZ of a `tzinfo' subclass that models both standard
     and daylight times must be consistent in this sense:

     `TZ.utcoffset(DT) - TZ.dst(DT)'

     must return the same result for every `datetime' DT with
     `DT.tzinfo==TZ'  For sane `tzinfo' subclasses, this expression
     yields the time zone's "standard offset", which should not depend
     on the date or the time, but only on geographic location.  The
     implementation of `datetime.astimezone()' relies on this, but
     cannot detect violations; it's the programmer's responsibility to
     ensure it.  If a `tzinfo' subclass cannot guarantee this, it may
     be able to override the default implementation of
     `tzinfo.fromutc()' to work correctly with `astimezone()'
     regardless.

     Most implementations of `dst()' will probably look like one of
     these two:

              return timedelta(0)   # a fixed-offset class:  doesn't account for DST
          
            or
          
              # Code to set dston and dstoff to the time zone's DST transition
              # times based on the input dt.year, and expressed in standard local
              # time.  Then
          
              if dston <= dt.replace(tzinfo=None) < dstoff:
                  return timedelta(hours=1)
              else:
                  return timedelta(0)

     The default implementation of `dst()' raises `NotImplementedError'.

`tzname(self, dt)'
     Return the time zone name corresponding to the `datetime' object
     DT, as a string.  Nothing about string names is defined by the
     `datetime' module, and there's no requirement that it mean
     anything in particular.  For example, "GMT", "UTC", "-500",
     "-5:00", "EDT", "US/Eastern", "America/New York" are all valid
     replies.  Return `None' if a string name isn't known.  Note that
     this is a method rather than a fixed string primarily because some
     `tzinfo' subclasses will wish to return different names depending
     on the specific value of DT passed, especially if the `tzinfo'
     class is accounting for daylight time.

     The default implementation of `tzname()' raises
     `NotImplementedError'.

These methods are called by a `datetime' or `time' object, in response
to their methods of the same names.  A `datetime' object passes itself
as the argument, and a `time' object passes `None' as the argument.  A
`tzinfo' subclass's methods should therefore be prepared to accept a DT
argument of `None', or of class `datetime'.

When `None' is passed, it's up to the class designer to decide the best
response.  For example, returning `None' is appropriate if the class
wishes to say that time objects don't participate in the `tzinfo'
protocols.  It may be more useful for `utcoffset(None)' to return the
standard UTC offset, as there is no other convention for discovering
the standard offset.

When a `datetime' object is passed in response to a `datetime' method,
`dt.tzinfo' is the same object as SELF.  `tzinfo' methods can rely on
this, unless user code calls `tzinfo' methods directly.  The intent is
that the `tzinfo' methods interpret DT as being in local time, and not
need worry about objects in other timezones.

There is one more `tzinfo' method that a subclass may wish to override:

`fromutc(self, dt)'
     This is called from the default `datetime.astimezone()'
     implementation.  When called from that, `DT.tzinfo' is SELF, and
     DT's date and time members are to be viewed as expressing a UTC
     time.  The purpose of `fromutc()' is to adjust the date and time
     members, returning an equivalent datetime in SELF's local time.

     Most `tzinfo' subclasses should be able to inherit the default
     `fromutc()' implementation without problems.  It's strong enough
     to handle fixed-offset time zones, and time zones accounting for
     both standard and daylight time, and the latter even if the DST
     transition times differ in different years.  An example of a time
     zone the default `fromutc()' implementation may not handle
     correctly in all cases is one where the standard offset (from UTC)
     depends on the specific date and time passed, which can happen for
     political reasons.  The default implementations of `astimezone()'
     and `fromutc()' may not produce the result you want if the result
     is one of the hours straddling the moment the standard offset
     changes.

     Skipping code for error cases, the default `fromutc()'
     implementation acts like:

            def fromutc(self, dt):
                # raise ValueError error if dt.tzinfo is not self
                dtoff = dt.utcoffset()
                dtdst = dt.dst()
                # raise ValueError if dtoff is None or dtdst is None
                delta = dtoff - dtdst  # this is self's standard offset
                if delta:
                    dt += delta   # convert to standard local time
                    dtdst = dt.dst()
                    # raise ValueError if dtdst is None
                if dtdst:
                    return dt + dtdst
                else:
                    return dt

Example `tzinfo' classes:

`tzinfo-examples.py'

Note that there are unavoidable subtleties twice per year in a `tzinfo'
subclass accounting for both standard and daylight time, at the DST
transition points.  For concreteness, consider US Eastern (UTC -0500),
where EDT begins the minute after 1:59 (EST) on the first Sunday in
April, and ends the minute after 1:59 (EDT) on the last Sunday in
October:

         UTC   3:MM  4:MM  5:MM  6:MM  7:MM  8:MM
         EST  22:MM 23:MM  0:MM  1:MM  2:MM  3:MM
         EDT  23:MM  0:MM  1:MM  2:MM  3:MM  4:MM
     
       start  22:MM 23:MM  0:MM  1:MM  3:MM  4:MM
     
         end  23:MM  0:MM  1:MM  1:MM  2:MM  3:MM

When DST starts (the "start" line), the local wall clock leaps from 1:59
to 3:00.  A wall time of the form 2:MM doesn't really make sense on that
day, so `astimezone(Eastern)' won't deliver a result with `hour==2' on
the day DST begins.  In order for `astimezone()' to make this
guarantee, the `rzinfo.dst()' method must consider times in the
"missing hour" (2:MM for Eastern) to be in daylight time.

When DST ends (the "end" line), there's a potentially worse problem:
there's an hour that can't be spelled unambiguously in local wall time:
the last hour of daylight time.  In Eastern, that's times of the form
5:MM UTC on the day daylight time ends.  The local wall clock leaps
from 1:59 (daylight time) back to 1:00 (standard time) again.  Local
times of the form 1:MM are ambiguous.  `astimezone()' mimics the local
clock's behavior by mapping two adjacent UTC hours into the same local
hour then.  In the Eastern example, UTC times of the form 5:MM and 6:MM
both map to 1:MM when converted to Eastern.  In order for
`astimezone()' to make this guarantee, the `tzinfo.dst()' method must
consider times in the "repeated hour" to be in standard time.  This is
easily arranged, as in the example, by expressing DST switch times in
the time zone's standard local time.

Applications that can't bear such ambiguities should avoid using hybrid
`tzinfo' subclasses; there are no ambiguities when using UTC, or any
other fixed-offset `tzinfo' subclass (such as a class representing only
EST (fixed offset -5 hours), or only EDT (fixed offset -4 hours)).


File: python-lib.info,  Node: strftime Behavior,  Prev: tzinfo Objects,  Up: datetime

`strftime()' Behavior
---------------------

`date', `datetime', and `time' objects all support a `strftime(FORMAT)'
method, to create a string representing the time under the control of
an explicit format string.  Broadly speaking, `d.strftime(fmt)' acts
like the `time' module's `time.strftime(fmt, d.timetuple())' although
not all objects support a `timetuple()' method.

For `time' objects, the format codes for year, month, and day should
not be used, as time objects have no such values.  If they're used
anyway, `1900' is substituted for the year, and `0' for the month and
day.

For `date' objects, the format codes for hours, minutes, and seconds
should not be used, as `date' objects have no such values.  If they're
used anyway, `0' is substituted for them.

For a naive object, the `%z' and `%Z' format codes are replaced by
empty strings.

For an aware object:

   * `%z' `utcoffset()' is transformed into a 5-character string of the
     form +HHMM or -HHMM, where HH is a 2-digit string giving the
     number of UTC offset hours, and MM is a 2-digit string giving the
     number of UTC offset minutes.  For example, if `utcoffset()'
     returns `timedelta(hours=-3, minutes=-30)', `%z' is replaced with
     the string `'-0330''.

   * `%Z' If `tzname()' returns `None', `%Z' is replaced by an empty
     string.  Otherwise `%Z' is replaced by the returned value, which
     must be a string.

The full set of format codes supported varies across platforms, because
Python calls the platform C library's `strftime()' function, and
platform variations are common.  The documentation for Python's `time'
module lists the format codes that the C standard (1989 version)
requires, and those work on all platforms with a standard C
implementation.  Note that the 1999 version of the C standard added
additional format codes.

The exact range of years for which `strftime()' works also varies
across platforms.  Regardless of platform, years before 1900 cannot be
used.

