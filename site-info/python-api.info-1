This is python-api.info, produced by makeinfo version 4.3 from
python-api.texi.

October 3, 2003


File: python-api.info,  Node: Top,  Next: Front Matter,  Prev: (dir),  Up: (dir)

Python/C API Reference Manual
*****************************

* Menu:

* Front Matter::
* Introduction::
* Very High Level Layer::
* Reference Counting::
* Exception Handling::
* Utilities::
* Abstract Objects Layer::
* Concrete Objects Layer::
* Initialization::
* Memory Management::
* Object Implementation Support::
* Reporting Bugs::
* History and License::
* Module Index::
* Class-Exception-Object Index::
* Function-Method-Variable Index::
* Miscellaneous Index::


File: python-api.info,  Node: Front Matter,  Next: Introduction,  Prev: Top,  Up: Top

Front Matter
************

Copyright (C) 2001, 2002, 2003 Python Software Foundation.  All rights
reserved.

Copyright (C) 2000 BeOpen.com.  All rights reserved.

Copyright (C) 1995-2000 Corporation for National Research Initiatives.
All rights reserved.

Copyright (C) 1991-1995 Stichting Mathematisch Centrum.  All rights
reserved.

See the end of this document for complete license and permissions
information.

     This manual documents the API used by C and C++ programmers who
     want to write extension modules or embed Python.  It is a
     companion to , which describes the general principles of extension
     writing but does not document the API functions in detail.

     _The current version of this document is incomplete.  I hope that
     it is nevertheless useful.  I will continue to work on it, and
     release new versions from time to time, independent from Python
     source code releases._



File: python-api.info,  Node: Introduction,  Next: Very High Level Layer,  Prev: Front Matter,  Up: Top

Introduction
************

The Application Programmer's Interface to Python gives C and C++
programmers access to the Python interpreter at a variety of levels.
The API is equally usable from C++, but for brevity it is generally
referred to as the Python/C API.  There are two fundamentally different
reasons for using the Python/C API.  The first reason is to write
_extension modules_ for specific purposes; these are C modules that
extend the Python interpreter.  This is probably the most common use.
The second reason is to use Python as a component in a larger
application; this technique is generally referred to as "embedding"
Python in an application.

Writing an extension module is a relatively well-understood process,
where a "cookbook" approach works well.  There are several tools that
automate the process to some extent.  While people have embedded Python
in other applications since its early existence, the process of
embedding Python is less straightforward than writing an extension.

Many API functions are useful independent of whether you're embedding
or extending Python; moreover, most applications that embed Python will
need to provide a custom extension as well, so it's probably a good
idea to become familiar with writing an extension before attempting to
embed Python in a real application.

* Menu:

* Include Files::
* Objects::
* Exceptions::
* Embedding Python::


File: python-api.info,  Node: Include Files,  Next: Objects,  Prev: Introduction,  Up: Introduction

Include Files
=============

All function, type and macro definitions needed to use the Python/C API
are included in your code by the following line:

     #include "Python.h"

This implies inclusion of the following standard headers: `<stdio.h>',
`<string.h>', `<errno.h>', `<limits.h>', and `<stdlib.h>' (if
available).  Since Python may define some pre-processor definitions
which affect the standard headers on some systems, you must include
`Python.h' before any standard headers are included.

All user visible names defined by Python.h (except those defined by the
included standard headers) have one of the prefixes `Py' or `_Py'.
Names beginning with `_Py' are for internal use by the Python
implementation and should not be used by extension writers.  Structure
member names do not have a reserved prefix.

*Important:* user code should never define names that begin with `Py'
or `_Py'.  This confuses the reader, and jeopardizes the portability of
the user code to future Python versions, which may define additional
names beginning with one of these prefixes.

The header files are typically installed with Python.  On UNIX, these
are located in the directories ``prefix'/include/pythonVERSION/' and
``exec_prefix'/include/pythonVERSION/', where `prefix' and
`exec_prefix' are defined by the corresponding parameters to Python's
`configure' script and VERSION is `sys.version[:3]'.  On Windows, the
headers are installed in ``prefix'/include', where `prefix' is the
installation directory specified to the installer.

To include the headers, place both directories (if different) on your
compiler's search path for includes.  Do _not_ place the parent
directories on the search path and then use `#include
<python2.3/Python.h>'; this will break on multi-platform builds since
the platform independent headers under `prefix' include the platform
specific headers from `exec_prefix'.

C++ users should note that though the API is defined entirely using C,
the header files do properly declare the entry points to be `extern
"C"', so there is no need to do anything special to use the API from
C++.


File: python-api.info,  Node: Objects,  Next: Exceptions,  Prev: Include Files,  Up: Introduction

Objects, Types and Reference Counts
===================================

Most Python/C API functions have one or more arguments as well as a
return value of type `PyObject*'.  This type is a pointer to an opaque
data type representing an arbitrary Python object.  Since all Python
object types are treated the same way by the Python language in most
situations (e.g., assignments, scope rules, and argument passing), it
is only fitting that they should be represented by a single C type.
Almost all Python objects live on the heap: you never declare an
automatic or static variable of type `PyObject', only pointer variables
of type `PyObject*' can be declared.  The sole exception are the type
objects ; since these must never be deallocated, they are typically
static `PyTypeObject' objects.

All Python objects (even Python integers) have a "type" and a
"reference count".  An object's type determines what kind of object it
is (e.g., an integer, a list, or a user-defined function; there are
many more as explained in the ).  For each of the well-known types
there is a macro to check whether an object is of that type; for
instance, `PyList_Check(A)' is true if (and only if) the object pointed
to by A is a Python list.

* Menu:

* Reference Counts::
* Types::


File: python-api.info,  Node: Reference Counts,  Next: Types,  Prev: Objects,  Up: Objects

Reference Counts
----------------

The reference count is important because today's computers have a
finite (and often severely limited) memory size; it counts how many
different places there are that have a reference to an object.  Such a
place could be another object, or a global (or static) C variable, or a
local variable in some C function.  When an object's reference count
becomes zero, the object is deallocated.  If it contains references to
other objects, their reference count is decremented.  Those other
objects may be deallocated in turn, if this decrement makes their
reference count become zero, and so on.  (There's an obvious problem
with objects that reference each other here; for now, the solution is
"don't do that.")

Reference counts are always manipulated explicitly.  The normal way is
to use the macro `Py_INCREF()'  to increment an object's reference
count by one, and `Py_DECREF()'  to decrement it by one.  The
`Py_DECREF()' macro is considerably more complex than the incref one,
since it must check whether the reference count becomes zero and then
cause the object's deallocator to be called.  The deallocator is a
function pointer contained in the object's type structure.  The
type-specific deallocator takes care of decrementing the reference
counts for other objects contained in the object if this is a compound
object type, such as a list, as well as performing any additional
finalization that's needed.  There's no chance that the reference count
can overflow; at least as many bits are used to hold the reference
count as there are distinct memory locations in virtual memory
(assuming `sizeof(long) >= sizeof(char*)').  Thus, the reference count
increment is a simple operation.

It is not necessary to increment an object's reference count for every
local variable that contains a pointer to an object.  In theory, the
object's reference count goes up by one when the variable is made to
point to it and it goes down by one when the variable goes out of
scope.  However, these two cancel each other out, so at the end the
reference count hasn't changed.  The only real reason to use the
reference count is to prevent the object from being deallocated as long
as our variable is pointing to it.  If we know that there is at least
one other reference to the object that lives at least as long as our
variable, there is no need to increment the reference count
temporarily.  An important situation where this arises is in objects
that are passed as arguments to C functions in an extension module that
are called from Python; the call mechanism guarantees to hold a
reference to every argument for the duration of the call.

However, a common pitfall is to extract an object from a list and hold
on to it for a while without incrementing its reference count.  Some
other operation might conceivably remove the object from the list,
decrementing its reference count and possible deallocating it.  The
real danger is that innocent-looking operations may invoke arbitrary
Python code which could do this; there is a code path which allows
control to flow back to the user from a `Py_DECREF()', so almost any
operation is potentially dangerous.

A safe approach is to always use the generic operations (functions
whose name begins with `PyObject_', `PyNumber_', `PySequence_' or
`PyMapping_').  These operations always increment the reference count
of the object they return.  This leaves the caller with the
responsibility to call `Py_DECREF()' when they are done with the
result; this soon becomes second nature.

* Menu:

* Reference Count Details::


File: python-api.info,  Node: Reference Count Details,  Prev: Reference Counts,  Up: Reference Counts

Reference Count Details
.......................

The reference count behavior of functions in the Python/C API is best
explained in terms of _ownership of references_.  Note that we talk of
owning references, never of owning objects; objects are always shared!
When a function owns a reference, it has to dispose of it properly --
either by passing ownership on (usually to its caller) or by calling
`Py_DECREF()' or `Py_XDECREF()'.  When a function passes ownership of a
reference on to its caller, the caller is said to receive a _new_
reference.  When no ownership is transferred, the caller is said to
_borrow_ the reference.  Nothing needs to be done for a borrowed
reference.

Conversely, when a calling function passes it a reference to an object,
there are two possibilities: the function _steals_ a reference to the
object, or it does not.  Few functions steal references; the two
notable exceptions are `PyList_SetItem()'  and `PyTuple_SetItem()' ,
which steal a reference to the item (but not to the tuple or list into
which the item is put!).  These functions were designed to steal a
reference because of a common idiom for populating a tuple or list with
newly created objects; for example, the code to create the tuple `(1,
2, "three")' could look like this (forgetting about error handling for
the moment; a better way to code this is shown below):

     PyObject *t;
     
     t = PyTuple_New(3);
     PyTuple_SetItem(t, 0, PyInt_FromLong(1L));
     PyTuple_SetItem(t, 1, PyInt_FromLong(2L));
     PyTuple_SetItem(t, 2, PyString_FromString("three"));

Incidentally, `PyTuple_SetItem()' is the _only_ way to set tuple items;
`PySequence_SetItem()' and `PyObject_SetItem()' refuse to do this since
tuples are an immutable data type.  You should only use
`PyTuple_SetItem()' for tuples that you are creating yourself.

Equivalent code for populating a list can be written using
`PyList_New()' and `PyList_SetItem()'.  Such code can also use
`PySequence_SetItem()'; this illustrates the difference between the two
(the extra `Py_DECREF()' calls):

     PyObject *l, *x;
     
     l = PyList_New(3);
     x = PyInt_FromLong(1L);
     PySequence_SetItem(l, 0, x); Py_DECREF(x);
     x = PyInt_FromLong(2L);
     PySequence_SetItem(l, 1, x); Py_DECREF(x);
     x = PyString_FromString("three");
     PySequence_SetItem(l, 2, x); Py_DECREF(x);

You might find it strange that the "recommended" approach takes more
code.  However, in practice, you will rarely use these ways of creating
and populating a tuple or list.  There's a generic function,
`Py_BuildValue()', that can create most common objects from C values,
directed by a "format string".  For example, the above two blocks of
code could be replaced by the following (which also takes care of the
error checking):

     PyObject *t, *l;
     
     t = Py_BuildValue("(iis)", 1, 2, "three");
     l = Py_BuildValue("[iis]", 1, 2, "three");

It is much more common to use `PyObject_SetItem()' and friends with
items whose references you are only borrowing, like arguments that were
passed in to the function you are writing.  In that case, their
behaviour regarding reference counts is much saner, since you don't
have to increment a reference count so you can give a reference away
("have it be stolen").  For example, this function sets all items of a
list (actually, any mutable sequence) to a given item:

     int
     set_all(PyObject *target, PyObject *item)
     {
         int i, n;
     
         n = PyObject_Length(target);
         if (n < 0)
             return -1;
         for (i = 0; i < n; i++) {
             if (PyObject_SetItem(target, i, item) < 0)
                 return -1;
         }
         return 0;
     }

The situation is slightly different for function return values.  While
passing a reference to most functions does not change your ownership
responsibilities for that reference, many functions that return a
referece to an object give you ownership of the reference.  The reason
is simple: in many cases, the returned object is created on the fly,
and the reference you get is the only reference to the object.
Therefore, the generic functions that return object references, like
`PyObject_GetItem()' and `PySequence_GetItem()', always return a new
reference (the caller becomes the owner of the reference).

It is important to realize that whether you own a reference returned by
a function depends on which function you call only -- _the plumage_
(the type of the type of the object passed as an argument to the
function) _doesn't enter into it!_  Thus, if you extract an item from a
list using `PyList_GetItem()', you don't own the reference -- but if
you obtain the same item from the same list using
`PySequence_GetItem()' (which happens to take exactly the same
arguments), you do own a reference to the returned object.

Here is an example of how you could write a function that computes the
sum of the items in a list of integers; once using `PyList_GetItem()' ,
and once using `PySequence_GetItem()' .

     long
     sum_list(PyObject *list)
     {
         int i, n;
         long total = 0;
         PyObject *item;
     
         n = PyList_Size(list);
         if (n < 0)
             return -1; /* Not a list */
         for (i = 0; i < n; i++) {
             item = PyList_GetItem(list, i); /* Can't fail */
             if (!PyInt_Check(item)) continue; /* Skip non-integers */
             total += PyInt_AsLong(item);
         }
         return total;
     }

     long
     sum_sequence(PyObject *sequence)
     {
         int i, n;
         long total = 0;
         PyObject *item;
         n = PySequence_Length(sequence);
         if (n < 0)
             return -1; /* Has no length */
         for (i = 0; i < n; i++) {
             item = PySequence_GetItem(sequence, i);
             if (item == NULL)
                 return -1; /* Not a sequence, or other failure */
             if (PyInt_Check(item))
                 total += PyInt_AsLong(item);
             Py_DECREF(item); /* Discard reference ownership */
         }
         return total;
     }


File: python-api.info,  Node: Types,  Prev: Reference Counts,  Up: Objects

Types
-----

There are few other data types that play a significant role in the
Python/C API; most are simple C types such as `int', `long', `double'
and `char*'.  A few structure types are used to describe static tables
used to list the functions exported by a module or the data attributes
of a new object type, and another is used to describe the value of a
complex number.  These will be discussed together with the functions
that use them.


File: python-api.info,  Node: Exceptions,  Next: Embedding Python,  Prev: Objects,  Up: Introduction

Exceptions
==========

The Python programmer only needs to deal with exceptions if specific
error handling is required; unhandled exceptions are automatically
propagated to the caller, then to the caller's caller, and so on, until
they reach the top-level interpreter, where they are reported to the
user accompanied by a stack traceback.

For C programmers, however, error checking always has to be explicit.
All functions in the Python/C API can raise exceptions, unless an
explicit claim is made otherwise in a function's documentation.  In
general, when a function encounters an error, it sets an exception,
discards any object references that it owns, and returns an error
indicator -- usually `NULL' or `-1'.  A few functions return a Boolean
true/false result, with false indicating an error.  Very few functions
return no explicit error indicator or have an ambiguous return value,
and require explicit testing for errors with `PyErr_Occurred()' .

Exception state is maintained in per-thread storage (this is equivalent
to using global storage in an unthreaded application).  A thread can be
in one of two states: an exception has occurred, or not.  The function
`PyErr_Occurred()' can be used to check for this: it returns a borrowed
reference to the exception type object when an exception has occurred,
and `NULL' otherwise.  There are a number of functions to set the
exception state: `PyErr_SetString()'  is the most common (though not
the most general) function to set the exception state, and
`PyErr_Clear()'  clears the exception state.

The full exception state consists of three objects (all of which can be
`NULL'): the exception type, the corresponding exception value, and the
traceback.  These have the same meanings as the Python objects
`sys.exc_type', `sys.exc_value', and `sys.exc_traceback'; however, they
are not the same: the Python objects represent the last exception being
handled by a Python `try' ... `except' statement, while the C level
exception state only exists while an exception is being passed on
between C functions until it reaches the Python bytecode interpreter's
main loop, which takes care of transferring it to `sys.exc_type' and
friends.

Note that starting with Python 1.5, the preferred, thread-safe way to
access the exception state from Python code is to call the function
`sys.exc_info()', which returns the per-thread exception state for
Python code.  Also, the semantics of both ways to access the exception
state have changed so that a function which catches an exception will
save and restore its thread's exception state so as to preserve the
exception state of its caller.  This prevents common bugs in exception
handling code caused by an innocent-looking function overwriting the
exception being handled; it also reduces the often unwanted lifetime
extension for objects that are referenced by the stack frames in the
traceback.

As a general principle, a function that calls another function to
perform some task should check whether the called function raised an
exception, and if so, pass the exception state on to its caller.  It
should discard any object references that it owns, and return an error
indicator, but it should _not_ set another exception -- that would
overwrite the exception that was just raised, and lose important
information about the exact cause of the error.

A simple example of detecting exceptions and passing them on is shown
in the `sum_sequence()'  example above.  It so happens that that
example doesn't need to clean up any owned references when it detects
an error.  The following example function shows some error cleanup.
First, to remind you why you like Python, we show the equivalent Python
code:

     def incr_item(dict, key):
         try:
             item = dict[key]
         except KeyError:
             item = 0
         dict[key] = item + 1

Here is the corresponding C code, in all its glory:

     int
     incr_item(PyObject *dict, PyObject *key)
     {
         /* Objects all initialized to NULL for Py_XDECREF */
         PyObject *item = NULL, *const_one = NULL, *incremented_item = NULL;
         int rv = -1; /* Return value initialized to -1 (failure) */
     
         item = PyObject_GetItem(dict, key);
         if (item == NULL) {
             /* Handle KeyError only: */
             if (!PyErr_ExceptionMatches(PyExc_KeyError))
                 goto error;
     
             /* Clear the error and use zero: */
             PyErr_Clear();
             item = PyInt_FromLong(0L);
             if (item == NULL)
                 goto error;
         }
         const_one = PyInt_FromLong(1L);
         if (const_one == NULL)
             goto error;
     
         incremented_item = PyNumber_Add(item, const_one);
         if (incremented_item == NULL)
             goto error;
     
         if (PyObject_SetItem(dict, key, incremented_item) < 0)
             goto error;
         rv = 0; /* Success */
         /* Continue with cleanup code */
     
      error:
         /* Cleanup code, shared by success and failure path */
     
         /* Use Py_XDECREF() to ignore NULL references */
         Py_XDECREF(item);
         Py_XDECREF(const_one);
         Py_XDECREF(incremented_item);
     
         return rv; /* -1 for error, 0 for success */
     }

This example represents an endorsed use of the `goto' statement in C!
It illustrates the use of `PyErr_ExceptionMatches()'  and
`PyErr_Clear()'  to handle specific exceptions, and the use of
`Py_XDECREF()'  to dispose of owned references that may be `NULL' (note
the `X' in the name; `Py_DECREF()' would crash when confronted with a
`NULL' reference).  It is important that the variables used to hold
owned references are initialized to `NULL' for this to work; likewise,
the proposed return value is initialized to `-1' (failure) and only set
to success after the final call made is successful.


File: python-api.info,  Node: Embedding Python,  Prev: Exceptions,  Up: Introduction

Embedding Python
================

The one important task that only embedders (as opposed to extension
writers) of the Python interpreter have to worry about is the
initialization, and possibly the finalization, of the Python
interpreter.  Most functionality of the interpreter can only be used
after the interpreter has been initialized.

The basic initialization function is `Py_Initialize()' .  This
initializes the table of loaded modules, and creates the fundamental
modules `__builtin__' , `__main__' , `sys' , and `exceptions'.    It
also initializes the module search path (`sys.path').

`Py_Initialize()' does not set the "script argument list" (`sys.argv').
If this variable is needed by Python code that will be executed later,
it must be set explicitly with a call to `PySys_SetArgv(ARGC, ARGV)'
subsequent to the call to `Py_Initialize()'.

On most systems (in particular, on UNIX and Windows, although the
details are slightly different), `Py_Initialize()' calculates the
module search path based upon its best guess for the location of the
standard Python interpreter executable, assuming that the Python
library is found in a fixed location relative to the Python interpreter
executable.  In particular, it looks for a directory named
`lib/python2.3' relative to the parent directory where the executable
named `python' is found on the shell command search path (the
environment variable `PATH').

For instance, if the Python executable is found in
`/usr/local/bin/python', it will assume that the libraries are in
`/usr/local/lib/python2.3'.  (In fact, this particular path is also the
"fallback" location, used when no executable file named `python' is
found along `PATH'.)  The user can override this behavior by setting
the environment variable `PYTHONHOME', or insert additional directories
in front of the standard path by setting `PYTHONPATH'.

The embedding application can steer the search by calling
`Py_SetProgramName(FILE)'  _before_ calling `Py_Initialize()'.  Note
that `PYTHONHOME' still overrides this and `PYTHONPATH' is still
inserted in front of the standard path.  An application that requires
total control has to provide its own implementation of `Py_GetPath()' ,
`Py_GetPrefix()' , `Py_GetExecPrefix()' , and `Py_GetProgramFullPath()'
(all defined in `Modules/getpath.c').

Sometimes, it is desirable to "uninitialize" Python.  For instance, the
application may want to start over (make another call to
`Py_Initialize()') or the application is simply done with its use of
Python and wants to free all memory allocated by Python.  This can be
accomplished by calling `Py_Finalize()'.  The function
`Py_IsInitialized()'  returns true if Python is currently in the
initialized state.  More information about these functions is given in
a later chapter.


File: python-api.info,  Node: Very High Level Layer,  Next: Reference Counting,  Prev: Introduction,  Up: Top

The Very High Level Layer
*************************

The functions in this chapter will let you execute Python source code
given in a file or a buffer, but they will not let you interact in a
more detailed way with the interpreter.

Several of these functions accept a start symbol from the grammar as a
parameter.  The available start symbols are `Py_eval_input',
`Py_file_input', and `Py_single_input'.  These are described following
the functions which accept them as parameters.

Note also that several of these functions take `FILE*' parameters.  On
particular issue which needs to be handled carefully is that the `FILE'
structure for different C libraries can be different and incompatible.
Under Windows (at least), it is possible for dynamically linked
extensions to actually use different libraries, so care should be taken
that `FILE*' parameters are only passed to these functions if it is
certain that they were created by the same library that the Python
runtime is using.

`int Py_Main(int argc, char **argv)'
     The main program for the standard interpreter.  This is made
     available for programs which embed Python.  The ARGC and ARGV
     parameters should be prepared exactly as those which are passed to
     a C program's `main()' function.  It is important to note that the
     argument list may be modified (but the contents of the strings
     pointed to by the argument list are not).  The return value will
     be the integer passed to the `sys.exit()' function, `1' if the
     interpreter exits due to an exception, or `2' if the parameter
     list does not represent a valid Python command line.

`int PyRun_AnyFile(FILE *fp, char *filename)'
     If FP refers to a file associated with an interactive device
     (console or terminal input or UNIX pseudo-terminal), return the
     value of `PyRun_InteractiveLoop()', otherwise return the result of
     `PyRun_SimpleFile()'.  If FILENAME is `NULL', this function uses
     `"???"' as the filename.

`int PyRun_SimpleString(char *command)'
     Executes the Python source code from COMMAND in the `__main__'
     module.  If `__main__' does not already exist, it is created.
     Returns `0' on success or `-1' if an exception was raised.  If
     there was an error, there is no way to get the exception
     information.

`int PyRun_SimpleFile(FILE *fp, char *filename)'
     Similar to `PyRun_SimpleString()', but the Python source code is
     read from FP instead of an in-memory string.  FILENAME should be
     the name of the file.

`int PyRun_InteractiveOne(FILE *fp, char *filename)'
     Read and execute a single statement from a file associated with an
     interactive device.  If FILENAME is `NULL', `"???"' is used
     instead.  The user will be prompted using `sys.ps1' and `sys.ps2'.
     Returns `0' when the input was executed successfully, `-1' if
     there was an exception, or an error code from the `errcode.h'
     include file distributed as part of Python if there was a parse
     error.  (Note that `errcode.h' is not included by `Python.h', so
     must be included specifically if needed.)

`int PyRun_InteractiveLoop(FILE *fp, char *filename)'
     Read and execute statements from a file associated with an
     interactive device until `EOF' is reached.  If FILENAME is `NULL',
     `"???"' is used instead.  The user will be prompted using
     `sys.ps1' and `sys.ps2'.  Returns `0' at `EOF'.

`struct _node* PyParser_SimpleParseString(char *str, int start)'
     Parse Python source code from STR using the start token START.
     The result can be used to create a code object which can be
     evaluated efficiently.  This is useful if a code fragment must be
     evaluated many times.

`struct _node* PyParser_SimpleParseFile(FILE *fp, char *filename, int start)'
     Similar to `PyParser_SimpleParseString()', but the Python source
     code is read from FP instead of an in-memory string.  FILENAME
     should be the name of the file.

`PyObject* PyRun_String(char *str, int start, PyObject *globals, PyObject *locals)'
     Execute Python source code from STR in the context specified by
     the dictionaries GLOBALS and LOCALS.  The parameter START
     specifies the start token that should be used to parse the source
     code.

     Returns the result of executing the code as a Python object, or
     `NULL' if an exception was raised.

`PyObject* PyRun_File(FILE *fp, char *filename, int start, PyObject *globals, PyObject *locals)'
     Similar to `PyRun_String()', but the Python source code is read
     from FP instead of an in-memory string.  FILENAME should be the
     name of the file.

`PyObject* Py_CompileString(char *str, char *filename, int start)'
     Parse and compile the Python source code in STR, returning the
     resulting code object.  The start token is given by START; this
     can be used to constrain the code which can be compiled and should
     be `Py_eval_input', `Py_file_input', or `Py_single_input'.  The
     filename specified by FILENAME is used to construct the code
     object and may appear in tracebacks or `SyntaxError' exception
     messages.  This returns `NULL' if the code cannot be parsed or
     compiled.

`int Py_eval_input'
     The start symbol from the Python grammar for isolated expressions;
     for use with `Py_CompileString()' .

`int Py_file_input'
     The start symbol from the Python grammar for sequences of
     statements as read from a file or other source; for use with
     `Py_CompileString()' .  This is the symbol to use when compiling
     arbitrarily long Python source code.

`int Py_single_input'
     The start symbol from the Python grammar for a single statement;
     for use with `Py_CompileString()' .  This is the symbol used for
     the interactive interpreter loop.


File: python-api.info,  Node: Reference Counting,  Next: Exception Handling,  Prev: Very High Level Layer,  Up: Top

Reference Counting
******************

The macros in this section are used for managing reference counts of
Python objects.

`void Py_INCREF(PyObject *o)'
     Increment the reference count for object O.  The object must not
     be `NULL'; if you aren't sure that it isn't `NULL', use
     `Py_XINCREF()'.

`void Py_XINCREF(PyObject *o)'
     Increment the reference count for object O.  The object may be
     `NULL', in which case the macro has no effect.

`void Py_DECREF(PyObject *o)'
     Decrement the reference count for object O.  The object must not
     be `NULL'; if you aren't sure that it isn't `NULL', use
     `Py_XDECREF()'.  If the reference count reaches zero, the object's
     type's deallocation function (which must not be `NULL') is invoked.

     _The deallocation function can cause arbitrary Python code to be
     invoked (e.g. when a class instance with a `__del__()' method is
     deallocated).  While exceptions in such code are not propagated,
     the executed code has free access to all Python global variables.
     This means that any object that is reachable from a global
     variable should be in a consistent state before `Py_DECREF()' is
     invoked.  For example, code to delete an object from a list should
     copy a reference to the deleted object in a temporary variable,
     update the list data structure, and then call `Py_DECREF()' for
     the temporary variable._

`void Py_XDECREF(PyObject *o)'
     Decrement the reference count for object O.  The object may be
     `NULL', in which case the macro has no effect; otherwise the effect
     is the same as for `Py_DECREF()', and the same warning applies.

The following functions or macros are only for use within the
interpreter core: `_Py_Dealloc()', `_Py_ForgetReference()',
`_Py_NewReference()', as well as the global variable `_Py_RefTotal'.


File: python-api.info,  Node: Exception Handling,  Next: Utilities,  Prev: Reference Counting,  Up: Top

Exception Handling
******************

The functions described in this chapter will let you handle and raise
Python exceptions.  It is important to understand some of the basics of
Python exception handling.  It works somewhat like the UNIX `errno'
variable: there is a global indicator (per thread) of the last error
that occurred.  Most functions don't clear this on success, but will
set it to indicate the cause of the error on failure.  Most functions
also return an error indicator, usually `NULL' if they are supposed to
return a pointer, or `-1' if they return an integer (exception: the
`PyArg_*()' functions return `1' for success and `0' for failure).

When a function must fail because some function it called failed, it
generally doesn't set the error indicator; the function it called
already set it.  It is responsible for either handling the error and
clearing the exception or returning after cleaning up any resources it
holds (such as object references or memory allocations); it should
_not_ continue normally if it is not prepared to handle the error.  If
returning due to an error, it is important to indicate to the caller
that an error has been set.  If the error is not handled or carefully
propagated, additional calls into the Python/C API may not behave as
intended and may fail in mysterious ways.

The error indicator consists of three Python objects corresponding to
the Python variables `sys.exc_type', `sys.exc_value' and
`sys.exc_traceback'.  API functions exist to interact with the error
indicator in various ways.  There is a separate error indicator for
each thread.

`void PyErr_Print()'
     Print a standard traceback to `sys.stderr' and clear the error
     indicator.  Call this function only when the error indicator is
     set.  (Otherwise it will cause a fatal error!)

`PyObject* PyErr_Occurred()'
     Test whether the error indicator is set.  If set, return the
     exception _type_ (the first argument to the last call to one of
     the `PyErr_Set*()' functions or to `PyErr_Restore()').  If not
     set, return `NULL'.  You do not own a reference to the return
     value, so you do not need to `Py_DECREF()' it.  _Note:_ Do not
     compare the return value to a specific exception; use
     `PyErr_ExceptionMatches()' instead, shown below.  (The comparison
     could easily fail since the exception may be an instance instead
     of a class, in the case of a class exception, or it may the a
     subclass of the expected exception.)

`int PyErr_ExceptionMatches(PyObject *exc)'
     Equivalent to `PyErr_GivenExceptionMatches(PyErr_Occurred(),
     EXC)'.  This should only be called when an exception is actually
     set; a memory access violation will occur if no exception has been
     raised.

`int PyErr_GivenExceptionMatches(PyObject *given, PyObject *exc)'
     Return true if the GIVEN exception matches the exception in EXC.
     If EXC is a class object, this also returns true when GIVEN is an
     instance of a subclass.  If EXC is a tuple, all exceptions in the
     tuple (and recursively in subtuples) are searched for a match.  If
     GIVEN is `NULL', a memory access violation will occur.

`void PyErr_NormalizeException(PyObject**exc, PyObject**val, PyObject**tb)'
     Under certain circumstances, the values returned by
     `PyErr_Fetch()' below can be "unnormalized", meaning that `*EXC'
     is a class object but `*VAL' is not an instance of the  same
     class.  This function can be used to instantiate the class in that
     case.  If the values are already normalized, nothing happens.  The
     delayed normalization is implemented to improve performance.

`void PyErr_Clear()'
     Clear the error indicator.  If the error indicator is not set,
     there is no effect.

`void PyErr_Fetch(PyObject **ptype, PyObject **pvalue, PyObject **ptraceback)'
     Retrieve the error indicator into three variables whose addresses
     are passed.  If the error indicator is not set, set all three
     variables to `NULL'.  If it is set, it will be cleared and you own
     a reference to each object retrieved.  The value and traceback
     object may be `NULL' even when the type object is not.  _Note:_
     This function is normally only used by code that needs to handle
     exceptions or by code that needs to save and restore the error
     indicator temporarily.

`void PyErr_Restore(PyObject *type, PyObject *value, PyObject *traceback)'
     Set  the error indicator from the three objects.  If the error
     indicator is already set, it is cleared first.  If the objects are
     `NULL', the error indicator is cleared.  Do not pass a `NULL' type
     and non-`NULL' value or traceback.  The exception type should be a
     class.  Do not pass an invalid exception type or value.
     (Violating these rules will cause subtle problems later.)  This
     call takes away a reference to each object: you must own a
     reference to each object before the call and after the call you no
     longer own these references.  (If you don't understand this, don't
     use this function.  I warned you.)  _Note:_ This function is
     normally only used by code that needs to save and restore the
     error indicator temporarily; use `PyErr_Fetch()' to save the
     current exception state.

`void PyErr_SetString(PyObject *type, char *message)'
     This is the most common way to set the error indicator.  The first
     argument specifies the exception type; it is normally one of the
     standard exceptions, e.g. `PyExc_RuntimeError'.  You need not
     increment its reference count.  The second argument is an error
     message; it is converted to a string object.

`void PyErr_SetObject(PyObject *type, PyObject *value)'
     This function is similar to `PyErr_SetString()' but lets you
     specify an arbitrary Python object for the "value" of the
     exception.

`PyObject* PyErr_Format(PyObject *exception, const char *format, ...)'
     This function sets the error indicator and returns `NULL'.
     EXCEPTION should be a Python exception (class, not an instance).
     FORMAT should be a string, containing format codes, similar to
     `printf()'. The `width.precision' before a format code is parsed,
     but the width part is ignored.

     Character                          Meaning
     ------                             -----
     c                                  Character, as an `int' parameter
     d                                  Number in decimal, as an `int'
                                        parameter
     x                                  Number in hexadecimal, as an
                                        `int' parameter
     s                                  A string, as a `char *' parameter
     p                                  A hex pointer, as a `void *'
                                        parameter

     An unrecognized format character causes all the rest of the format
     string to be copied as-is to the result string, and any extra
     arguments discarded.

`void PyErr_SetNone(PyObject *type)'
     This is a shorthand for `PyErr_SetObject(TYPE, Py_None)'.

`int PyErr_BadArgument()'
     This is a shorthand for `PyErr_SetString(PyExc_TypeError,
     MESSAGE)', where MESSAGE indicates that a built-in operation was
     invoked with an illegal argument.  It is mostly for internal use.

`PyObject* PyErr_NoMemory()'
     This is a shorthand for `PyErr_SetNone(PyExc_MemoryError)'; it
     returns `NULL' so an object allocation function can write `return
     PyErr_NoMemory();' when it runs out of memory.

`PyObject* PyErr_SetFromErrno(PyObject *type)'
     This is a convenience function to raise an exception when a C
     library function has returned an error and set the C variable
     `errno'.  It constructs a tuple object whose first item is the
     integer `errno' value and whose second item is the corresponding
     error message (gotten from `strerror()' ), and then calls
     `PyErr_SetObject(TYPE, OBJECT)'.  On UNIX, when the `errno' value
     is `EINTR', indicating an interrupted system call, this calls
     `PyErr_CheckSignals()', and if that set the error indicator,
     leaves it set to that.  The function always returns `NULL', so a
     wrapper function around a system call can write `return
     PyErr_SetFromErrno(TYPE);' when the system call returns an error.

`PyObject* PyErr_SetFromErrnoWithFilename(PyObject *type, char *filename)'
     Similar to `PyErr_SetFromErrno()', with the additional behavior
     that if FILENAME is not `NULL', it is passed to the constructor of
     TYPE as a third parameter.  In the case of exceptions such as
     `IOError' and `OSError', this is used to define the `filename'
     attribute of the exception instance.

`PyObject* PyErr_SetFromWindowsErr(int ierr)'
     This is a convenience function to raise `WindowsError'.  If called
     with IERR of `0', the error code returned by a call to
     `GetLastError()' is used instead.  It calls the Win32 function
     `FormatMessage()' to retrieve the Windows description of error
     code given by IERR or `GetLastError()', then it constructs a tuple
     object whose first item is the IERR value and whose second item is
     the corresponding error message (gotten from `FormatMessage()'),
     and then calls `PyErr_SetObject(PYEXC_WINDOWSERROR, OBJECT)'.
     This function always returns `NULL'.  Availability: Windows.

`PyObject* PyErr_SetExcFromWindowsErr(PyObject *type, int ierr)'
     Similar to `PyErr_SetFromWindowsErr()', with an additional
     parameter specifying the exception type to be raised.
     Availability: Windows.  _Added in Python version 2.3_

`PyObject* PyErr_SetFromWindowsErrWithFilename(int ierr, char *filename)'
     Similar to `PyErr_SetFromWindowsErr()', with the additional
     behavior that if FILENAME is not `NULL', it is passed to the
     constructor of `WindowsError' as a third parameter.  Availability:
     Windows.

`PyObject* PyErr_SetExcFromWindowsErrWithFilename(PyObject *type, int ierr, char *filename)'
     Similar to `PyErr_SetFromWindowsErrWithFilename()', with an
     additional parameter specifying the exception type to be raised.
     Availability: Windows.  _Added in Python version 2.3_

`void PyErr_BadInternalCall()'
     This is a shorthand for `PyErr_SetString(PyExc_TypeError,
     MESSAGE)', where MESSAGE indicates that an internal operation
     (e.g. a Python/C API function) was invoked with an illegal
     argument.  It is mostly for internal use.

`int PyErr_Warn(PyObject *category, char *message)'
     Issue a warning message.  The CATEGORY argument is a warning
     category (see below) or `NULL'; the MESSAGE argument is a message
     string.

     This function normally prints a warning message to SYS.STDERR;
     however, it is also possible that the user has specified that
     warnings are to be turned into errors, and in that case this will
     raise an exception.  It is also possible that the function raises
     an exception because of a problem with the warning machinery (the
     implementation imports the `warnings' module to do the heavy
     lifting).  The return value is `0' if no exception is raised, or
     `-1' if an exception is raised.  (It is not possible to determine
     whether a warning message is actually printed, nor what the reason
     is for the exception; this is intentional.)  If an exception is
     raised, the caller should do its normal exception handling (for
     example, `Py_DECREF()' owned references and return an error value).

     Warning categories must be subclasses of `Warning'; the default
     warning category is `RuntimeWarning'.  The standard Python warning
     categories are available as global variables whose names are
     `PyExc_' followed by the Python exception name.  These have the
     type `PyObject*'; they are all class objects.  Their names are
     `PyExc_Warning', `PyExc_UserWarning', `PyExc_DeprecationWarning',
     `PyExc_SyntaxWarning', `PyExc_RuntimeWarning', and
     `PyExc_FutureWarning'.  `PyExc_Warning' is a subclass of
     `PyExc_Exception'; the other warning categories are subclasses of
     `PyExc_Warning'.

     For information about warning control, see the documentation for
     the `warnings' module and the `-W' option in the command line
     documentation.  There is no C API for warning control.

`int PyErr_WarnExplicit(PyObject *category, char *message, char *filename, int lineno, char *module, PyObject *registry)'
     Issue a warning message with explicit control over all warning
     attributes.  This is a straightforward wrapper around the Python
     function `warnings.warn_explicit()', see there for more
     information.  The MODULE and REGISTRY arguments may be set to
     `NULL' to get the default effect described there.

`int PyErr_CheckSignals()'
     This function interacts with Python's signal handling.  It checks
     whether a signal has been sent to the processes and if so, invokes
     the corresponding signal handler.  If the `signal'  module is
     supported, this can invoke a signal handler written in Python.  In
     all cases, the default effect for `SIGINT'  is to raise the
     `KeyboardInterrupt' exception.  If an exception is raised the
     error indicator is set and the function returns `1'; otherwise the
     function returns `0'.  The error indicator may or may not be
     cleared if it was previously set.

`void PyErr_SetInterrupt()'
     This function is obsolete.  It simulates the effect of a `SIGINT'
     signal arriving -- the next time `PyErr_CheckSignals()' is called,
     `KeyboardInterrupt' will be raised.  It may be called without
     holding the interpreter lock.

`PyObject* PyErr_NewException(char *name, PyObject *base, PyObject *dict)'
     This utility function creates and returns a new exception object.
     The NAME argument must be the name of the new exception, a C
     string of the form `module.class'.  The BASE and DICT arguments
     are normally `NULL'.  This creates a class object derived from the
     root for all exceptions, the built-in name `Exception' (accessible
     in C as `PyExc_Exception').  The `__module__' attribute of the new
     class is set to the first part (up to the last dot) of the NAME
     argument, and the class name is set to the last part (after the
     last dot).  The BASE argument can be used to specify an alternate
     base class.  The DICT argument can be used to specify a dictionary
     of class variables and methods.

`void PyErr_WriteUnraisable(PyObject *obj)'
     This utility function prints a warning message to `sys.stderr'
     when an exception has been set but it is impossible for the
     interpreter to actually raise the exception.  It is used, for
     example, when an exception occurs in an `__del__()' method.

     The function is called with a single argument OBJ that identifies
     where the context in which the unraisable exception occurred.  The
     repr of OBJ will be printed in the warning message.

* Menu:

* Standard Exceptions::
* Deprecation of String Exceptions::

