This is python-ext.info, produced by makeinfo version 4.3 from
python-ext.texi.

October 3, 2003


File: python-ext.info,  Node: NULL Pointers,  Prev: Thin Ice,  Up: Reference Counts

NULL Pointers
-------------

In general, functions that take object references as arguments do not
expect you to pass them `NULL' pointers, and will dump core (or cause
later core dumps) if you do so.  Functions that return object
references generally return `NULL' only to indicate that an exception
occurred.  The reason for not testing for `NULL' arguments is that
functions often pass the objects they receive on to other function --
if each function were to test for `NULL', there would be a lot of
redundant tests and the code would run more slowly.

It is better to test for `NULL' only at the "source:" when a pointer
that may be `NULL' is received, for example, from `malloc()' or from a
function that may raise an exception.

The macros `Py_INCREF()' and `Py_DECREF()' do not check for `NULL'
pointers -- however, their variants `Py_XINCREF()' and `Py_XDECREF()'
do.

The macros for checking for a particular object type (`PyTYPE_Check()')
don't check for `NULL' pointers -- again, there is much code that calls
several of these in a row to test an object against various different
expected types, and this would generate redundant tests.  There are no
variants with `NULL' checking.

The C function calling mechanism guarantees that the argument list
passed to C functions (`args' in the examples) is never `NULL' -- in
fact it guarantees that it is always a tuple.(1)

It is a severe error to ever let a `NULL' pointer "escape" to the
Python user.

---------- Footnotes ----------

(1)  These guarantees don't hold when you use the "old" style calling
convention -- this is still found in much existing code.


File: python-ext.info,  Node: Writing Extensions in C++,  Next: Providing a C API for an Extension Module,  Prev: Reference Counts,  Up: Extending Python with C or C++

Writing Extensions in C++
=========================

It is possible to write extension modules in C++.  Some restrictions
apply.  If the main program (the Python interpreter) is compiled and
linked by the C compiler, global or static objects with constructors
cannot be used.  This is not a problem if the main program is linked by
the C++ compiler.  Functions that will be called by the Python
interpreter (in particular, module initalization functions) have to be
declared using `extern "C"'.  It is unnecessary to enclose the Python
header files in `extern "C" {...}' -- they use this form already if the
symbol `__cplusplus' is defined (all recent C++ compilers define this
symbol).


File: python-ext.info,  Node: Providing a C API for an Extension Module,  Prev: Writing Extensions in C++,  Up: Extending Python with C or C++

Providing a C API for an Extension Module
=========================================

Many extension modules just provide new functions and types to be used
from Python, but sometimes the code in an extension module can be
useful for other extension modules. For example, an extension module
could implement a type "collection" which works like lists without
order. Just like the standard Python list type has a C API which
permits extension modules to create and manipulate lists, this new
collection type should have a set of C functions for direct
manipulation from other extension modules.

At first sight this seems easy: just write the functions (without
declaring them `static', of course), provide an appropriate header
file, and document the C API. And in fact this would work if all
extension modules were always linked statically with the Python
interpreter. When modules are used as shared libraries, however, the
symbols defined in one module may not be visible to another module.
The details of visibility depend on the operating system; some systems
use one global namespace for the Python interpreter and all extension
modules (Windows, for example), whereas others require an explicit list
of imported symbols at module link time (AIX is one example), or offer
a choice of different strategies (most Unices). And even if symbols are
globally visible, the module whose functions one wishes to call might
not have been loaded yet!

Portability therefore requires not to make any assumptions about symbol
visibility. This means that all symbols in extension modules should be
declared `static', except for the module's initialization function, in
order to avoid name clashes with other extension modules (as discussed
in section~*Note Module's Method Table and Initialization Function::).
And it means that symbols that _should_ be accessible from other
extension modules must be exported in a different way.

Python provides a special mechanism to pass C-level information
(pointers) from one extension module to another one: CObjects.  A
CObject is a Python data type which stores a pointer (`void *').
CObjects can only be created and accessed via their C API, but they can
be passed around like any other Python object. In particular, they can
be assigned to a name in an extension module's namespace.  Other
extension modules can then import this module, retrieve the value of
this name, and then retrieve the pointer from the CObject.

There are many ways in which CObjects can be used to export the C API
of an extension module. Each name could get its own CObject, or all C
API pointers could be stored in an array whose address is published in
a CObject. And the various tasks of storing and retrieving the pointers
can be distributed in different ways between the module providing the
code and the client modules.

The following example demonstrates an approach that puts most of the
burden on the writer of the exporting module, which is appropriate for
commonly used library modules. It stores all C API pointers (just one
in the example!) in an array of `void' pointers which becomes the value
of a CObject. The header file corresponding to the module provides a
macro that takes care of importing the module and retrieving its C API
pointers; client modules only have to call this macro before accessing
the C API.

The exporting module is a modification of the `spam' module from
section~*Note A Simple Example::. The function `spam.system()' does not
call the C library function `system()' directly, but a function
`PySpam_System()', which would of course do something more complicated
in reality (such as adding "spam" to every command). This function
`PySpam_System()' is also exported to other extension modules.

The function `PySpam_System()' is a plain C function, declared `static'
like everything else:

     static int
     PySpam_System(char *command)
     {
         return system(command);
     }

The function `spam_system()' is modified in a trivial way:

     static PyObject *
     spam_system(PyObject *self, PyObject *args)
     {
         char *command;
         int sts;
     
         if (!PyArg_ParseTuple(args, "s", &command))
             return NULL;
         sts = PySpam_System(command);
         return Py_BuildValue("i", sts);
     }

In the beginning of the module, right after the line

     #include "Python.h"

two more lines must be added:

     #define SPAM_MODULE
     #include "spammodule.h"

The `#define' is used to tell the header file that it is being included
in the exporting module, not a client module. Finally, the module's
initialization function must take care of initializing the C API
pointer array:

     PyMODINIT_FUNC
     initspam(void)
     {
         PyObject *m;
         static void *PySpam_API[PySpam_API_pointers];
         PyObject *c_api_object;
     
         m = Py_InitModule("spam", SpamMethods);
     
         /* Initialize the C API pointer array */
         PySpam_API[PySpam_System_NUM] = (void *)PySpam_System;
     
         /* Create a CObject containing the API pointer array's address */
         c_api_object = PyCObject_FromVoidPtr((void *)PySpam_API, NULL);
     
         if (c_api_object != NULL)
             PyModule_AddObject(m, "_C_API", c_api_object);
     }

Note that `PySpam_API' is declared `static'; otherwise the pointer
array would disappear when `initspam()' terminates!

The bulk of the work is in the header file `spammodule.h', which looks
like this:

     #ifndef Py_SPAMMODULE_H
     #define Py_SPAMMODULE_H
     #ifdef __cplusplus
     extern "C" {
     #endif
     
     /* Header file for spammodule */
     
     /* C API functions */
     #define PySpam_System_NUM 0
     #define PySpam_System_RETURN int
     #define PySpam_System_PROTO (char *command)
     
     /* Total number of C API pointers */
     #define PySpam_API_pointers 1
     
     #ifdef SPAM_MODULE
     /* This section is used when compiling spammodule.c */
     
     static PySpam_System_RETURN PySpam_System PySpam_System_PROTO;
     
     #else
     /* This section is used in modules that use spammodule's API */
     
     static void **PySpam_API;
     
     #define PySpam_System \
      (*(PySpam_System_RETURN (*)PySpam_System_PROTO) PySpam_API[PySpam_System_NUM])
     
     /* Return -1 and set exception on error, 0 on success. */
     static int
     import_spam(void)
     {
         PyObject *module = PyImport_ImportModule("spam");
     
         if (module != NULL) {
             PyObject *c_api_object = PyObject_GetAttrString(module, "_C_API");
             if (c_api_object == NULL)
                 return -1;
             if (PyCObject_Check(c_api_object))
                 PySpam_API = (void **)PyCObject_AsVoidPtr(c_api_object);
             Py_DECREF(c_api_object);
         }
         return 0;
     }
     
     #endif
     
     #ifdef __cplusplus
     }
     #endif
     
     #endif /* !defined(Py_SPAMMODULE_H) */

All that a client module must do in order to have access to the
function `PySpam_System()' is to call the function (or rather macro)
`import_spam()' in its initialization function:

     PyMODINIT_FUNC
     initclient(void)
     {
         PyObject *m;
     
         Py_InitModule("client", ClientMethods);
         if (import_spam() < 0)
             return;
         /* additional initialization can happen here */
     }

The main disadvantage of this approach is that the file `spammodule.h'
is rather complicated. However, the basic structure is the same for
each function that is exported, so it has to be learned only once.

Finally it should be mentioned that CObjects offer additional
functionality, which is especially useful for memory allocation and
deallocation of the pointer stored in a CObject. The details are
described in the  in the section "CObjects" and in the implementation
of CObjects (files `Include/cobject.h' and `Objects/cobject.c' in the
Python source code distribution).


File: python-ext.info,  Node: Defining New Types,  Next: Building C and C++ Extensions with distutils,  Prev: Extending Python with C or C++,  Up: Top

Defining New Types
******************

As mentioned in the last chapter, Python allows the writer of an
extension module to define new types that can be manipulated from
Python code, much like strings and lists in core Python.

This is not hard; the code for all extension types follows a pattern,
but there are some details that you need to understand before you can
get started.

_Notice:_ The way new types are defined changed dramatically (and for
the better) in Python 2.2.  This document documents how to define new
types for Python 2.2 and later.  If you need to support older versions
of Python, you will need to refer to older versions of this
documentation.

* Menu:

* Basics::
* Type Methods::


File: python-ext.info,  Node: Basics,  Next: Type Methods,  Prev: Defining New Types,  Up: Defining New Types

The Basics
==========

The Python runtime sees all Python objects as variables of type
`PyObject*'.  A `PyObject' is not a very magnificent object - it just
contains the refcount and a pointer to the object's "type object".
This is where the action is; the type object determines which (C)
functions get called when, for instance, an attribute gets looked up on
an object or it is multiplied by another object.  These C functions are
called "type methods" to distinguish them from things like `[].append'
(which we call "object methods").

So, if you want to define a new object type, you need to create a new
type object.

This sort of thing can only be explained by example, so here's a
minimal, but complete, module that defines a new type:

`noddy.c'

Now that's quite a bit to take in at once, but hopefully bits will seem
familiar from the last chapter.

The first bit that will be new is:

     typedef struct {
         PyObject_HEAD
     } noddy_NoddyObject;

This is what a Noddy object will contain--in this case, nothing more
than every Python object contains, namely a refcount and a pointer to a
type object.  These are the fields the `PyObject_HEAD' macro brings in.
The reason for the macro is to standardize the layout and to enable
special debugging fields in debug builds.  Note that there is no
semicolon after the `PyObject_HEAD' macro; one is included in the macro
definition.  Be wary of adding one by accident; it's easy to do from
habit, and your compiler might not complain, but someone else's
probably will!  (On Windows, MSVC is known to call this an error and
refuse to compile the code.)

For contrast, let's take a look at the corresponding definition for
standard Python integers:

     typedef struct {
         PyObject_HEAD
         long ob_ival;
     } PyIntObject;

Moving on, we come to the crunch -- the type object.

     static PyTypeObject noddy_NoddyType = {
         PyObject_HEAD_INIT(NULL)
         0,                         /*ob_size*/
         "noddy.Noddy",             /*tp_name*/
         sizeof(noddy_NoddyObject), /*tp_basicsize*/
         0,                         /*tp_itemsize*/
         0,                         /*tp_dealloc*/
         0,                         /*tp_print*/
         0,                         /*tp_getattr*/
         0,                         /*tp_setattr*/
         0,                         /*tp_compare*/
         0,                         /*tp_repr*/
         0,                         /*tp_as_number*/
         0,                         /*tp_as_sequence*/
         0,                         /*tp_as_mapping*/
         0,                         /*tp_hash */
         0,                         /*tp_call*/
         0,                         /*tp_str*/
         0,                         /*tp_getattro*/
         0,                         /*tp_setattro*/
         0,                         /*tp_as_buffer*/
         Py_TPFLAGS_DEFAULT,        /*tp_flags*/
         "Noddy objects",           /* tp_doc */
     };

Now if you go and look up the definition of `PyTypeObject' in
`object.h' you'll see that it has many more fields that the definition
above.  The remaining fields will be filled with zeros by the C
compiler, and it's common practice to not specify them explicitly
unless you need them.

This is so important that we're going to pick the top of it apart still
further:

         PyObject_HEAD_INIT(NULL)

This line is a bit of a wart; what we'd like to write is:

         PyObject_HEAD_INIT(&PyType_Type)

as the type of a type object is "type", but this isn't strictly
conforming C and some compilers complain.  Fortunately, this member
will be filled in for us by `PyType_Ready()'.

         0,                          /* ob_size */

The `ob_size' field of the header is not used; its presence in the type
structure is a historical artifact that is maintained for binary
compatibility with extension modules compiled for older versions of
Python.  Always set this field to zero.

         "noddy.Noddy",              /* tp_name */

The name of our type.  This will appear in the default textual
representation of our objects and in some error messages, for example:

     >>> "" + noddy.new_noddy()
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: cannot add type "noddy.Noddy" to string

Note that the name is a dotted name that includes both the module name
and the name of the type within the module. The module in this case is
`noddy' and the type is `Noddy', so we set the type name to
`noddy.Noddy'.

         sizeof(noddy_NoddyObject),  /* tp_basicsize */

This is so that Python knows how much memory to allocate when you call
`PyObject_New()'.

         0,                          /* tp_itemsize */

This has to do with variable length objects like lists and strings.
Ignore this for now.

Skipping a number of type methods that we don't provide, we set the
class flags to `Py_TPFLAGS_DEFAULT'.

         Py_TPFLAGS_DEFAULT,        /*tp_flags*/

All types should include this constant in their flags.  It enables all
of the members defined by the current version of Python.

We provide a doc string for the type in `tp_doc'.

         "Noddy objects",           /* tp_doc */

Now we get into the type methods, the things that make your objects
different from the others.  We aren't going to implement any of these
in this version of the module.  We'll expand this example later to have
more interesting behavior.

For now, all we want to be able to do is to create new `Noddy' objects.
To enable object creation, we have to provide a `tp_new'
implementation. In this case, we can just use the default
implementation provided by the API function `PyType_GenericNew()'.
We'd like to just assign this to the `tp_new' slot, but we can't, for
portability sake, On some platforms or compilers, we can't statically
initialize a structure member with a function defined in another C
module, so, instead, we'll assign the `tp_new' slot in the module
initialization function just before calling `PyType_Ready()':

         noddy_NoddyType.tp_new = PyType_GenericNew;
         if (PyType_Ready(&noddy_NoddyType) < 0)
             return;

All the other type methods are `NULL', so we'll go over them later --
that's for a later section!

Everything else in the file should be familiar, except for some code in
`initnoddy()':

         if (PyType_Ready(&noddy_NoddyType) < 0)
             return;

This initializes the `Noddy' type, filing in a number of members,
including `ob_type' that we initially set to `NULL'.

         PyModule_AddObject(m, "Noddy", (PyObject *)&noddy_NoddyType);

This adds the type to the module dictionary.  This allows us to create
`Noddy' instances by calling the `Noddy' class:

     import noddy
     mynoddy = noddy.Noddy()

That's it!  All that remains is to build it; put the above code in a
file called `noddy.c' and

     from distutils.core import setup, Extension
     setup(name="noddy", version="1.0",
           ext_modules=[Extension("noddy", ["noddy.c"])])

in a file called `setup.py'; then typing

     $ python setup.py build

at a shell should produce a file `noddy.so' in a subdirectory; move to
that directory and fire up Python -- you should be able to `import
noddy' and play around with Noddy objects.

That wasn't so hard, was it?

Of course, the current Noddy type is pretty uninteresting. It has no
data and doesn't do anything. It can't even be subclassed.

* Menu:

* Adding data and methods to the Basic example::
* Providing finer control over data attributes::
* Supporting cyclic garbage collection::


File: python-ext.info,  Node: Adding data and methods to the Basic example,  Next: Providing finer control over data attributes,  Prev: Basics,  Up: Basics

Adding data and methods to the Basic example
--------------------------------------------

Let's expend the basic example to add some data and methods.  Let's
also make the type usable as a base class. We'll create a new module,
`noddy2' that adds these capabilities:

`noddy2.c'

This version of the module has a number of changes.

We've added an extra include:

     #include "structmember.h"

This include provides declarations that we use to handle attributes, as
described a bit later.

The name of the `Noddy' object structure has been shortened to `Noddy'.
The type object name has been shortened to `NoddyType'.

The  `Noddy' type now has three data attributes, FIRST, LAST, and
NUMBER.  The FIRST and LAST variables are Python strings containing
first and last names. The NUMBER attribute is an integer.

The object structure is updated accordingly:

     typedef struct {
         PyObject_HEAD
         PyObject *first;
         PyObject *last;
         int number;
     } Noddy;

Because we now have data to manage, we have to be more careful about
object allocation and deallocation.  At a minimum, we need a
deallocation method:

     static void
     Noddy_dealloc(Noddy* self)
     {
         Py_XDECREF(self->first);
         Py_XDECREF(self->last);
         self->ob_type->tp_free((PyObject*)self);
     }

which is assigned to the `tp_dealloc' member:

         (destructor)Noddy_dealloc, /*tp_dealloc*/

This method decrements the reference counts of the two Python
attributes. We use `Py_XDECREF()' here because the `first' and `last'
members could be `NULL'.  It then calls the `tp_free' member of the
object's type to free the object's memory.  Note that the object's type
might not be `NoddyType', because the object may be an instance of a
subclass.

We want to make sure that the first and last names are initialized to
empty strings, so we provide a new method:

     static PyObject *
     Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
     {
         Noddy *self;
     
         self = (Noddy *)type->tp_alloc(type, 0);
         if (self != NULL) {
             self->first = PyString_FromString("");
             if (self->first == NULL)
               {
                 Py_DECREF(self);
                 return NULL;
               }
     
             self->last = PyString_FromString("");
             if (self->last == NULL)
               {
                 Py_DECREF(self);
                 return NULL;
               }
     
             self->number = 0;
         }
     
         return (PyObject *)self;
     }

and install it in the `tp_new' member:

         Noddy_new,                 /* tp_new */

The new member is responsible for creating (as opposed to initializing)
objects of the type.  It is exposed in Python as the `__new__()'
method.  See the paper titled "Unifying types and classes in Python"
for a detailed discussion of the `__new__()' method.  One reason to
implement a new method is to assure the initial values of instance
variables.  In this case, we use the new method to make sure that the
initial values of the members `first' and `last' are not `NULL'. If we
didn't care whether the initial values were `NULL', we could have used
`PyType_GenericNew()' as our new method, as we did before.
`PyType_GenericNew()' initializes all of the instance variable members
to NULLs.

The new method is a static method that is passed the type being
instantiated and any arguments passed when the type was called, and
that returns the new object created. New methods always accept
positional and keyword arguments, but they often ignore the arguments,
leaving the argument handling to initializer methods. Note that if the
type supports subclassing, the type passed may not be the type being
defined.  The new method calls the tp_alloc slot to allocate memory.
We don't fill the `tp_alloc' slot ourselves. Rather `PyType_Ready()'
fills it for us by inheriting it from our base class, which is `object'
by default.  Most types use the default allocation.

We provide an initialization function:

     static int
     Noddy_init(Noddy *self, PyObject *args, PyObject *kwds)
     {
         PyObject *first=NULL, *last=NULL;
     
         static char *kwlist[] = {"first", "last", "number", NULL};
     
         if (! PyArg_ParseTupleAndKeywords(args, kwds, "|OOi", kwlist,
                                           &first, &last,
                                           &self->number))
             return -1;
     
         if (first) {
             Py_XDECREF(self->first);
             Py_INCREF(first);
             self->first = first;
         }
     
         if (last) {
             Py_XDECREF(self->last);
             Py_INCREF(last);
             self->last = last;
         }
     
         return 0;
     }

by filling the `tp_init' slot.

         (initproc)Noddy_init,         /* tp_init */

The `tp_init' slot is exposed in Python as the `__init__()' method. It
is used to initialize an object after it's created. Unlike the new
method, we can't guarantee that the initializer is called.  The
initializer isn't called when unpickling objects and it can be
overridden.  Our initializer accepts arguments to provide initial
values for our instance. Initializers always accept positional and
keyword arguments.

We want to want to expose our instance variables as attributes. There
are a number of ways to do that. The simplest way is to define member
definitions:

     static PyMemberDef Noddy_members[] = {
         {"first", T_OBJECT_EX, offsetof(Noddy, first), 0,
          "first name"},
         {"last", T_OBJECT_EX, offsetof(Noddy, last), 0,
          "last name"},
         {"number", T_INT, offsetof(Noddy, number), 0,
          "noddy number"},
         {NULL}  /* Sentinel */
     };

and put the definitions in the `tp_members' slot:

         Noddy_members,             /* tp_members */

Each member definition has a member name, type, offset, access flags
and documentation string. See the "Generic Attribute Management"
section below for details.

A disadvantage of this approach is that it doesn't provide a way to
restrict the types of objects that can be assigned to the Python
attributes.  We expect the first and last names to be strings, but any
Python objects can be assigned.  Further, the attributes can be
deleted, setting the C pointers to `NULL'.  Even though we can make
sure the members are initialized to non-`NULL' values, the members can
be set to `NULL' if the attributes are deleted.

We define a single method, `name', that outputs the objects name as the
concatenation of the first and last names.

     static PyObject *
     Noddy_name(Noddy* self)
     {
         static PyObject *format = NULL;
         PyObject *args, *result;
     
         if (format == NULL) {
             format = PyString_FromString("%s %s");
             if (format == NULL)
                 return NULL;
         }
     
         if (self->first == NULL) {
             PyErr_SetString(PyExc_AttributeError, "first");
             return NULL;
         }
     
         if (self->last == NULL) {
             PyErr_SetString(PyExc_AttributeError, "last");
             return NULL;
         }
     
         args = Py_BuildValue("OO", self->first, self->last);
         if (args == NULL)
             return NULL;
     
         result = PyString_Format(format, args);
         Py_DECREF(args);
     
         return result;
     }

The method is implemented as a C function that takes a `Noddy' (or
`Noddy' subclass) instance as the first argument.  Methods always take
an instance as the first argument. Methods often take positional and
keyword arguments as well, but in this cased we don't take any and
don't need to accept a positional argument tuple or keyword argument
dictionary. This method is equivalent to the Python method:

         def name(self):
            return "%s %s" % (self.first, self.last)

Note that we have to check for the possibility that our `first' and
`last' members are `NULL'.  This is because they can be deleted, in
which case they are set to `NULL'.  It would be better to prevent
deletion of these attributes and to restrict the attribute values to be
strings.  We'll see how to do that in the next section.

Now that we've defined the method, we need to create an array of method
definitions:

     static PyMethodDef Noddy_methods[] = {
         {"name", (PyCFunction)Noddy_name, METH_NOARGS,
          "Return the name, combining the first and last name"
         },
         {NULL}  /* Sentinel */
     };

and assign them to the `tp_methods' slot:

         Noddy_methods,             /* tp_methods */

Note that used the `METH_NOARGS' flag to indicate that the method is
passed no arguments.

Finally, we'll make our type usable as a base class.  We've written our
methods carefully so far so that they don't make any assumptions about
the type of the object being created or used, so all we need to do is
to add the `Py_TPFLAGS_BASETYPE' to our class flag definition:

         Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/

We rename `initnoddy()' to `initnoddy2()' and update the module name
passed to `Py_InitModule3()'.

Finally, we update our `setup.py' file to build the new module:

     from distutils.core import setup, Extension
     setup(name="noddy", version="1.0",
           ext_modules=[
              Extension("noddy", ["noddy.c"]),
              Extension("noddy2", ["noddy2.c"]),
              ])


File: python-ext.info,  Node: Providing finer control over data attributes,  Next: Supporting cyclic garbage collection,  Prev: Adding data and methods to the Basic example,  Up: Basics

Providing finer control over data attributes
--------------------------------------------

In this section, we'll provide finer control over how the `first' and
`last' attributes are set in the `Noddy' example. In the previous
version of our module, the instance variables `first' and `last' could
be set to non-string values or even deleted. We want to make sure that
these attributes always contain strings.

`noddy3.c'

To provide greater control, over the `first' and `last' attributes,
we'll use custom getter and setter functions.  Here are the functions
for getting and setting the `first' attribute:

     Noddy_getfirst(Noddy *self, void *closure)
     {
         Py_INCREF(self->first);
         return self->first;
     }
     
     static int
     Noddy_setfirst(Noddy *self, PyObject *value, void *closure)
     {
       if (value == NULL) {
         PyErr_SetString(PyExc_TypeError, "Cannot delete the first attribute");
         return -1;
       }
     
       if (! PyString_Check(value)) {
         PyErr_SetString(PyExc_TypeError,
                         "The first attribute value must be a string");
         return -1;
       }
     
       Py_DECREF(self->first);
       Py_INCREF(value);
       self->first = value;
     
       return 0;
     }

The getter function is passed a `Noddy' object and a "closure", which
is void pointer. In this case, the closure is ignored. (The closure
supports an advanced usage in which definition data is passed to the
getter and setter. This could, for example, be used to allow a single
set of getter and setter functions that decide the attribute to get or
set based on data in the closure.)

The setter function is passed the `Noddy' object, the new value, and
the closure. The new value may be `NULL', in which case the attribute
is being deleted.  In our setter, we raise an error if the attribute is
deleted or if the attribute value is not a string.

We create an array of `PyGetSetDef' structures:

     static PyGetSetDef Noddy_getseters[] = {
         {"first",
          (getter)Noddy_getfirst, (setter)Noddy_setfirst,
          "first name",
          NULL},
         {"last",
          (getter)Noddy_getlast, (setter)Noddy_setlast,
          "last name",
          NULL},
         {NULL}  /* Sentinel */
     };

and register it in the `tp_getset' slot:

         Noddy_getseters,           /* tp_getset */

to register out attribute getters and setters.

The last item in a `PyGetSetDef' structure is the closure mentioned
above. In this case, we aren't using the closure, so we just pass
`NULL'.

We also remove the member definitions for these attributes:

     static PyMemberDef Noddy_members[] = {
         {"number", T_INT, offsetof(Noddy, number), 0,
          "noddy number"},
         {NULL}  /* Sentinel */
     };

With these changes, we can assure that the `first' and `last' members
are never NULL so we can remove checks for `NULL' values in almost all
cases. This means that most of the `Py_XDECREF()' calls can be
converted to `Py_DECREF()' calls. The only place we can't change these
calls is in the deallocator, where there is the possibility that the
initialization of these members failed in the constructor.

We also rename the module initialization function and module name in
the initialization function, as we did before, and we add an extra
definition to the `setup.py' file.


File: python-ext.info,  Node: Supporting cyclic garbage collection,  Prev: Providing finer control over data attributes,  Up: Basics

Supporting cyclic garbage collection
------------------------------------

Python has a cyclic-garbage collector that can identify unneeded
objects even when their reference counts are not zero. This can happen
when objects are involved in cycles.  For example, consider:

     >>> l = []
     >>> l.append(l)
     >>> del l

In this example, we create a list that contains itself. When we delete
it, it still has a reference from itself. It's reference count doesn't
drop to zero.  Fortunately, Python's cyclic-garbage collector will
eventually figure out that that the list is garbage and free it.

In the second version of the `Noddy' example, we allowed any kind of
object to be stored in the `first' or `last' attributes. This means
that `Noddy' objects can participate in cycles:

     >>> import noddy2
     >>> n = noddy2.Noddy()
     >>> l = [n]
     >>> n.first = l

This is pretty silly, but it gives us an excuse to add support for the
cyclic-garbage collector to the `Noddy' example.  To support cyclic
garbage collection, types need to fill two slots and set a class flag
that enables these slots:

`noddy4.c'

The traversal method provides access to subobjects that could
participate in cycles:

     static int
     Noddy_traverse(Noddy *self, visitproc visit, void *arg)
     {
         if (self->first && visit(self->first, arg) < 0)
             return -1;
         if (self->last && visit(self->last, arg) < 0)
             return -1;
     
         return 0;
     }

For each subobject that can participate in cycles, we need to call the
`visit()' function, which is passed to the traversal method.  The
`visit()' function takes as arguments the subobject and the extra
argument ARG passed to the traversal method.

We also need to provide a method for clearing any subobjects that can
participate in cycles.  We implement the method and reimplement the
deallocator to use it:

     static int
     Noddy_clear(Noddy *self)
     {
         Py_XDECREF(self->first);
         self->first = NULL;
         Py_XDECREF(self->last);
         self->last = NULL;
     
         return 0;
     }
     
     static void
     Noddy_dealloc(Noddy* self)
     {
         Noddy_clear(self);
         self->ob_type->tp_free((PyObject*)self);
     }

Finally, we add the `Py_TPFLAGS_HAVE_GC' flag to the class flags:

         Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /*tp_flags*/

That's pretty much it.  If we had written custom `tp_alloc' or
`tp_free' slots, we'd need to modify them for cyclic-garbage
collection. Most extensions will use the versions automatically
provided.


File: python-ext.info,  Node: Type Methods,  Prev: Basics,  Up: Defining New Types

Type Methods
============

This section aims to give a quick fly-by on the various type methods
you can implement and what they do.

Here is the definition of `PyTypeObject', with some fields only used in
debug builds omitted:

`typestruct.h'

Now that's a _lot_ of methods.  Don't worry too much though - if you
have a type you want to define, the chances are very good that you will
only implement a handful of these.

As you probably expect by now, we're going to go over this and give
more information about the various handlers.  We won't go in the order
they are defined in the structure, because there is a lot of historical
baggage that impacts the ordering of the fields; be sure your type
initializaion keeps the fields in the right order!  It's often easiest
to find an example that includes all the fields you need (even if
they're initialized to `0') and then change the values to suit your new
type.

         char *tp_name; /* For printing */

The name of the type - as mentioned in the last section, this will
appear in various places, almost entirely for diagnostic purposes.  Try
to choose something that will be helpful in such a situation!

         int tp_basicsize, tp_itemsize; /* For allocation */

These fields tell the runtime how much memory to allocate when new
objects of this type are created.  Python has some builtin support for
variable length structures (think: strings, lists) which is where the
`tp_itemsize' field comes in.  This will be dealt with later.

         char *tp_doc;

Here you can put a string (or its address) that you want returned when
the Python script references `obj.__doc__' to retrieve the docstring.

Now we come to the basic type methods--the ones most extension types
will implement.

* Menu:

* Finalization and De-allocation::
* Object Presentation::
* Attribute Management::
* Object Comparison::
* Abstract Protocol Support::
* More Suggestions::


File: python-ext.info,  Node: Finalization and De-allocation,  Next: Object Presentation,  Prev: Type Methods,  Up: Type Methods

Finalization and De-allocation
------------------------------

         destructor tp_dealloc;

This function is called when the reference count of the instance of
your type is reduced to zero and the Python interpreter wants to
reclaim it.  If your type has memory to free or other clean-up to
perform, put it here.  The object itself needs to be freed here as
well.  Here is an example of this function:

     static void
     newdatatype_dealloc(newdatatypeobject * obj)
     {
         free(obj->obj_UnderlyingDatatypePtr);
         obj->ob_type->tp_free(obj);
     }

One important requirement of the deallocator function is that it leaves
any pending exceptions alone.  This is important since deallocators are
frequently called as the interpreter unwinds the Python stack; when the
stack is unwound due to an exception (rather than normal returns),
nothing is done to protect the deallocators from seeing that an
exception has already been set.  Any actions which a deallocator
performs which may cause additional Python code to be executed may
detect that an exception has been set.  This can lead to misleading
errors from the interpreter.  The proper way to protect against this is
to save a pending exception before performing the unsafe action, and
restoring it when done.  This can be done using the `PyErr_Fetch()'  and
`PyErr_Restore()'  functions:

     static void
     my_dealloc(PyObject *obj)
     {
         MyObject *self = (MyObject *) obj;
         PyObject *cbresult;
     
         if (self->my_callback != NULL) {
             PyObject *err_type, *err_value, *err_traceback;
             int have_error = PyErr_Occurred() ? 1 : 0;
     
             if (have_error)
                 PyErr_Fetch(&err_type, &err_value, &err_traceback);
     
             cbresult = PyObject_CallObject(self->my_callback, NULL);
             if (cbresult == NULL)
                 PyErr_WriteUnraisable();
             else
                 Py_DECREF(cbresult);
     
             if (have_error)
                 PyErr_Restore(err_type, err_value, err_traceback);
     
             Py_DECREF(self->my_callback);
         }
         obj->ob_type->tp_free((PyObject*)self);
     }


File: python-ext.info,  Node: Object Presentation,  Next: Attribute Management,  Prev: Finalization and De-allocation,  Up: Type Methods

Object Presentation
-------------------

In Python, there are three ways to generate a textual representation of
an object: the `repr()'  function (or equivalent backtick syntax), the
`str()' function, and the `print' statement.  For most objects, the
`print' statement is equivalent to the `str()' function, but it is
possible to special-case printing to a `FILE*' if necessary; this
should only be done if efficiency is identified as a problem and
profiling suggests that creating a temporary string object to be
written to a file is too expensive.

These handlers are all optional, and most types at most need to
implement the `tp_str' and `tp_repr' handlers.

         reprfunc tp_repr;
         reprfunc tp_str;
         printfunc tp_print;

The `tp_repr' handler should return a string object containing a
representation of the instance for which it is called.  Here is a
simple example:

     static PyObject *
     newdatatype_repr(newdatatypeobject * obj)
     {
         return PyString_FromFormat("Repr-ified_newdatatype{{size:\%d}}",
                                    obj->obj_UnderlyingDatatypePtr->size);
     }

If no `tp_repr' handler is specified, the interpreter will supply a
representation that uses the type's `tp_name' and a
uniquely-identifying value for the object.

The `tp_str' handler is to `str()' what the `tp_repr' handler described
above is to `repr()'; that is, it is called when Python code calls
`str()' on an instance of your object.  Its implementation is very
similar to the `tp_repr' function, but the resulting string is intended
for human consumption.  If `tp_str' is not specified, the `tp_repr'
handler is used instead.

Here is a simple example:

     static PyObject *
     newdatatype_str(newdatatypeobject * obj)
     {
         return PyString_FromFormat("Stringified_newdatatype{{size:\%d}}",
                                    obj->obj_UnderlyingDatatypePtr->size);
     }

The print function will be called whenever Python needs to "print" an
instance of the type.  For example, if 'node' is an instance of type
TreeNode, then the print function is called when Python code calls:

     print node

There is a flags argument and one flag, `Py_PRINT_RAW', and it suggests
that you print without string quotes and possibly without interpreting
escape sequences.

The print function receives a file object as an argument. You will
likely want to write to that file object.

Here is a sampe print function:

     static int
     newdatatype_print(newdatatypeobject *obj, FILE *fp, int flags)
     {
         if (flags & Py_PRINT_RAW) {
             fprintf(fp, "<{newdatatype object--size: %d}>",
                     obj->obj_UnderlyingDatatypePtr->size);
         }
         else {
             fprintf(fp, "\"<{newdatatype object--size: %d}>\"",
                     obj->obj_UnderlyingDatatypePtr->size);
         }
         return 0;
     }


File: python-ext.info,  Node: Attribute Management,  Next: Object Comparison,  Prev: Object Presentation,  Up: Type Methods

Attribute Management
--------------------

For every object which can support attributes, the corresponding type
must provide the functions that control how the attributes are
resolved.  There needs to be a function which can retrieve attributes
(if any are defined), and another to set attributes (if setting
attributes is allowed).  Removing an attribute is a special case, for
which the new value passed to the handler is `NULL'.

Python supports two pairs of attribute handlers; a type that supports
attributes only needs to implement the functions for one pair.  The
difference is that one pair takes the name of the attribute as a
`char*', while the other accepts a `PyObject*'.  Each type can use
whichever pair makes more sense for the implementation's convenience.

         getattrfunc  tp_getattr;        /* char * version */
         setattrfunc  tp_setattr;
         /* ... */
         getattrofunc tp_getattrofunc;   /* PyObject * version */
         setattrofunc tp_setattrofunc;

If accessing attributes of an object is always a simple operation (this
will be explained shortly), there are generic implementations which can
be used to provide the `PyObject*' version of the attribute management
functions.  The actual need for type-specific attribute handlers almost
completely disappeared starting with Python 2.2, though there are many
examples which have not been updated to use some of the new generic
mechanism that is available.

* Menu:

* Generic Attribute Management::
* Type-specific Attribute Management::


File: python-ext.info,  Node: Generic Attribute Management,  Next: Type-specific Attribute Management,  Prev: Attribute Management,  Up: Attribute Management

Generic Attribute Management
............................

_Added in Python version 2.2_

Most extension types only use _simple_ attributes.  So, what makes the
attributes simple?  There are only a couple of conditions that must be
met:

  1. The name of the attributes must be known when `PyType_Ready()' is
     called.

  2. No special processing is needed to record that an attribute was
     looked up or set, nor do actions need to be taken based on the
     value.

Note that this list does not place any restrictions on the values of
the attributes, when the values are computed, or how relevant data is
stored.

When `PyType_Ready()' is called, it uses three tables referenced by the
type object to create _descriptors_ which are placed in the dictionary
of the type object.  Each descriptor controls access to one attribute
of the instance object.  Each of the tables is optional; if all three
are `NULL', instances of the type will only have attributes that are
inherited from their base type, and should leave the `tp_getattro' and
`tp_setattro' fields `NULL' as well, allowing the base type to handle
attributes.

The tables are declared as three fields of the type object:

         struct PyMethodDef *tp_methods;
         struct PyMemberDef *tp_members;
         struct PyGetSetDef *tp_getset;

If `tp_methods' is not `NULL', it must refer to an array of
`PyMethodDef' structures.  Each entry in the table is an instance of
this structure:

     typedef struct PyMethodDef {
         char        *ml_name;       /* method name */
         PyCFunction  ml_meth;       /* implementation function */
         int	         ml_flags;      /* flags */
         char        *ml_doc;        /* docstring */
     } PyMethodDef;

One entry should be defined for each method provided by the type; no
entries are needed for methods inherited from a base type.  One
additional entry is needed at the end; it is a sentinel that marks the
end of the array.  The `ml_name' field of the sentinel must be `NULL'.

XXX Need to refer to some unified discussion of the structure fields,
shared with the next section.

The second table is used to define attributes which map directly to
data stored in the instance.  A variety of primitive C types are
supported, and access may be read-only or read-write.  The structures
in the table are defined as:

     typedef struct PyMemberDef {
         char *name;
         int   type;
         int   offset;
         int   flags;
         char *doc;
     } PyMemberDef;

For each entry in the table, a descriptor will be constructed and added
to the type which will be able to extract a value from the instance
structure.  The `type' field should contain one of the type codes
defined in the `structmember.h' header; the value will be used to
determine how to convert Python values to and from C values.  The
`flags' field is used to store flags which control how the attribute
can be accessed.

XXX Need to move some of this to a shared section!

The following flag constants are defined in `structmember.h'; they may
be combined using bitwise-OR.

Constant                             Meaning
------                               -----
READONLY                             Never writable.
RO                                   Shorthand for `READONLY'.
READ_RESTRICTED                      Not readable in restricted mode.
WRITE_RESTRICTED                     Not writable in restricted mode.
RESTRICTED                           Not readable or writable in
                                     restricted mode.

An interesting advantage of using the `tp_members' table to build
descriptors that are used at runtime is that any attribute defined this
way can have an associated docstring simply by providing the text in
the table.  An application can use the introspection API to retrieve
the descriptor from the class object, and get the docstring using its
`__doc__' attribute.

As with the `tp_methods' table, a sentinel entry with a `name' value of
`NULL' is required.

