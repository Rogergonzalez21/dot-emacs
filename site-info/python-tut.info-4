This is python-tut.info, produced by makeinfo version 4.3 from
python-tut.texi.

October 3, 2003


File: python-tut.info,  Node: Random Remarks,  Next: Inheritance,  Prev: A First Look at Classes,  Up: Classes

Random Remarks
==============

[These should perhaps be placed more carefully...]

Data attributes override method attributes with the same name; to avoid
accidental name conflicts, which may cause hard-to-find bugs in large
programs, it is wise to use some kind of convention that minimizes the
chance of conflicts.  Possible conventions include capitalizing method
names, prefixing data attribute names with a small unique string
(perhaps just an underscore), or using verbs for methods and nouns for
data attributes.

Data attributes may be referenced by methods as well as by ordinary
users ("clients") of an object.  In other words, classes are not usable
to implement pure abstract data types.  In fact, nothing in Python
makes it possible to enforce data hiding -- it is all based upon
convention.  (On the other hand, the Python implementation, written in
C, can completely hide implementation details and control access to an
object if necessary; this can be used by extensions to Python written
in C.)

Clients should use data attributes with care -- clients may mess up
invariants maintained by the methods by stamping on their data
attributes.  Note that clients may add data attributes of their own to
an instance object without affecting the validity of the methods, as
long as name conflicts are avoided -- again, a naming convention can
save a lot of headaches here.

There is no shorthand for referencing data attributes (or other
methods!) from within methods.  I find that this actually increases the
readability of methods: there is no chance of confusing local variables
and instance variables when glancing through a method.

Conventionally, the first argument of methods is often called `self'.
This is nothing more than a convention: the name `self' has absolutely
no special meaning to Python.  (Note, however, that by not following
the convention your code may be less readable by other Python
programmers, and it is also conceivable that a _class browser_ program
be written which relies upon such a convention.)

Any function object that is a class attribute defines a method for
instances of that class.  It is not necessary that the function
definition is textually enclosed in the class definition: assigning a
function object to a local variable in the class is also ok.  For
example:

     # Function defined outside the class
     def f1(self, x, y):
         return min(x, x+y)
     
     class C:
         f = f1
         def g(self):
             return 'hello world'
         h = g

Now `f', `g' and `h' are all attributes of class `C' that refer to
function objects, and consequently they are all methods of instances of
`C' -- `h' being exactly equivalent to `g'.  Note that this practice
usually only serves to confuse the reader of a program.

Methods may call other methods by using method attributes of the `self'
argument:

     class Bag:
         def __init__(self):
             self.data = []
         def add(self, x):
             self.data.append(x)
         def addtwice(self, x):
             self.add(x)
             self.add(x)

Methods may reference global names in the same way as ordinary
functions.  The global scope associated with a method is the module
containing the class definition.  (The class itself is never used as a
global scope!)  While one rarely encounters a good reason for using
global data in a method, there are many legitimate uses of the global
scope: for one thing, functions and modules imported into the global
scope can be used by methods, as well as functions and classes defined
in it.  Usually, the class containing the method is itself defined in
this global scope, and in the next section we'll find some good reasons
why a method would want to reference its own class!


File: python-tut.info,  Node: Inheritance,  Next: Private Variables,  Prev: Random Remarks,  Up: Classes

Inheritance
===========

Of course, a language feature would not be worthy of the name "class"
without supporting inheritance.  The syntax for a derived class
definition looks as follows:

     class DerivedClassName(BaseClassName):
         <statement-1>
         .
         .
         .
         <statement-N>

The name `BaseClassName' must be defined in a scope containing the
derived class definition.  Instead of a base class name, an expression
is also allowed.  This is useful when the base class is defined in
another module,

     class DerivedClassName(modname.BaseClassName):

Execution of a derived class definition proceeds the same as for a base
class.  When the class object is constructed, the base class is
remembered.  This is used for resolving attribute references: if a
requested attribute is not found in the class, it is searched in the
base class.  This rule is applied recursively if the base class itself
is derived from some other class.

There's nothing special about instantiation of derived classes:
`DerivedClassName()' creates a new instance of the class.  Method
references are resolved as follows: the corresponding class attribute
is searched, descending down the chain of base classes if necessary,
and the method reference is valid if this yields a function object.

Derived classes may override methods of their base classes.  Because
methods have no special privileges when calling other methods of the
same object, a method of a base class that calls another method defined
in the same base class, may in fact end up calling a method of a
derived class that overrides it.  (For C++ programmers: all methods in
Python are effectively `virtual'.)

An overriding method in a derived class may in fact want to extend
rather than simply replace the base class method of the same name.
There is a simple way to call the base class method directly: just call
`BaseClassName.methodname(self, arguments)'.  This is occasionally
useful to clients as well.  (Note that this only works if the base
class is defined or imported directly in the global scope.)

* Menu:

* Multiple Inheritance::


File: python-tut.info,  Node: Multiple Inheritance,  Prev: Inheritance,  Up: Inheritance

Multiple Inheritance
--------------------

Python supports a limited form of multiple inheritance as well.  A
class definition with multiple base classes looks as follows:

     class DerivedClassName(Base1, Base2, Base3):
         <statement-1>
         .
         .
         .
         <statement-N>

The only rule necessary to explain the semantics is the resolution rule
used for class attribute references.  This is depth-first,
left-to-right.  Thus, if an attribute is not found in
`DerivedClassName', it is searched in `Base1', then (recursively) in
the base classes of `Base1', and only if it is not found there, it is
searched in `Base2', and so on.

(To some people breadth first -- searching `Base2' and `Base3' before
the base classes of `Base1' -- looks more natural.  However, this would
require you to know whether a particular attribute of `Base1' is
actually defined in `Base1' or in one of its base classes before you
can figure out the consequences of a name conflict with an attribute of
`Base2'.  The depth-first rule makes no differences between direct and
inherited attributes of `Base1'.)

It is clear that indiscriminate use of multiple inheritance is a
maintenance nightmare, given the reliance in Python on conventions to
avoid accidental name conflicts.  A well-known problem with multiple
inheritance is a class derived from two classes that happen to have a
common base class.  While it is easy enough to figure out what happens
in this case (the instance will have a single copy of "instance
variables" or data attributes used by the common base class), it is not
clear that these semantics are in any way useful.


File: python-tut.info,  Node: Private Variables,  Next: Odds and Ends,  Prev: Inheritance,  Up: Classes

Private Variables
=================

There is limited support for class-private identifiers.  Any identifier
of the form `__spam' (at least two leading underscores, at most one
trailing underscore) is now textually replaced with `_classname__spam',
where `classname' is the current class name with leading underscore(s)
stripped.  This mangling is done without regard of the syntactic
position of the identifier, so it can be used to define class-private
instance and class variables, methods, as well as globals, and even to
store instance variables private to this class on instances of _other_
classes.  Truncation may occur when the mangled name would be longer
than 255 characters.  Outside classes, or when the class name consists
of only underscores, no mangling occurs.

Name mangling is intended to give classes an easy way to define
"private" instance variables and methods, without having to worry about
instance variables defined by derived classes, or mucking with instance
variables by code outside the class.  Note that the mangling rules are
designed mostly to avoid accidents; it still is possible for a
determined soul to access or modify a variable that is considered
private.  This can even be useful in special circumstances, such as in
the debugger, and that's one reason why this loophole is not closed.
(Buglet: derivation of a class with the same name as the base class
makes use of private variables of the base class possible.)

Notice that code passed to `exec', `eval()' or `evalfile()' does not
consider the classname of the invoking class to be the current class;
this is similar to the effect of the `global' statement, the effect of
which is likewise restricted to code that is byte-compiled together.
The same restriction applies to `getattr()', `setattr()' and
`delattr()', as well as when referencing `__dict__' directly.


File: python-tut.info,  Node: Odds and Ends,  Next: Exceptions Are Classes Too,  Prev: Private Variables,  Up: Classes

Odds and Ends
=============

Sometimes it is useful to have a data type similar to the Pascal
"record" or C "struct", bundling together a couple of named data items.
An empty class definition will do nicely:

     class Employee:
         pass
     
     john = Employee() # Create an empty employee record
     
     # Fill the fields of the record
     john.name = 'John Doe'
     john.dept = 'computer lab'
     john.salary = 1000

A piece of Python code that expects a particular abstract data type can
often be passed a class that emulates the methods of that data type
instead.  For instance, if you have a function that formats some data
from a file object, you can define a class with methods `read()' and
`readline()' that gets the data from a string buffer instead, and pass
it as an argument.

Instance method objects have attributes, too: `m.im_self' is the object
of which the method is an instance, and `m.im_func' is the function
object corresponding to the method.


File: python-tut.info,  Node: Exceptions Are Classes Too,  Next: Iterators,  Prev: Odds and Ends,  Up: Classes

Exceptions Are Classes Too
==========================

User-defined exceptions are identified by classes as well.  Using this
mechanism it is possible to create extensible hierarchies of exceptions.

There are two new valid (semantic) forms for the raise statement:

     raise Class, instance
     
     raise instance

In the first form, `instance' must be an instance of `Class' or of a
class derived from it.  The second form is a shorthand for:

     raise instance.__class__, instance

A class in an except clause is compatible with an exception if it is
the same class or a base class thereof (but not the other way around --
an except clause listing a derived class is not compatible with a base
class).  For example, the following code will print B, C, D in that
order:

     class B:
         pass
     class C(B):
         pass
     class D(C):
         pass
     
     for c in [B, C, D]:
         try:
             raise c()
         except D:
             print "D"
         except C:
             print "C"
         except B:
             print "B"

Note that if the except clauses were reversed (with `except B' first),
it would have printed B, B, B -- the first matching except clause is
triggered.

When an error message is printed for an unhandled exception which is a
class, the class name is printed, then a colon and a space, and finally
the instance converted to a string using the built-in function `str()'.


File: python-tut.info,  Node: Iterators,  Next: Generators,  Prev: Exceptions Are Classes Too,  Up: Classes

Iterators
=========

By now, you've probably noticed that most container objects can looped
over using a `for' statement:

     for element in [1, 2, 3]:
         print element
     for element in (1, 2, 3):
         print element
     for key in {'one':1, 'two':2}:
         print key
     for char in "123":
         print char
     for line in open("myfile.txt"):
         print line

This style of access is clear, concise, and convenient.  The use of
iterators pervades and unifies Python.  Behind the scenes, the `for'
statement calls `iter()' on the container object.  The function returns
an iterator object that defines the method `next()' which accesses
elements in the container one at a time.  When there are no more
elements, `next()' raises a `StopIteration' exception which tells the
`for' loop to terminate.  This example shows how it all works:

     >>> s = 'abc'
     >>> it = iter(s)
     >>> it
     <iterator object at 0x00A1DB50>
     >>> it.next()
     'a'
     >>> it.next()
     'b'
     >>> it.next()
     'c'
     >>> it.next()
     
     Traceback (most recent call last):
       File "<pyshell#6>", line 1, in -toplevel-
         it.next()
     StopIteration

Having seen the mechanics behind the iterator protocol, it is easy to
add iterator behavior to your classes.  Define a `__iter__()' method
which returns an object with a `next()' method.  If the class defines
`next()', then `__iter__()' can just return `self':

     >>> class Reverse:
         "Iterator for looping over a sequence backwards"
         def __init__(self, data):
             self.data = data
             self.index = len(data)
         def __iter__(self):
             return self
         def next(self):
             if self.index == 0:
                 raise StopIteration
             self.index = self.index - 1
             return self.data[self.index]
     
     >>> for char in Reverse('spam'):
     	print char
     
     m
     a
     p
     s


File: python-tut.info,  Node: Generators,  Prev: Iterators,  Up: Classes

Generators
==========

Generators are a simple and powerful tool for creating iterators.  They
are written like regular functions but use the `yield' statement
whenever they want to return data.  Each time the `next()' is called,
the generator resumes where it left-off (it remembers all the data
values and which statement was last executed).  An example shows that
generators can be trivially easy to create:

     >>> def reverse(data):
     	for index in range(len(data)-1, -1, -1):
     		yield data[index]
     
     >>> for char in reverse('golf'):
     	print char
     
     f
     l
     o
     g

Anything that can be done with generators can also be done with class
based iterators as described in the previous section.  What makes
generators so compact is that the `__iter__()' and `next()' methods are
created automatically.

Another key feature is that the local variables and execution state are
automatically saved between calls.  This made the function easier to
write and much more clear than an approach using class variables like
`self.index' and `self.data'.

In addition to automatic method creation and saving program state, when
generators terminate, they automatically raise `StopIteration'.  In
combination, these features make it easy to create iterators with no
more effort than writing a regular function.


File: python-tut.info,  Node: What Now?,  Next: Interactive Input Editing and History Substitution,  Prev: Classes,  Up: Top

What Now?
*********

Reading this tutorial has probably reinforced your interest in using
Python -- you should be eager to apply Python to solve your real-world
problems.  Now what should you do?

You should read, or at least page through, the , which gives complete
(though terse) reference material about types, functions, and modules
that can save you a lot of time when writing Python programs.  The
standard Python distribution includes a _lot_ of code in both C and
Python; there are modules to read UNIX mailboxes, retrieve documents
via HTTP, generate random numbers, parse command-line options, write
CGI programs, compress data, and a lot more; skimming through the
Library Reference will give you an idea of what's available.

The major Python Web site is <http://www.python.org/>; it contains
code, documentation, and pointers to Python-related pages around the
Web.  This Web site is mirrored in various places around the world,
such as Europe, Japan, and Australia; a mirror may be faster than the
main site, depending on your geographical location.  A more informal
site is <http://starship.python.net/>, which contains a bunch of
Python-related personal home pages; many people have downloadable
software there. Many more user-created Python modules can be found in a
third-party repository at <http://www.vex.net/parnassus>.

For Python-related questions and problem reports, you can post to the
newsgroup `comp.lang.python', or send them to the mailing list at
<python-list@python.org>.  The newsgroup and mailing list are
gatewayed, so messages posted to one will automatically be forwarded to
the other.  There are around 120 postings a day (with peaks up to
several hundred), asking (and answering) questions, suggesting new
features, and announcing new modules.  Before posting, be sure to check
the list of Frequently Asked Questions (also called the FAQ), at
<http://www.python.org/doc/FAQ.html>, or look for it in the `Misc/'
directory of the Python source distribution.  Mailing list archives are
available at <http://www.python.org/pipermail/>.  The FAQ answers many
of the questions that come up again and again, and may already contain
the solution for your problem.


File: python-tut.info,  Node: Interactive Input Editing and History Substitution,  Next: Floating Point Arithmetic Issues and Limitations,  Prev: What Now?,  Up: Top

Interactive Input Editing and History Substitution
**************************************************

Some versions of the Python interpreter support editing of the current
input line and history substitution, similar to facilities found in the
Korn shell and the GNU Bash shell.  This is implemented using the _GNU
Readline_ library, which supports Emacs-style and vi-style editing.
This library has its own documentation which I won't duplicate here;
however, the basics are easily explained.  The interactive editing and
history described here are optionally available in the UNIX and CygWin
versions of the interpreter.

This chapter does _not_ document the editing facilities of Mark
Hammond's PythonWin package or the Tk-based environment, IDLE,
distributed with Python.  The command line history recall which
operates within DOS boxes on NT and some other DOS and Windows flavors
is yet another beast.

* Menu:

* Line Editing::
* History Substitution::
* Key Bindings::
* Commentary::


File: python-tut.info,  Node: Line Editing,  Next: History Substitution,  Prev: Interactive Input Editing and History Substitution,  Up: Interactive Input Editing and History Substitution

Line Editing
============

If supported, input line editing is active whenever the interpreter
prints a primary or secondary prompt.  The current line can be edited
using the conventional Emacs control characters.  The most important of
these are: <C-A> (Control-A) moves the cursor to the beginning of the
line, <C-E> to the end, <C-B> moves it one position to the left, <C-F>
to the right.  Backspace erases the character to the left of the
cursor, <C-D> the character to its right.  <C-K> kills (erases) the
rest of the line to the right of the cursor, <C-Y> yanks back the last
killed string.  <C-underscore> undoes the last change you made; it can
be repeated for cumulative effect.


File: python-tut.info,  Node: History Substitution,  Next: Key Bindings,  Prev: Line Editing,  Up: Interactive Input Editing and History Substitution

History Substitution
====================

History substitution works as follows.  All non-empty input lines
issued are saved in a history buffer, and when a new prompt is given
you are positioned on a new line at the bottom of this buffer.  <C-P>
moves one line up (back) in the history buffer, <C-N> moves one down.
Any line in the history buffer can be edited; an asterisk appears in
front of the prompt to mark a line as modified.  Pressing the <Return>
key passes the current line to the interpreter.  <C-R> starts an
incremental reverse search; <C-S> starts a forward search.


File: python-tut.info,  Node: Key Bindings,  Next: Commentary,  Prev: History Substitution,  Up: Interactive Input Editing and History Substitution

Key Bindings
============

The key bindings and some other parameters of the Readline library can
be customized by placing commands in an initialization file called
`~{}/.inputrc'.  Key bindings have the form

     key-name: function-name

or

     "string": function-name

and options can be set with

     set option-name value

For example:

     # I prefer vi-style editing:
     set editing-mode vi
     
     # Edit using a single line:
     set horizontal-scroll-mode On
     
     # Rebind some keys:
     Meta-h: backward-kill-word
     "\C-u": universal-argument
     "\C-x\C-r": re-read-init-file

Note that the default binding for <Tab> in Python is to insert a <Tab>
character instead of Readline's default filename completion function.
If you insist, you can override this by putting

     Tab: complete

in your `~{}/.inputrc'.  (Of course, this makes it harder to type
indented continuation lines.)

Automatic completion of variable and module names is optionally
available.  To enable it in the interpreter's interactive mode, add the
following to your startup file:(1)

     import rlcompleter, readline
     readline.parse_and_bind('tab: complete')

This binds the <Tab> key to the completion function, so hitting the
<Tab> key twice suggests completions; it looks at Python statement
names, the current local variables, and the available module names.
For dotted expressions such as `string.a', it will evaluate the
expression up to the final `.' and then suggest completions from the
attributes of the resulting object.  Note that this may execute
application-defined code if an object with a `__getattr__()' method is
part of the expression.

A more capable startup file might look like this example.  Note that
this deletes the names it creates once they are no longer needed; this
is done since the startup file is executed in the same namespace as the
interactive commands, and removing the names avoids creating side
effects in the interactive environments.  You may find it convenient to
keep some of the imported modules, such as `os', which turn out to be
needed in most sessions with the interpreter.

     # Add auto-completion and a stored history file of commands to your Python
     # interactive interpreter. Requires Python 2.0+, readline. Autocomplete is
     # bound to the Esc key by default (you can change it - see readline docs).
     #
     # Store the file in ~/.pystartup, and set an environment variable to point
     # to it:  "export PYTHONSTARTUP=/max/home/itamar/.pystartup" in bash.
     #
     # Note that PYTHONSTARTUP does *not* expand "~", so you have to put in the
     # full path to your home directory.
     
     import atexit
     import os
     import readline
     import rlcompleter
     
     historyPath = os.path.expanduser("~/.pyhistory")
     
     def save_history(historyPath=historyPath):
         import readline
         readline.write_history_file(historyPath)
     
     if os.path.exists(historyPath):
         readline.read_history_file(historyPath)
     
     atexit.register(save_history)
     del os, atexit, readline, rlcompleter, save_history, historyPath

---------- Footnotes ----------

(1)  Python will execute the contents of a file identified by the
`PYTHONSTARTUP' environment variable when you start an interactive
interpreter.


File: python-tut.info,  Node: Commentary,  Prev: Key Bindings,  Up: Interactive Input Editing and History Substitution

Commentary
==========

This facility is an enormous step forward compared to earlier versions
of the interpreter; however, some wishes are left: It would be nice if
the proper indentation were suggested on continuation lines (the parser
knows if an indent token is required next).  The completion mechanism
might use the interpreter's symbol table.  A command to check (or even
suggest) matching parentheses, quotes, etc., would also be useful.


File: python-tut.info,  Node: Floating Point Arithmetic Issues and Limitations,  Next: History and License,  Prev: Interactive Input Editing and History Substitution,  Up: Top

Floating Point Arithmetic:  Issues and Limitations
**************************************************

Floating-point numbers are represented in computer hardware as base 2
(binary) fractions.  For example, the decimal fraction

     0.125

has value 1/10 + 2/100 + 5/1000, and in the same way the binary fraction

     0.001

has value 0/2 + 0/4 + 1/8.  These two fractions have identical values,
the only real difference being that the first is written in base 10
fractional notation, and the second in base 2.

Unfortunately, most decimal fractions cannot be represented exactly as
binary fractions.  A consequence is that, in general, the decimal
floating-point numbers you enter are only approximated by the binary
floating-point numbers actually stored in the machine.

The problem is easier to understand at first in base 10.  Consider the
fraction 1/3.  You can approximate that as a base 10 fraction:

     0.3

or, better,

     0.33

or, better,

     0.333

and so on.  No matter how many digits you're willing to write down, the
result will never be exactly 1/3, but will be an increasingly better
approximation to 1/3.

In the same way, no matter how many base 2 digits you're willing to
use, the decimal value 0.1 cannot be represented exactly as a base 2
fraction.  In base 2, 1/10 is the infinitely repeating fraction

     0.0001100110011001100110011001100110011001100110011...

Stop at any finite number of bits, and you get an approximation.  This
is why you see things like:

     >>> 0.1
     0.10000000000000001

On most machines today, that is what you'll see if you enter 0.1 at a
Python prompt.  You may not, though, because the number of bits used by
the hardware to store floating-point values can vary across machines,
and Python only prints a decimal approximation to the true decimal
value of the binary approximation stored by the machine.  On most
machines, if Python were to print the true decimal value of the binary
approximation stored for 0.1, it would have to display

     >>> 0.1
     0.1000000000000000055511151231257827021181583404541015625

instead!  The Python prompt (implicitly) uses the builtin `repr()'
function to obtain a string version of everything it displays.  For
floats, `repr(FLOAT)' rounds the true decimal value to 17 significant
digits, giving

     0.10000000000000001

`repr(FLOAT)' produces 17 significant digits because it turns out
that's enough (on most machines) so that `eval(repr(X)) == X' exactly
for all finite floats X, but rounding to 16 digits is not enough to
make that true.

Note that this is in the very nature of binary floating-point: this is
not a bug in Python, it is not a bug in your code either, and you'll
see the same kind of thing in all languages that support your
hardware's floating-point arithmetic (although some languages may not
_display_ the difference by default, or in all output modes).

Python's builtin `str()' function produces only 12 significant digits,
and you may wish to use that instead.  It's unusual for `eval(str(X))'
to reproduce X, but the output may be more pleasant to look at:

     >>> print str(0.1)
     0.1

It's important to realize that this is, in a real sense, an illusion:
the value in the machine is not exactly 1/10, you're simply rounding
the _display_ of the true machine value.

Other surprises follow from this one.  For example, after seeing

     >>> 0.1
     0.10000000000000001

you may be tempted to use the `round()' function to chop it back to the
single digit you expect.  But that makes no difference:

     >>> round(0.1, 1)
     0.10000000000000001

The problem is that the binary floating-point value stored for "0.1"
was already the best possible binary approximation to 1/10, so trying
to round it again can't make it better:  it was already as good as it
gets.

Another consequence is that since 0.1 is not exactly 1/10, adding 0.1
to itself 10 times may not yield exactly 1.0, either:

     >>> sum = 0.0
     >>> for i in range(10):
     ...     sum += 0.1
     ...
     >>> sum
     0.99999999999999989

Binary floating-point arithmetic holds many surprises like this.  The
problem with "0.1" is explained in precise detail below, in the
"Representation Error" section.  See  for a more complete account of
other common surprises.

As that says near the end, "there are no easy answers."  Still, don't
be unduly wary of floating-point!  The errors in Python float
operations are inherited from the floating-point hardware, and on most
machines are on the order of no more than 1 part in 2**53 per
operation.  That's more than adequate for most tasks, but you do need
to keep in mind that it's not decimal arithmetic, and that every float
operation can suffer a new rounding error.

While pathological cases do exist, for most casual use of
floating-point arithmetic you'll see the result you expect in the end
if you simply round the display of your final results to the number of
decimal digits you expect.  `str()' usually suffices, and for finer
control see the discussion of Pythons's `%' format operator: the `%g',
`%f' and `%e' format codes supply flexible and easy ways to round float
results for display.

* Menu:

* Representation Error::


File: python-tut.info,  Node: Representation Error,  Prev: Floating Point Arithmetic Issues and Limitations,  Up: Floating Point Arithmetic Issues and Limitations

Representation Error
====================

This section explains the "0.1" example in detail, and shows how you
can perform an exact analysis of cases like this yourself.  Basic
familiarity with binary floating-point representation is assumed.

"Representation error" refers to that some (most, actually) decimal
fractions cannot be represented exactly as binary (base 2) fractions.
This is the chief reason why Python (or Perl, C, C++, Java, Fortran,
and many others) often won't display the exact decimal number you
expect:

     >>> 0.1
     0.10000000000000001

Why is that?  1/10 is not exactly representable as a binary fraction.
Almost all machines today (November 2000) use IEEE-754 floating point
arithmetic, and almost all platforms map Python floats to IEEE-754
"double precision".  754 doubles contain 53 bits of precision, so on
input the computer strives to convert 0.1 to the closest fraction it can
of the form J/2**N where J is an integer containing exactly 53 bits.
Rewriting

      1 / 10 ~= J / (2**N)

as

     J ~= 2**N / 10

and recalling that J has exactly 53 bits (is `>= 2**52' but `< 2**53'),
the best value for N is 56:

     >>> 2L**52
     4503599627370496L
     >>> 2L**53
     9007199254740992L
     >>> 2L**56/10
     7205759403792793L

That is, 56 is the only value for N that leaves J with exactly 53 bits.
The best possible value for J is then that quotient rounded:

     >>> q, r = divmod(2L**56, 10)
     >>> r
     6L

Since the remainder is more than half of 10, the best approximation is
obtained by rounding up:

     >>> q+1
     7205759403792794L

Therefore the best possible approximation to 1/10 in 754 double
precision is that over 2**56, or

     7205759403792794 / 72057594037927936

Note that since we rounded up, this is actually a little bit larger than
1/10; if we had not rounded up, the quotient would have been a little
bit smaller than 1/10.  But in no case can it be _exactly_ 1/10!

So the computer never "sees" 1/10:  what it sees is the exact fraction
given above, the best 754 double approximation it can get:

     >>> .1 * 2L**56
     7205759403792794.0

If we multiply that fraction by 10**30, we can see the (truncated)
value of its 30 most significant decimal digits:

     >>> 7205759403792794L * 10L**30 / 2L**56
     100000000000000005551115123125L

meaning that the exact number stored in the computer is approximately
equal to the decimal value 0.100000000000000005551115123125.  Rounding
that to 17 significant digits gives the 0.10000000000000001 that Python
displays (well, will display on any 754-conforming platform that does
best-possible input and output conversions in its C library -- yours may
not!).


File: python-tut.info,  Node: History and License,  Next: Module Index,  Prev: Floating Point Arithmetic Issues and Limitations,  Up: Top

History and License
*******************

* Menu:

* History of the software::
* Terms and conditions for accessing or otherwise using Python::


File: python-tut.info,  Node: History of the software,  Next: Terms and conditions for accessing or otherwise using Python,  Prev: History and License,  Up: History and License

History of the software
=======================

Python was created in the early 1990s by Guido van Rossum at Stichting
Mathematisch Centrum (CWI, see <http://www.cwi.nl/>) in the Netherlands
as a successor of a language called ABC.  Guido remains Python's
principal author, although it includes many contributions from others.

In 1995, Guido continued his work on Python at the Corporation for
National Research Initiatives (CNRI, see
<http://www.cnri.reston.va.us/>) in Reston, Virginia where he released
several versions of the software.

In May 2000, Guido and the Python core development team moved to
BeOpen.com to form the BeOpen PythonLabs team.  In October of the same
year, the PythonLabs team moved to Digital Creations (now Zope
Corporation; see <http://www.zope.com/>).  In 2001, the Python Software
Foundation (PSF, see <http://www.python.org/psf/>) was formed, a
non-profit organization created specifically to own Python-related
Intellectual Property.  Zope Corporation is a sponsoring member of the
PSF.

All Python releases are Open Source (see <http://www.opensource.org/>
for the Open Source Definition).  Historically, most, but not all,
Python releases have also been GPL-compatible; the table below
summarizes the various releases.

Release        Derived from   Year           Owner          GPL
                                                            compatible?
------         ------         ------         ------         ------
0.9.0 thru     n/a            1991-1995      CWI            yes
1.2                                                         
1.3 thru       1.2            1995-1999      CNRI           yes
1.5.2                                                       
1.6            1.5.2          2000           CNRI           no
2.0            1.6            2000           BeOpen.com     no
1.6.1          1.6            2001           CNRI           no
2.1            2.0+1.6.1      2001           PSF            no
2.0.1          2.0+1.6.1      2001           PSF            yes
2.1.1          2.1+2.0.1      2001           PSF            yes
2.2            2.1.1          2001           PSF            yes
2.1.2          2.1.1          2002           PSF            yes
2.1.3          2.1.2          2002           PSF            yes
2.2.1          2.2            2002           PSF            yes
2.2.2          2.2.1          2002           PSF            yes
2.2.3          2.2.2          2002-2003      PSF            yes
2.3            2.2.2          2002-2003      PSF            yes
2.3.1          2.3            2002-2003      PSF            yes
2.3.2          2.3.1          2003           PSF            yes

_Note:_ GPL-compatible doesn't mean that we're distributing Python
under the GPL.  All Python licenses, unlike the GPL, let you distribute
a modified version without making your changes open source. The
GPL-compatible licenses make it possible to combine Python with other
software that is released under the GPL; the others don't.

Thanks to the many outside volunteers who have worked under Guido's
direction to make these releases possible.


File: python-tut.info,  Node: Terms and conditions for accessing or otherwise using Python,  Prev: History of the software,  Up: History and License

Terms and conditions for accessing or otherwise using Python
============================================================

               *PSF LICENSE AGREEMENT FOR PYTHON 2.3.2*
  1. This LICENSE AGREEMENT is between the Python Software Foundation
     ("PSF"), and the Individual or Organization ("Licensee") accessing
     and otherwise using Python 2.3.2 software in source or binary form
     and its associated documentation.

  2. Subject to the terms and conditions of this License Agreement, PSF
     hereby grants Licensee a nonexclusive, royalty-free, world-wide
     license to reproduce, analyze, test, perform and/or display
     publicly, prepare derivative works, distribute, and otherwise use
     Python 2.3.2 alone or in any derivative version, provided,
     however, that PSF's License Agreement and PSF's notice of
     copyright, i.e., "Copyright (C) 2001-2003 Python Software
     Foundation; All Rights Reserved" are retained in Python 2.3.2
     alone or in any derivative version prepared by Licensee.

  3. In the event Licensee prepares a derivative work that is based on
     or incorporates Python 2.3.2 or any part thereof, and wants to
     make the derivative work available to others as provided herein,
     then Licensee hereby agrees to include in any such work a brief
     summary of the changes made to Python 2.3.2.

  4. PSF is making Python 2.3.2 available to Licensee on an "AS IS"
     basis.  PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
     IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND
     DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR
     FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 2.3.2
     WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.

  5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON
     2.3.2 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR
     LOSS AS A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING
     PYTHON 2.3.2, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE
     POSSIBILITY THEREOF.

  6. This License Agreement will automatically terminate upon a material
     breach of its terms and conditions.

  7. Nothing in this License Agreement shall be deemed to create any
     relationship of agency, partnership, or joint venture between PSF
     and Licensee.  This License Agreement does not grant permission to
     use PSF trademarks or trade name in a trademark sense to endorse
     or promote products or services of Licensee, or any third party.

  8. By copying, installing or otherwise using Python 2.3.2, Licensee
     agrees to be bound by the terms and conditions of this License
     Agreement.

             *BEOPEN.COM LICENSE AGREEMENT FOR PYTHON 2.0*
         *BEOPEN PYTHON OPEN SOURCE LICENSE AGREEMENT VERSION 1*
  1. This LICENSE AGREEMENT is between BeOpen.com ("BeOpen"), having an
     office at 160 Saratoga Avenue, Santa Clara, CA 95051, and the
     Individual or Organization ("Licensee") accessing and otherwise
     using this software in source or binary form and its associated
     documentation ("the Software").

  2. Subject to the terms and conditions of this BeOpen Python License
     Agreement, BeOpen hereby grants Licensee a non-exclusive,
     royalty-free, world-wide license to reproduce, analyze, test,
     perform and/or display publicly, prepare derivative works,
     distribute, and otherwise use the Software alone or in any
     derivative version, provided, however, that the BeOpen Python
     License is retained in the Software, alone or in any derivative
     version prepared by Licensee.

  3. BeOpen is making the Software available to Licensee on an "AS IS"
     basis.  BEOPEN MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
     IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, BEOPEN MAKES NO
     AND DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR
     FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE
     WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.

  4. BEOPEN SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF THE
     SOFTWARE FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR
     LOSS AS A RESULT OF USING, MODIFYING OR DISTRIBUTING THE SOFTWARE,
     OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY
     THEREOF.

  5. This License Agreement will automatically terminate upon a material
     breach of its terms and conditions.

  6. This License Agreement shall be governed by and interpreted in all
     respects by the law of the State of California, excluding conflict
     of law provisions.  Nothing in this License Agreement shall be
     deemed to create any relationship of agency, partnership, or joint
     venture between BeOpen and Licensee.  This License Agreement does
     not grant permission to use BeOpen trademarks or trade names in a
     trademark sense to endorse or promote products or services of
     Licensee, or any third party.  As an exception, the "BeOpen
     Python" logos available at http://www.pythonlabs.com/logos.html
     may be used according to the permissions granted on that web page.

  7. By copying, installing or otherwise using the software, Licensee
     agrees to be bound by the terms and conditions of this License
     Agreement.

               *CNRI LICENSE AGREEMENT FOR PYTHON 1.6.1*
  1. This LICENSE AGREEMENT is between the Corporation for National
     Research Initiatives, having an office at 1895 Preston White Drive,
     Reston, VA 20191 ("CNRI"), and the Individual or Organization
     ("Licensee") accessing and otherwise using Python 1.6.1 software in
     source or binary form and its associated documentation.

  2. Subject to the terms and conditions of this License Agreement, CNRI
     hereby grants Licensee a nonexclusive, royalty-free, world-wide
     license to reproduce, analyze, test, perform and/or display
     publicly, prepare derivative works, distribute, and otherwise use
     Python 1.6.1 alone or in any derivative version, provided,
     however, that CNRI's License Agreement and CNRI's notice of
     copyright, i.e., "Copyright (C) 1995-2001 Corporation for National
     Research Initiatives; All Rights Reserved" are retained in Python
     1.6.1 alone or in any derivative version prepared by Licensee.
     Alternately, in lieu of CNRI's License Agreement, Licensee may
     substitute the following text (omitting the quotes): "Python 1.6.1
     is made available subject to the terms and conditions in CNRI's
     License Agreement.  This Agreement together with Python 1.6.1 may
     be located on the Internet using the following unique, persistent
     identifier (known as a handle): 1895.22/1013.  This Agreement may
     also be obtained from a proxy server on the Internet using the
     following URL: <http://hdl.handle.net/1895.22/1013>."

  3. In the event Licensee prepares a derivative work that is based on
     or incorporates Python 1.6.1 or any part thereof, and wants to make
     the derivative work available to others as provided herein, then
     Licensee hereby agrees to include in any such work a brief summary
     of the changes made to Python 1.6.1.

  4. CNRI is making Python 1.6.1 available to Licensee on an "AS IS"
     basis.  CNRI MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
     IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, CNRI MAKES NO AND
     DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR
     FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 1.6.1
     WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.

  5. CNRI SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON
     1.6.1 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR
     LOSS AS A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING
     PYTHON 1.6.1, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE
     POSSIBILITY THEREOF.

  6. This License Agreement will automatically terminate upon a material
     breach of its terms and conditions.

  7. This License Agreement shall be governed by the federal
     intellectual property law of the United States, including without
     limitation the federal copyright law, and, to the extent such U.S.
     federal law does not apply, by the law of the Commonwealth of
     Virginia, excluding Virginia's conflict of law provisions.
     Notwithstanding the foregoing, with regard to derivative works
     based on Python 1.6.1 that incorporate non-separable material that
     was previously distributed under the GNU General Public License
     (GPL), the law of the Commonwealth of Virginia shall govern this
     License Agreement only as to issues arising under or with respect
     to Paragraphs 4, 5, and 7 of this License Agreement.  Nothing in
     this License Agreement shall be deemed to create any relationship
     of agency, partnership, or joint venture between CNRI and
     Licensee.  This License Agreement does not grant permission to use
     CNRI trademarks or trade name in a trademark sense to endorse or
     promote products or services of Licensee, or any third party.

  8. By clicking on the "ACCEPT" button where indicated, or by copying,
     installing or otherwise using Python 1.6.1, Licensee agrees to be
     bound by the terms and conditions of this License Agreement.

                                ACCEPT
          *CWI LICENSE AGREEMENT FOR PYTHON 0.9.0 THROUGH 1.2*
 Copyright
(C) 1991 - 1995, Stichting Mathematisch Centrum Amsterdam, The
Netherlands.  All rights reserved.

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Stichting Mathematisch
Centrum or CWI not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior permission.

STICHTING MATHEMATISCH CENTRUM DISCLAIMS ALL WARRANTIES WITH REGARD TO
THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH CENTRUM BE LIABLE FOR
ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.


File: python-tut.info,  Node: Module Index,  Next: Class-Exception-Object Index,  Prev: History and License,  Up: Top

Module Index
************

* Menu:

* __builtin__:                           dir Function.
* compileall:                            Compiled Python files.
* pickle:                                pickle Module.
* readline:                              Key Bindings.
* rlcompleter:                           Key Bindings.
* string:                                Fancier Output Formatting.
* sys:                                   Standard Modules.


File: python-tut.info,  Node: Class-Exception-Object Index,  Next: Function-Method-Variable Index,  Prev: Module Index,  Up: Top

Class, Exception, and Object Index
**********************************

* Menu:

* file:                                  Reading and Writing Files.
* method:                                Instance Objects.


File: python-tut.info,  Node: Function-Method-Variable Index,  Next: Miscellaneous Index,  Prev: Class-Exception-Object Index,  Up: Top

Function, Method, and Variable Index
************************************

* Menu:

* append:                                More on Lists.
* count:                                 More on Lists.
* extend:                                More on Lists.
* index:                                 More on Lists.
* insert:                                More on Lists.
* open:                                  Reading and Writing Files.
* pop:                                   More on Lists.
* remove:                                More on Lists.
* reverse:                               More on Lists.
* sort:                                  More on Lists.
* unicode:                               Unicode Strings.


File: python-tut.info,  Node: Miscellaneous Index,  Prev: Function-Method-Variable Index,  Up: Top

Miscellaneous Index
*******************

* Menu:

* docstrings <1>:                        Documentation Strings.
* docstrings:                            Defining Functions.
* documentation strings <1>:             Documentation Strings.
* documentation strings:                 Defining Functions.
* for:                                   for Statements.
* module search path:                    Module Search Path.
* strings, documentation <1>:            Documentation Strings.
* strings, documentation:                Defining Functions.


