This is python-api.info, produced by makeinfo version 4.3 from
python-api.texi.

October 3, 2003


File: python-api.info,  Node: Object Protocol,  Next: Number Protocol,  Prev: Abstract Objects Layer,  Up: Abstract Objects Layer

Object Protocol
===============

`int PyObject_Print(PyObject *o, FILE *fp, int flags)'
     Print an object O, on file FP.  Returns `-1' on error.  The flags
     argument is used to enable certain printing options.  The only
     option currently supported is `Py_PRINT_RAW'; if given, the
     `str()' of the object is written instead of the `repr()'.

`int PyObject_HasAttrString(PyObject *o, char *attr_name)'
     Returns `1' if O has the attribute ATTR_NAME, and `0' otherwise.
     This is equivalent to the Python expression `hasattr(O,
     ATTR_NAME)'.  This function always succeeds.

`PyObject* PyObject_GetAttrString(PyObject *o, char *attr_name)'
     Retrieve an attribute named ATTR_NAME from object O.  Returns the
     attribute value on success, or `NULL' on failure.  This is the
     equivalent of the Python expression `O.ATTR_NAME'.

`int PyObject_HasAttr(PyObject *o, PyObject *attr_name)'
     Returns `1' if O has the attribute ATTR_NAME, and `0' otherwise.
     This is equivalent to the Python expression `hasattr(O,
     ATTR_NAME)'.  This function always succeeds.

`PyObject* PyObject_GetAttr(PyObject *o, PyObject *attr_name)'
     Retrieve an attribute named ATTR_NAME from object O.  Returns the
     attribute value on success, or `NULL' on failure.  This is the
     equivalent of the Python expression `O.ATTR_NAME'.

`int PyObject_SetAttrString(PyObject *o, char *attr_name, PyObject *v)'
     Set the value of the attribute named ATTR_NAME, for object O, to
     the value V. Returns `-1' on failure.  This is the equivalent of
     the Python statement `O.ATTR_NAME = V'.

`int PyObject_SetAttr(PyObject *o, PyObject *attr_name, PyObject *v)'
     Set the value of the attribute named ATTR_NAME, for object O, to
     the value V. Returns `-1' on failure.  This is the equivalent of
     the Python statement `O.ATTR_NAME = V'.

`int PyObject_DelAttrString(PyObject *o, char *attr_name)'
     Delete attribute named ATTR_NAME, for object O. Returns `-1' on
     failure.  This is the equivalent of the Python statement: `del
     O.ATTR_NAME'.

`int PyObject_DelAttr(PyObject *o, PyObject *attr_name)'
     Delete attribute named ATTR_NAME, for object O. Returns `-1' on
     failure.  This is the equivalent of the Python statement `del
     O.ATTR_NAME'.

`PyObject* PyObject_RichCompare(PyObject *o1, PyObject *o2, int opid)'
     Compare the values of O1 and O2 using the operation specified by
     OPID, which must be one of `Py_LT', `Py_LE', `Py_EQ', `Py_NE',
     `Py_GT', or `Py_GE', corresponding to `<', `<=', `==', `!=', `>',
     or `>=' respectively. This is the equivalent of the Python
     expression `O1 op O2', where `op' is the operator corresponding to
     OPID. Returns the value of the comparison on success, or `NULL' on
     failure.

`int PyObject_RichCompareBool(PyObject *o1, PyObject *o2, int opid)'
     Compare the values of O1 and O2 using the operation specified by
     OPID, which must be one of `Py_LT', `Py_LE', `Py_EQ', `Py_NE',
     `Py_GT', or `Py_GE', corresponding to `<', `<=', `==', `!=', `>',
     or `>=' respectively. Returns `-1' on error, `0' if the result is
     false, `1' otherwise. This is the equivalent of the Python
     expression `O1 op O2', where `op' is the operator corresponding to
     OPID.

`int PyObject_Cmp(PyObject *o1, PyObject *o2, int *result)'
     Compare the values of O1 and O2 using a routine provided by O1, if
     one exists, otherwise with a routine provided by O2.  The result
     of the comparison is returned in RESULT.  Returns `-1' on failure.
     This is the equivalent of the Python statement  `RESULT = cmp(O1,
     O2)'.

`int PyObject_Compare(PyObject *o1, PyObject *o2)'
     Compare the values of O1 and O2 using a routine provided by O1, if
     one exists, otherwise with a routine provided by O2.  Returns the
     result of the comparison on success.  On error, the value returned
     is undefined; use `PyErr_Occurred()' to detect an error.  This is
     equivalent to the Python expression  `cmp(O1, O2)'.

`PyObject* PyObject_Repr(PyObject *o)'
     Compute a string representation of object O.  Returns the string
     representation on success, `NULL' on failure.  This is the
     equivalent of the Python expression `repr(O)'.  Called by the
     `repr()'  built-in function and by reverse quotes.

`PyObject* PyObject_Str(PyObject *o)'
     Compute a string representation of object O.  Returns the string
     representation on success, `NULL' on failure.  This is the
     equivalent of the Python expression `str(O)'.  Called by the
     `str()'  built-in function and by the `print' statement.

`PyObject* PyObject_Unicode(PyObject *o)'
     Compute a Unicode string representation of object O.  Returns the
     Unicode string representation on success, `NULL' on failure.  This
     is the equivalent of the Python expression `unicode(O)'.  Called
     by the `unicode()'  built-in function.

`int PyObject_IsInstance(PyObject *inst, PyObject *cls)'
     Returns `1' if INST is an instance of the class CLS or a subclass
     of CLS, or `0' if not.  On error, returns `-1' and sets an
     exception.  If CLS is a type object rather than a class object,
     `PyObject_IsInstance()' returns `1' if INST is of type CLS.  If CLS
     is a tuple, the check will be done against every entry in CLS.
     The result will be `1' when at least one of the checks returns
     `1', otherwise it will be `0'. If INST is not a class instance and
     CLS is neither a type object, nor a class object, nor a tuple,
     INST must have a `__class__' attribute -- the class relationship
     of the value of that attribute with CLS will be used to determine
     the result of this function.  _Added in Python version 2.1_
     _Changed in Python version 2.2_

Subclass determination is done in a fairly straightforward way, but
includes a wrinkle that implementors of extensions to the class system
may want to be aware of.  If `A' and `B' are class objects, `B' is a
subclass of `A' if it inherits from `A' either directly or indirectly.
If either is not a class object, a more general mechanism is used to
determine the class relationship of the two objects.  When testing if B
is a subclass of A, if A is B, `PyObject_IsSubclass()' returns true.
If A and B are different objects, B's `__bases__' attribute is searched
in a depth-first fashion for A -- the presence of the `__bases__'
attribute is considered sufficient for this determination.

`int PyObject_IsSubclass(PyObject *derived, PyObject *cls)'
     Returns `1' if the class DERIVED is identical to or derived from
     the class CLS, otherwise returns `0'.  In case of an error,
     returns `-1'. If CLS is a tuple, the check will be done against
     every entry in CLS.  The result will be `1' when at least one of
     the checks returns `1', otherwise it will be `0'. If either
     DERIVED or CLS is not an actual class object (or tuple), this
     function uses the generic algorithm described above.  _Added in
     Python version 2.1_ _Changed in Python version 2.3_

`int PyCallable_Check(PyObject *o)'
     Determine if the object O is callable.  Return `1' if the object
     is callable and `0' otherwise.  This function always succeeds.

`PyObject* PyObject_Call(PyObject *callable_object, PyObject *args, PyObject *kw)'
     Call a callable Python object CALLABLE_OBJECT, with arguments
     given by the tuple ARGS, and named arguments given by the
     dictionary KW. If no named arguments are needed, KW may be `NULL'.
     ARGS must not be `NULL', use an empty tuple if no arguments are
     needed. Returns the result of the call on success, or `NULL' on
     failure.  This is the equivalent of the Python expression
     `apply(CALLABLE_OBJECT, ARGS, KW)' or `CALLABLE_OBJECT(*ARGS,
     **KW)'.  _Added in Python version 2.2_

`PyObject* PyObject_CallObject(PyObject *callable_object, PyObject *args)'
     Call a callable Python object CALLABLE_OBJECT, with arguments
     given by the tuple ARGS.  If no arguments are needed, then ARGS
     may be `NULL'.  Returns the result of the call on success, or
     `NULL' on failure.  This is the equivalent of the Python
     expression `apply(CALLABLE_OBJECT, ARGS)' or
     `CALLABLE_OBJECT(*ARGS)'.

`PyObject* PyObject_CallFunction(PyObject *callable, char *format, ...)'
     Call a callable Python object CALLABLE, with a variable number of
     C arguments.  The C arguments are described using a
     `Py_BuildValue()' style format string.  The format may be `NULL',
     indicating that no arguments are provided.  Returns the result of
     the call on success, or `NULL' on failure.  This is the equivalent
     of the Python expression `apply(CALLABLE, ARGS)' or
     `CALLABLE(*ARGS)'.

`PyObject* PyObject_CallMethod(PyObject *o, char *method, char *format, ...)'
     Call the method named M of object O with a variable number of C
     arguments.  The C arguments are described by a `Py_BuildValue()'
     format string.  The format may be `NULL', indicating that no
     arguments are provided. Returns the result of the call on success,
     or `NULL' on failure.  This is the equivalent of the Python
     expression `O.METHOD(ARGS)'.

`PyObject* PyObject_CallFunctionObjArgs(PyObject *callable, ..., `NULL')'
     Call a callable Python object CALLABLE, with a variable number of
     `PyObject*' arguments.  The arguments are provided as a variable
     number of parameters followed by `NULL'.  Returns the result of
     the call on success, or `NULL' on failure.  _Added in Python
     version 2.2_

`PyObject* PyObject_CallMethodObjArgs(PyObject *o, PyObject *name, ..., `NULL')'
     Calls a method of the object O, where the name of the method is
     given as a Python string object in NAME.  It is called with a
     variable number of `PyObject*' arguments.  The arguments are
     provided as a variable number of parameters followed by `NULL'.
     Returns the result of the call on success, or `NULL' on failure.
     _Added in Python version 2.2_

`int PyObject_Hash(PyObject *o)'
     Compute and return the hash value of an object O.  On failure,
     return `-1'.  This is the equivalent of the Python expression
     `hash(O)'.

`int PyObject_IsTrue(PyObject *o)'
     Returns `1' if the object O is considered to be true, and `0'
     otherwise.  This is equivalent to the Python expression `not not
     O'.  On failure, return `-1'.

`int PyObject_Not(PyObject *o)'
     Returns `0' if the object O is considered to be true, and `1'
     otherwise.  This is equivalent to the Python expression `not O'.
     On failure, return `-1'.

`PyObject* PyObject_Type(PyObject *o)'
     When O is non-`NULL', returns a type object corresponding to the
     object type of object O. On failure, raises `SystemError' and
     returns `NULL'.  This is equivalent to the Python expression
     `type(O)'.  This function increments the reference count of the
     return value.  There's really no reason to use this function
     instead of the common expression `O->ob_type', which returns a
     pointer of type `PyTypeObject*', except when the incremented
     reference count is needed.

`int PyObject_TypeCheck(PyObject *o, PyTypeObject *type)'
     Return true if the object O is of type TYPE or a subtype of TYPE.
     Both parameters must be non-`NULL'.  _Added in Python version 2.2_

`int PyObject_Length(PyObject *o)'
`int PyObject_Size(PyObject *o)'
     Return the length of object O.  If the object O provides both
     sequence and mapping protocols, the sequence length is returned.
     On error, `-1' is returned.  This is the equivalent to the Python
     expression `len(O)'.

`PyObject* PyObject_GetItem(PyObject *o, PyObject *key)'
     Return element of O corresponding to the object KEY or `NULL' on
     failure.  This is the equivalent of the Python expression `O[KEY]'.

`int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v)'
     Map the object KEY to the value V.  Returns `-1' on failure.  This
     is the equivalent of the Python statement `O[KEY] = V'.

`int PyObject_DelItem(PyObject *o, PyObject *key)'
     Delete the mapping for KEY from O.  Returns `-1' on failure. This
     is the equivalent of the Python statement `del O[KEY]'.

`int PyObject_AsFileDescriptor(PyObject *o)'
     Derives a file-descriptor from a Python object.  If the object is
     an integer or long integer, its value is returned.  If not, the
     object's `fileno()' method is called if it exists; the method must
     return an integer or long integer, which is returned as the file
     descriptor value.  Returns `-1' on failure.

`PyObject* PyObject_Dir(PyObject *o)'
     This is equivalent to the Python expression `dir(O)', returning a
     (possibly empty) list of strings appropriate for the object
     argument, or `NULL' if there was an error.  If the argument is
     `NULL', this is like the Python `dir()', returning the names of
     the current locals; in this case, if no execution frame is active
     then `NULL' is returned but `PyErr_Occurred()' will return false.

`PyObject* PyObject_GetIter(PyObject *o)'
     This is equivalent to the Python expression `iter(O)'.  It returns
     a new iterator for the object argument, or the object itself if
     the object is already an iterator.  Raises `TypeError' and returns
     `NULL' if the object cannot be iterated.


File: python-api.info,  Node: Number Protocol,  Next: Sequence Protocol,  Prev: Object Protocol,  Up: Abstract Objects Layer

Number Protocol
===============

`int PyNumber_Check(PyObject *o)'
     Returns `1' if the object O provides numeric protocols, and false
     otherwise.  This function always succeeds.

`PyObject* PyNumber_Add(PyObject *o1, PyObject *o2)'
     Returns the result of adding O1 and O2, or `NULL' on failure.
     This is the equivalent of the Python expression `O1 + O2'.

`PyObject* PyNumber_Subtract(PyObject *o1, PyObject *o2)'
     Returns the result of subtracting O2 from O1, or `NULL' on
     failure.  This is the equivalent of the Python expression `O1 -
     O2'.

`PyObject* PyNumber_Multiply(PyObject *o1, PyObject *o2)'
     Returns the result of multiplying O1 and O2, or `NULL' on failure.
     This is the equivalent of the Python expression `O1 * O2'.

`PyObject* PyNumber_Divide(PyObject *o1, PyObject *o2)'
     Returns the result of dividing O1 by O2, or `NULL' on failure.
     This is the equivalent of the Python expression `O1 / O2'.

`PyObject* PyNumber_FloorDivide(PyObject *o1, PyObject *o2)'
     Return the floor of O1 divided by O2, or `NULL' on failure.  This
     is equivalent to the "classic" division of integers.  _Added in
     Python version 2.2_

`PyObject* PyNumber_TrueDivide(PyObject *o1, PyObject *o2)'
     Return a reasonable approximation for the mathematical value of O1
     divided by O2, or `NULL' on failure.  The return value is
     "approximate" because binary floating point numbers are
     approximate; it is not possible to represent all real numbers in
     base two.  This function can return a floating point value when
     passed two integers.  _Added in Python version 2.2_

`PyObject* PyNumber_Remainder(PyObject *o1, PyObject *o2)'
     Returns the remainder of dividing O1 by O2, or `NULL' on failure.
     This is the equivalent of the Python expression `O1 % O2'.

`PyObject* PyNumber_Divmod(PyObject *o1, PyObject *o2)'
     See the built-in function `divmod()' .  Returns `NULL' on failure.
     This is the equivalent of the Python expression `divmod(O1, O2)'.

`PyObject* PyNumber_Power(PyObject *o1, PyObject *o2, PyObject *o3)'
     See the built-in function `pow()' .  Returns `NULL' on failure.
     This is the equivalent of the Python expression `pow(O1, O2, O3)',
     where O3 is optional.  If O3 is to be ignored, pass `Py_None' in
     its place (passing `NULL' for O3 would cause an illegal memory
     access).

`PyObject* PyNumber_Negative(PyObject *o)'
     Returns the negation of O on success, or `NULL' on failure.  This
     is the equivalent of the Python expression `-O'.

`PyObject* PyNumber_Positive(PyObject *o)'
     Returns O on success, or `NULL' on failure.  This is the
     equivalent of the Python expression `+O'.

`PyObject* PyNumber_Absolute(PyObject *o)'
     Returns the absolute value of O, or `NULL' on failure.  This is
     the equivalent of the Python expression `abs(O)'.

`PyObject* PyNumber_Invert(PyObject *o)'
     Returns the bitwise negation of O on success, or `NULL' on
     failure.  This is the equivalent of the Python expression `~O'.

`PyObject* PyNumber_Lshift(PyObject *o1, PyObject *o2)'
     Returns the result of left shifting O1 by O2 on success, or `NULL'
     on failure.  This is the equivalent of the Python expression `O1
     <`<' O2'.

`PyObject* PyNumber_Rshift(PyObject *o1, PyObject *o2)'
     Returns the result of right shifting O1 by O2 on success, or
     `NULL' on failure.  This is the equivalent of the Python
     expression `O1 >`>' O2'.

`PyObject* PyNumber_And(PyObject *o1, PyObject *o2)'
     Returns the "bitwise and" of O2 and O2 on success and `NULL' on
     failure. This is the equivalent of the Python expression `O1 & O2'.

`PyObject* PyNumber_Xor(PyObject *o1, PyObject *o2)'
     Returns the "bitwise exclusive or" of O1 by O2 on success, or
     `NULL' on failure.  This is the equivalent of the Python
     expression `O1 ^ O2'.

`PyObject* PyNumber_Or(PyObject *o1, PyObject *o2)'
     Returns the "bitwise or" of O1 and O2 on success, or `NULL' on
     failure.  This is the equivalent of the Python expression `O1 |
     O2'.

`PyObject* PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2)'
     Returns the result of adding O1 and O2, or `NULL' on failure.  The
     operation is done _in-place_ when O1 supports it.  This is the
     equivalent of the Python statement `O1 += O2'.

`PyObject* PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2)'
     Returns the result of subtracting O2 from O1, or `NULL' on
     failure.  The operation is done _in-place_ when O1 supports it.
     This is the equivalent of the Python statement `O1 -= O2'.

`PyObject* PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2)'
     Returns the result of multiplying O1 and O2, or `NULL' on failure.
     The operation is done _in-place_ when O1 supports it.  This is
     the equivalent of the Python statement `O1 *= O2'.

`PyObject* PyNumber_InPlaceDivide(PyObject *o1, PyObject *o2)'
     Returns the result of dividing O1 by O2, or `NULL' on failure.
     The operation is done _in-place_ when O1 supports it. This is the
     equivalent of the Python statement `O1 /= O2'.

`PyObject* PyNumber_InPlaceFloorDivide(PyObject *o1, PyObject *o2)'
     Returns the mathematical of dividing O1 by O2, or `NULL' on
     failure.  The operation is done _in-place_ when O1 supports it.
     This is the equivalent of the Python statement `O1 //= O2'.
     _Added in Python version 2.2_

`PyObject* PyNumber_InPlaceTrueDivide(PyObject *o1, PyObject *o2)'
     Return a reasonable approximation for the mathematical value of O1
     divided by O2, or `NULL' on failure.  The return value is
     "approximate" because binary floating point numbers are
     approximate; it is not possible to represent all real numbers in
     base two.  This function can return a floating point value when
     passed two integers.  The operation is done _in-place_ when O1
     supports it.  _Added in Python version 2.2_

`PyObject* PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2)'
     Returns the remainder of dividing O1 by O2, or `NULL' on failure.
     The operation is done _in-place_ when O1 supports it.  This is the
     equivalent of the Python statement `O1 %= O2'.

`PyObject* PyNumber_InPlacePower(PyObject *o1, PyObject *o2, PyObject *o3)'
     See the built-in function `pow()'.  Returns `NULL' on failure.
     The operation is done _in-place_ when O1 supports it.  This is the
     equivalent of the Python statement `O1 **= O2' when o3 is
     `Py_None', or an in-place variant of `pow(O1, O2, O3)' otherwise.
     If O3 is to be ignored, pass `Py_None' in its place (passing
     `NULL' for O3 would cause an illegal memory access).

`PyObject* PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2)'
     Returns the result of left shifting O1 by O2 on success, or `NULL'
     on failure.  The operation is done _in-place_ when O1 supports it.
     This is the equivalent of the Python statement `O1 <`<=' O2'.

`PyObject* PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2)'
     Returns the result of right shifting O1 by O2 on success, or
     `NULL' on failure.  The operation is done _in-place_ when O1
     supports it.  This is the equivalent of the Python statement `O1
     >`>=' O2'.

`PyObject* PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2)'
     Returns the "bitwise and" of O1 and O2 on success and `NULL' on
     failure. The operation is done _in-place_ when O1 supports it.
     This is the equivalent of the Python statement `O1 &= O2'.

`PyObject* PyNumber_InPlaceXor(PyObject *o1, PyObject *o2)'
     Returns the "bitwise exclusive or" of O1 by O2 on success, or
     `NULL' on failure.  The operation is done _in-place_ when O1
     supports it.  This is the equivalent of the Python statement `O1
     ^= O2'.

`PyObject* PyNumber_InPlaceOr(PyObject *o1, PyObject *o2)'
     Returns the "bitwise or" of O1 and O2 on success, or `NULL' on
     failure.  The operation is done _in-place_ when O1 supports it.
     This is the equivalent of the Python statement `O1 |= O2'.

`int PyNumber_Coerce(PyObject **p1, PyObject **p2)'
     This function takes the addresses of two variables of type
     `PyObject*'.  If the objects pointed to by `*P1' and `*P2' have
     the same type, increment their reference count and return `0'
     (success). If the objects can be converted to a common numeric
     type, replace `*p1' and `*p2' by their converted value (with 'new'
     reference counts), and return `0'.  If no conversion is possible,
     or if some other error occurs, return `-1' (failure) and don't
     increment the reference counts.  The call `PyNumber_Coerce(&o1,
     &o2)' is equivalent to the Python statement `O1, O2 = coerce(O1,
     O2)'.

`PyObject* PyNumber_Int(PyObject *o)'
     Returns the O converted to an integer object on success, or `NULL'
     on failure.  If the argument is outside the integer range a long
     object will be returned instead. This is the equivalent of the
     Python expression `int(O)'.

`PyObject* PyNumber_Long(PyObject *o)'
     Returns the O converted to a long integer object on success, or
     `NULL' on failure.  This is the equivalent of the Python
     expression `long(O)'.

`PyObject* PyNumber_Float(PyObject *o)'
     Returns the O converted to a float object on success, or `NULL' on
     failure.  This is the equivalent of the Python expression
     `float(O)'.


File: python-api.info,  Node: Sequence Protocol,  Next: Mapping Protocol,  Prev: Number Protocol,  Up: Abstract Objects Layer

Sequence Protocol
=================

`int PySequence_Check(PyObject *o)'
     Return `1' if the object provides sequence protocol, and `0'
     otherwise.  This function always succeeds.

`int PySequence_Size(PyObject *o)'
     Returns the number of objects in sequence O on success, and `-1'
     on failure.  For objects that do not provide sequence protocol,
     this is equivalent to the Python expression `len(O)'.

`int PySequence_Length(PyObject *o)'
     Alternate name for `PySequence_Size()'.

`PyObject* PySequence_Concat(PyObject *o1, PyObject *o2)'
     Return the concatenation of O1 and O2 on success, and `NULL' on
     failure.   This is the equivalent of the Python expression `O1 +
     O2'.

`PyObject* PySequence_Repeat(PyObject *o, int count)'
     Return the result of repeating sequence object O COUNT times, or
     `NULL' on failure.  This is the equivalent of the Python
     expression `O * COUNT'.

`PyObject* PySequence_InPlaceConcat(PyObject *o1, PyObject *o2)'
     Return the concatenation of O1 and O2 on success, and `NULL' on
     failure.  The operation is done _in-place_ when O1 supports it.
     This is the equivalent of the Python expression `O1 += O2'.

`PyObject* PySequence_InPlaceRepeat(PyObject *o, int count)'
     Return the result of repeating sequence object O COUNT times, or
     `NULL' on failure.  The operation is done _in-place_ when O
     supports it.  This is the equivalent of the Python expression `O
     *= COUNT'.

`PyObject* PySequence_GetItem(PyObject *o, int i)'
     Return the Ith element of O, or `NULL' on failure.  This is the
     equivalent of the Python expression `O[I]'.

`PyObject* PySequence_GetSlice(PyObject *o, int i1, int i2)'
     Return the slice of sequence object O between I1 and I2, or `NULL'
     on failure. This is the equivalent of the Python expression
     `O[I1:I2]'.

`int PySequence_SetItem(PyObject *o, int i, PyObject *v)'
     Assign object V to the Ith element of O.  Returns `-1' on failure.
     This is the equivalent of the Python statement `O[I] = V'.  This
     function _does not_ steal a reference to V.

`int PySequence_DelItem(PyObject *o, int i)'
     Delete the Ith element of object O.  Returns `-1' on failure.
     This is the equivalent of the Python statement `del O[I]'.

`int PySequence_SetSlice(PyObject *o, int i1, int i2, PyObject *v)'
     Assign the sequence object V to the slice in sequence object O
     from I1 to I2.  This is the equivalent of the Python statement
     `O[I1:I2] = V'.

`int PySequence_DelSlice(PyObject *o, int i1, int i2)'
     Delete the slice in sequence object O from I1 to I2.  Returns `-1'
     on failure.  This is the equivalent of the Python statement `del
     O[I1:I2]'.

`PyObject* PySequence_Tuple(PyObject *o)'
     Returns the O as a tuple on success, and `NULL' on failure.  This
     is equivalent to the Python expression `tuple(O)'.

`int PySequence_Count(PyObject *o, PyObject *value)'
     Return the number of occurrences of VALUE in O, that is, return
     the number of keys for which `O[KEY] == VALUE'.  On failure,
     return `-1'.  This is equivalent to the Python expression
     `O.count(VALUE)'.

`int PySequence_Contains(PyObject *o, PyObject *value)'
     Determine if O contains VALUE.  If an item in O is equal to VALUE,
     return `1', otherwise return `0'.  On error, return `-1'.  This is
     equivalent to the Python expression `VALUE in O'.

`int PySequence_Index(PyObject *o, PyObject *value)'
     Return the first index I for which `O[I] == VALUE'.  On error,
     return `-1'.    This is equivalent to the Python expression
     `O.index(VALUE)'.

`PyObject* PySequence_List(PyObject *o)'
     Return a list object with the same contents as the arbitrary
     sequence O.  The returned list is guaranteed to be new.

`PyObject* PySequence_Tuple(PyObject *o)'
     Return a tuple object with the same contents as the arbitrary
     sequence O.  If O is a tuple, a new reference will be returned,
     otherwise a tuple will be constructed with the appropriate
     contents.

`PyObject* PySequence_Fast(PyObject *o, const char *m)'
     Returns the sequence O as a tuple, unless it is already a tuple or
     list, in which case O is returned.  Use
     `PySequence_Fast_GET_ITEM()' to access the members of the result.
     Returns `NULL' on failure.  If the object is not a sequence,
     raises `TypeError' with M as the message text.

`PyObject* PySequence_Fast_GET_ITEM(PyObject *o, int i)'
     Return the Ith element of O, assuming that O was returned by
     `PySequence_Fast()', O is not `NULL', and that I is within bounds.

`PyObject* PySequence_ITEM(PyObject *o, int i)'
     Return the Ith element of O or `NULL' on failure.  Macro form of
     `PySequence_GetItem()' but without checking that
     `PySequence_Check(O)' is true and without adjustment for negative
     indices.  _Added in Python version 2.3_

`int PySequence_Fast_GET_SIZE(PyObject *o)'
     Returns the length of O, assuming that O was returned by
     `PySequence_Fast()' and that O is not `NULL'.  The size can also
     be gotten by calling `PySequence_Size()' on O, but
     `PySequence_Fast_GET_SIZE()' is faster because it can assume O is
     a list or tuple.


File: python-api.info,  Node: Mapping Protocol,  Next: Iterator Protocol,  Prev: Sequence Protocol,  Up: Abstract Objects Layer

Mapping Protocol
================

`int PyMapping_Check(PyObject *o)'
     Return `1' if the object provides mapping protocol, and `0'
     otherwise.  This function always succeeds.

`int PyMapping_Length(PyObject *o)'
     Returns the number of keys in object O on success, and `-1' on
     failure.  For objects that do not provide mapping protocol, this
     is equivalent to the Python expression `len(O)'.

`int PyMapping_DelItemString(PyObject *o, char *key)'
     Remove the mapping for object KEY from the object O.  Return `-1'
     on failure.  This is equivalent to the Python statement `del
     O[KEY]'.

`int PyMapping_DelItem(PyObject *o, PyObject *key)'
     Remove the mapping for object KEY from the object O.  Return `-1'
     on failure.  This is equivalent to the Python statement `del
     O[KEY]'.

`int PyMapping_HasKeyString(PyObject *o, char *key)'
     On success, return `1' if the mapping object has the key KEY and
     `0' otherwise.  This is equivalent to the Python expression
     `O.has_key(KEY)'.  This function always succeeds.

`int PyMapping_HasKey(PyObject *o, PyObject *key)'
     Return `1' if the mapping object has the key KEY and `0'
     otherwise.  This is equivalent to the Python expression
     `O.has_key(KEY)'.  This function always succeeds.

`PyObject* PyMapping_Keys(PyObject *o)'
     On success, return a list of the keys in object O.  On failure,
     return `NULL'. This is equivalent to the Python expression
     `O.keys()'.

`PyObject* PyMapping_Values(PyObject *o)'
     On success, return a list of the values in object O.  On failure,
     return `NULL'. This is equivalent to the Python expression
     `O.values()'.

`PyObject* PyMapping_Items(PyObject *o)'
     On success, return a list of the items in object O, where each
     item is a tuple containing a key-value pair.  On failure, return
     `NULL'. This is equivalent to the Python expression `O.items()'.

`PyObject* PyMapping_GetItemString(PyObject *o, char *key)'
     Return element of O corresponding to the object KEY or `NULL' on
     failure. This is the equivalent of the Python expression `O[KEY]'.

`int PyMapping_SetItemString(PyObject *o, char *key, PyObject *v)'
     Map the object KEY to the value V in object O.  Returns `-1' on
     failure.  This is the equivalent of the Python statement `O[KEY] =
     V'.


File: python-api.info,  Node: Iterator Protocol,  Next: Buffer Protocol,  Prev: Mapping Protocol,  Up: Abstract Objects Layer

Iterator Protocol
=================

_Added in Python version 2.2_

There are only a couple of functions specifically for working with
iterators.

`int PyIter_Check(PyObject *o)'
     Return true if the object O supports the iterator protocol.

`PyObject* PyIter_Next(PyObject *o)'
     Return the next value from the iteration O.  If the object is an
     iterator, this retrieves the next value from the iteration, and
     returns `NULL' with no exception set if there are no remaining
     items.  If the object is not an iterator, `TypeError' is raised,
     or if there is an error in retrieving the item, returns `NULL' and
     passes along the exception.

To write a loop which iterates over an iterator, the C code should look
something like this:

     PyObject *iterator = PyObject_GetIter(obj);
     PyObject *item;
     
     if (iterator == NULL) {
         /* propagate error */
     }
     
     while (item = PyIter_Next(iterator)) {
         /* do something with item */
         ...
         /* release reference when done */
         Py_DECREF(item);
     }
     
     Py_DECREF(iterator);
     
     if (PyErr_Occurred()) {
         /* propagate error */
     }
     else {
         /* continue doing useful work */
     }


File: python-api.info,  Node: Buffer Protocol,  Prev: Iterator Protocol,  Up: Abstract Objects Layer

Buffer Protocol
===============

`int PyObject_AsCharBuffer(PyObject *obj, const char **buffer, int *buffer_len)'
     Returns a pointer to a read-only memory location useable as
     character- based input.  The OBJ argument must support the
     single-segment character buffer interface.  On success, returns
     `0', sets BUFFER to the memory location and BUFFER_LEN to the
     buffer length.  Returns `-1' and sets a `TypeError' on error.
     _Added in Python version 1.6_

`int PyObject_AsReadBuffer(PyObject *obj, const char **buffer, int *buffer_len)'
     Returns a pointer to a read-only memory location containing
     arbitrary data.  The OBJ argument must support the single-segment
     readable buffer interface.  On success, returns `0', sets BUFFER
     to the memory location and BUFFER_LEN to the buffer length.
     Returns `-1' and sets a `TypeError' on error.  _Added in Python
     version 1.6_

`int PyObject_CheckReadBuffer(PyObject *o)'
     Returns `1' if O supports the single-segment readable buffer
     interface.  Otherwise returns `0'.  _Added in Python version 2.2_

`int PyObject_AsWriteBuffer(PyObject *obj, char **buffer, int *buffer_len)'
     Returns a pointer to a writeable memory location.  The OBJ
     argument must support the single-segment, character buffer
     interface.  On success, returns `0', sets BUFFER to the memory
     location and BUFFER_LEN to the buffer length.  Returns `-1' and
     sets a `TypeError' on error.  _Added in Python version 1.6_


File: python-api.info,  Node: Concrete Objects Layer,  Next: Initialization,  Prev: Abstract Objects Layer,  Up: Top

Concrete Objects Layer
**********************

The functions in this chapter are specific to certain Python object
types.  Passing them an object of the wrong type is not a good idea; if
you receive an object from a Python program and you are not sure that
it has the right type, you must perform a type check first; for
example, to check that an object is a dictionary, use `PyDict_Check()'.
The chapter is structured like the "family tree" of Python object
types.

_While the functions described in this chapter carefully check the type
of the objects which are passed in, many of them do not check for
`NULL' being passed instead of a valid object.  Allowing `NULL' to be
passed in can cause memory access violations and immediate termination
of the interpreter._

* Menu:

* Fundamental Objects::
* Numeric Objects::
* Sequence Objects::
* Mapping Objects::
* Other Objects::


File: python-api.info,  Node: Fundamental Objects,  Next: Numeric Objects,  Prev: Concrete Objects Layer,  Up: Concrete Objects Layer

Fundamental Objects
===================

This section describes Python type objects and the singleton object
`None'.

* Menu:

* Type Objects::
* None Object::


File: python-api.info,  Node: Type Objects,  Next: None Object,  Prev: Fundamental Objects,  Up: Fundamental Objects

Type Objects
------------

`PyTypeObject'
     The C structure of the objects used to describe built-in types.

`PyObject* PyType_Type'
     This is the type object for type objects; it is the same object as
     `types.TypeType' in the Python layer.

`int PyType_Check(PyObject *o)'
     Returns true if the object O is a type object, including instances
     of types derived from the standard type object.  Returns false in
     all other cases.

`int PyType_CheckExact(PyObject *o)'
     Returns true if the object O is a type object, but not a subtype
     of the standard type object.  Returns false in all other cases.
     _Added in Python version 2.2_

`int PyType_HasFeature(PyObject *o, int feature)'
     Returns true if the type object O sets the feature FEATURE.  Type
     features are denoted by single bit flags.

`int PyType_IS_GC(PyObject *o)'
     Return true if the type object includes support for the cycle
     detector; this tests the type flag `Py_TPFLAGS_HAVE_GC'.  _Added
     in Python version 2.0_

`int PyType_IsSubtype(PyTypeObject *a, PyTypeObject *b)'
     Returns true if A is a subtype of B.  _Added in Python version 2.2_

`PyObject* PyType_GenericAlloc(PyTypeObject *type, int nitems)'
     _Added in Python version 2.2_

`PyObject* PyType_GenericNew(PyTypeObject *type, PyObject *args, PyObject *kwds)'
     _Added in Python version 2.2_

`int PyType_Ready(PyTypeObject *type)'
     Finalize a type object.  This should be called on all type objects
     to finish their initialization.  This function is responsible for
     adding inherited slots from a type's base class.  Returns `0' on
     success, or returns `-1' and sets an exception on error.  _Added
     in Python version 2.2_


File: python-api.info,  Node: None Object,  Prev: Type Objects,  Up: Fundamental Objects

The None Object
---------------

Note that the `PyTypeObject' for `None' is not directly exposed in the
Python/C API.  Since `None' is a singleton, testing for object identity
(using `==' in C) is sufficient.  There is no `PyNone_Check()' function
for the same reason.

`PyObject* Py_None'
     The Python `None' object, denoting lack of value.  This object has
     no methods.  It needs to be treated just like any other object
     with respect to reference counts.


File: python-api.info,  Node: Numeric Objects,  Next: Sequence Objects,  Prev: Fundamental Objects,  Up: Concrete Objects Layer

Numeric Objects
===============

* Menu:

* Plain Integer Objects::
* Long Integer Objects::
* Floating Point Objects::
* Complex Number Objects::


File: python-api.info,  Node: Plain Integer Objects,  Next: Long Integer Objects,  Prev: Numeric Objects,  Up: Numeric Objects

Plain Integer Objects
---------------------

`PyIntObject'
     This subtype of `PyObject' represents a Python integer object.

`PyTypeObject PyInt_Type'
     This instance of `PyTypeObject' represents the Python plain
     integer type.  This is the same object as `types.IntType'.

`int PyInt_Check(PyObject* o)'
     Returns true if O is of type `PyInt_Type' or a subtype of
     `PyInt_Type'.  _Changed in Python version 2.2_

`int PyInt_CheckExact(PyObject* o)'
     Returns true if O is of type `PyInt_Type', but not a subtype of
     `PyInt_Type'.  _Added in Python version 2.2_

`PyObject* PyInt_FromString(char *str, char **pend, int base)'
     Return a new `PyIntObject' or `PyLongObject' based on the string
     value in STR, which is interpreted according to the radix in BASE.
     If PEND is non-`NULL', `*PEND' will point to the first character
     in STR which follows the representation of the number.  If BASE is
     `0', the radix will be determined based on the leading characters
     of STR: if STR starts with `'0x'' or `'0X'', radix 16 will be
     used; if STR starts with `'0'', radix 8 will be used; otherwise
     radix 10 will be used.  If BASE is not `0', it must be between `2'
     and `36', inclusive.  Leading spaces are ignored.  If there are no
     digits, `ValueError' will be raised.  If the string represents a
     number too large to be contained within the machine's `long int'
     type and overflow warnings are being suppressed, a `PyLongObject'
     will be returned.  If overflow warnings are not being suppressed,
     `NULL' will be returned in this case.

`PyObject* PyInt_FromLong(long ival)'
     Creates a new integer object with a value of IVAL.

     The current implementation keeps an array of integer objects for
     all integers between `-1' and `100', when you create an int in
     that range you actually just get back a reference to the existing
     object. So it should be possible to change the value of `1'.  I
     suspect the behaviour of Python in this case is undefined. :-)

`long PyInt_AsLong(PyObject *io)'
     Will first attempt to cast the object to a `PyIntObject', if it is
     not already one, and then return its value.

`long PyInt_AS_LONG(PyObject *io)'
     Returns the value of the object IO.  No error checking is
     performed.

`unsigned long PyInt_AsUnsignedLongMask(PyObject *io)'
     Will first attempt to cast the object to a `PyIntObject' or
     `PyLongObject', if it is not already one, and then return its
     value as unsigned long.  This function does not check for overflow.
     _Added in Python version 2.3_

`unsigned long PyInt_AsUnsignedLongLongMask(PyObject *io)'
     Will first attempt to cast the object to a `PyIntObject' or
     `PyLongObject', if it is not already one, and then return its
     value as unsigned long long, without checking for overflow.
     _Added in Python version 2.3_

`long PyInt_GetMax()'
     Returns the system's idea of the largest integer it can handle
     (`LONG_MAX' , as defined in the system header files).


File: python-api.info,  Node: Long Integer Objects,  Next: Floating Point Objects,  Prev: Plain Integer Objects,  Up: Numeric Objects

Long Integer Objects
--------------------

`PyLongObject'
     This subtype of `PyObject' represents a Python long integer object.

`PyTypeObject PyLong_Type'
     This instance of `PyTypeObject' represents the Python long integer
     type.  This is the same object as `types.LongType'.

`int PyLong_Check(PyObject *p)'
     Returns true if its argument is a `PyLongObject' or a subtype of
     `PyLongObject'.  _Changed in Python version 2.2_

`int PyLong_CheckExact(PyObject *p)'
     Returns true if its argument is a `PyLongObject', but not a
     subtype of `PyLongObject'.  _Added in Python version 2.2_

`PyObject* PyLong_FromLong(long v)'
     Returns a new `PyLongObject' object from V, or `NULL' on failure.

`PyObject* PyLong_FromUnsignedLong(unsigned long v)'
     Returns a new `PyLongObject' object from a C `unsigned long', or
     `NULL' on failure.

`PyObject* PyLong_FromLongLong(long long v)'
     Returns a new `PyLongObject' object from a C `long long', or
     `NULL' on failure.

`PyObject* PyLong_FromUnsignedLongLong(unsigned long long v)'
     Returns a new `PyLongObject' object from a C `unsigned long long',
     or `NULL' on failure.

`PyObject* PyLong_FromDouble(double v)'
     Returns a new `PyLongObject' object from the integer part of V, or
     `NULL' on failure.

`PyObject* PyLong_FromString(char *str, char **pend, int base)'
     Return a new `PyLongObject' based on the string value in STR,
     which is interpreted according to the radix in BASE.  If PEND is
     non-`NULL', `*PEND' will point to the first character in STR which
     follows the representation of the number.  If BASE is `0', the
     radix will be determined based on the leading characters of STR: if
     STR starts with `'0x'' or `'0X'', radix 16 will be used; if STR
     starts with `'0'', radix 8 will be used; otherwise radix 10 will
     be used.  If BASE is not `0', it must be between `2' and `36',
     inclusive.  Leading spaces are ignored.  If there are no digits,
     `ValueError' will be raised.

`PyObject* PyLong_FromUnicode(Py_UNICODE *u, int length, int base)'
     Convert a sequence of Unicode digits to a Python long integer
     value.  The first parameter, U, points to the first character of
     the Unicode string, LENGTH gives the number of characters, and
     BASE is the radix for the conversion.  The radix must be in the
     range [2, 36]; if it is out of range, `ValueError' will be raised.
     _Added in Python version 1.6_

`PyObject* PyLong_FromVoidPtr(void *p)'
     Create a Python integer or long integer from the pointer P.  The
     pointer value can be retrieved from the resulting value using
     `PyLong_AsVoidPtr()'.  _Added in Python version 1.5.2_

`long PyLong_AsLong(PyObject *pylong)'
     Returns a C `long' representation of the contents of PYLONG.  If
     PYLONG is greater than `LONG_MAX' , an `OverflowError' is raised.

`unsigned long PyLong_AsUnsignedLong(PyObject *pylong)'
     Returns a C `unsigned long' representation of the contents of
     PYLONG.  If PYLONG is greater than `ULONG_MAX' , an
     `OverflowError' is raised.

`long long PyLong_AsLongLong(PyObject *pylong)'
     Return a C `long long' from a Python long integer.  If PYLONG
     cannot be represented as a `long long', an `OverflowError' will be
     raised.  _Added in Python version 2.2_

`unsigned long long PyLong_AsUnsignedLongLong(PyObject *pylong)'
     Return a C `unsigned long long' from a Python long integer.  If
     PYLONG cannot be represented as an `unsigned long long', an
     `OverflowError' will be raised if the value is positive, or a
     `TypeError' will be raised if the value is negative.  _Added in
     Python version 2.2_

`unsigned long PyLong_AsUnsignedLongMask(PyObject *io)'
     Return a C `unsigned long' from a Python long integer, without
     checking for overflow.  _Added in Python version 2.3_

`unsigned long PyLong_AsUnsignedLongLongMask(PyObject *io)'
     Return a C `unsigned long long' from a Python long integer, without
     checking for overflow.  _Added in Python version 2.3_

`double PyLong_AsDouble(PyObject *pylong)'
     Returns a C `double' representation of the contents of PYLONG.  If
     PYLONG cannot be approximately represented as a `double', an
     `OverflowError' exception is raised and `-1.0' will be returned.

`void* PyLong_AsVoidPtr(PyObject *pylong)'
     Convert a Python integer or long integer PYLONG to a C `void'
     pointer.  If PYLONG cannot be converted, an `OverflowError' will
     be raised.  This is only assured to produce a usable `void'
     pointer for values created with `PyLong_FromVoidPtr()'.  _Added in
     Python version 1.5.2_


File: python-api.info,  Node: Floating Point Objects,  Next: Complex Number Objects,  Prev: Long Integer Objects,  Up: Numeric Objects

Floating Point Objects
----------------------

`PyFloatObject'
     This subtype of `PyObject' represents a Python floating point
     object.

`PyTypeObject PyFloat_Type'
     This instance of `PyTypeObject' represents the Python floating
     point type.  This is the same object as `types.FloatType'.

`int PyFloat_Check(PyObject *p)'
     Returns true if its argument is a `PyFloatObject' or a subtype of
     `PyFloatObject'.  _Changed in Python version 2.2_

`int PyFloat_CheckExact(PyObject *p)'
     Returns true if its argument is a `PyFloatObject', but not a
     subtype of `PyFloatObject'.  _Added in Python version 2.2_

`PyObject* PyFloat_FromString(PyObject *str, char **pend)'
     Creates a `PyFloatObject' object based on the string value in STR,
     or `NULL' on failure.  The PEND argument is ignored.  It remains
     only for backward compatibility.

`PyObject* PyFloat_FromDouble(double v)'
     Creates a `PyFloatObject' object from V, or `NULL' on failure.

`double PyFloat_AsDouble(PyObject *pyfloat)'
     Returns a C `double' representation of the contents of PYFLOAT.

`double PyFloat_AS_DOUBLE(PyObject *pyfloat)'
     Returns a C `double' representation of the contents of PYFLOAT,
     but without error checking.


File: python-api.info,  Node: Complex Number Objects,  Prev: Floating Point Objects,  Up: Numeric Objects

Complex Number Objects
----------------------

Python's complex number objects are implemented as two distinct types
when viewed from the C API:  one is the Python object exposed to Python
programs, and the other is a C structure which represents the actual
complex number value.  The API provides functions for working with both.

* Menu:

* Complex Numbers as C Structures::
* Complex Numbers as Python Objects::


File: python-api.info,  Node: Complex Numbers as C Structures,  Next: Complex Numbers as Python Objects,  Prev: Complex Number Objects,  Up: Complex Number Objects

Complex Numbers as C Structures
...............................

Note that the functions which accept these structures as parameters and
return them as results do so _by value_ rather than dereferencing them
through pointers.  This is consistent throughout the API.

`Py_complex'
     The C structure which corresponds to the value portion of a Python
     complex number object.  Most of the functions for dealing with
     complex number objects use structures of this type as input or
     output values, as appropriate.  It is defined as:

          typedef struct {
             double real;
             double imag;
          } Py_complex;

`Py_complex _Py_c_sum(Py_complex left, Py_complex right)'
     Return the sum of two complex numbers, using the C `Py_complex'
     representation.

`Py_complex _Py_c_diff(Py_complex left, Py_complex right)'
     Return the difference between two complex numbers, using the C
     `Py_complex' representation.

`Py_complex _Py_c_neg(Py_complex complex)'
     Return the negation of the complex number COMPLEX, using the C
     `Py_complex' representation.

`Py_complex _Py_c_prod(Py_complex left, Py_complex right)'
     Return the product of two complex numbers, using the C
     `Py_complex' representation.

`Py_complex _Py_c_quot(Py_complex dividend, Py_complex divisor)'
     Return the quotient of two complex numbers, using the C
     `Py_complex' representation.

`Py_complex _Py_c_pow(Py_complex num, Py_complex exp)'
     Return the exponentiation of NUM by EXP, using the C `Py_complex'
     representation.

