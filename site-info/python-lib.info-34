This is python-lib.info, produced by makeinfo version 4.3 from
python-lib.texi.

October 3, 2003


File: python-lib.info,  Node: Representing an email message,  Next: Parsing email messages,  Prev: email,  Up: email

Representing an email message
-----------------------------

The base class representing email messages.

The central class in the `email' package is the `Message' class; it is
the base class for the `email' object model.  `Message' provides the
core functionality for setting and querying header fields, and for
accessing message bodies.

Conceptually, a `Message' object consists of _headers_ and _payloads_.
Headers are RFC 2822 style field names and values where the field name
and value are separated by a colon.  The colon is not part of either
the field name or the field value.

Headers are stored and returned in case-preserving form but are matched
case-insensitively.  There may also be a single envelope header, also
known as the _Unix-From_ header or the `From_' header.  The payload is
either a string in the case of simple message objects or a list of
`Message' objects for MIME container documents (e.g. `multipart/*' and
`message/rfc822').

`Message' objects provide a mapping style interface for accessing the
message headers, and an explicit interface for accessing both the
headers and the payload.  It provides convenience methods for
generating a flat text representation of the message object tree, for
accessing commonly used header parameters, and for recursively walking
over the object tree.

Here are the methods of the `Message' class:

`Message()'
     The constructor takes no arguments.

`as_string([unixfrom])'
     Return the entire message flatten as a string.  When optional
     UNIXFROM is `True', the envelope header is included in the
     returned string.  UNIXFROM defaults to `False'.

     Note that this method is provided as a convenience and may not
     always format the message the way you want.  For more flexibility,
     instantiate a `Generator' instance and use its `flatten()' method
     directly.  For example:

          from cStringIO import StringIO
          from email.Generator import Generator
          fp = StringIO()
          g = Generator(mangle_from_=False, maxheaderlen=60)
          g.flatten(msg)
          text = fp.getvalue()

`__str__()'
     Equivalent to `as_string(unixfrom=True)'.

`is_multipart()'
     Return `True' if the message's payload is a list of sub-`Message'
     objects, otherwise return `False'.  When `is_multipart()' returns
     False, the payload should be a string object.

`set_unixfrom(unixfrom)'
     Set the message's envelope header to UNIXFROM, which should be a
     string.

`get_unixfrom()'
     Return the message's envelope header.  Defaults to `None' if the
     envelope header was never set.

`attach(payload)'
     Add the given PAYLOAD to the current payload, which must be `None'
     or a list of `Message' objects before the call.  After the call,
     the payload will always be a list of `Message' objects.  If you
     want to set the payload to a scalar object (e.g. a string), use
     `set_payload()' instead.

`get_payload([i[, decode]])'
     Return a reference the current payload, which will be a list of
     `Message' objects when `is_multipart()' is `True', or a string
     when `is_multipart()' is `False'.  If the payload is a list and
     you mutate the list object, you modify the message's payload in
     place.

     With optional argument I, `get_payload()' will return the I-th
     element of the payload, counting from zero, if `is_multipart()' is
     `True'.  An `IndexError' will be raised if I is less than 0 or
     greater than or equal to the number of items in the payload.  If
     the payload is a string (i.e. `is_multipart()' is `False') and I
     is given, a `TypeError' is raised.

     Optional DECODE is a flag indicating whether the payload should be
     decoded or not, according to the `Content-Transfer-Encoding'
     header.  When `True' and the message is not a multipart, the
     payload will be decoded if this header's value is
     `quoted-printable' or `base64'.  If some other encoding is used, or
     `Content-Transfer-Encoding' header is missing, or if the payload
     has bogus base64 data, the payload is returned as-is (undecoded).
     If the message is a multipart and the DECODE flag is `True', then
     `None' is returned.  The default for DECODE is `False'.

`set_payload(payload[, charset])'
     Set the entire message object's payload to PAYLOAD.  It is the
     client's responsibility to ensure the payload invariants.  Optional
     CHARSET sets the message's default character set; see
     `set_charset()' for details.

     _Changed in Python version 2.2.2_

`set_charset(charset)'
     Set the character set of the payload to CHARSET, which can either
     be a `Charset' instance (see `email.Charset'), a string naming a
     character set, or `None'.  If it is a string, it will be converted
     to a `Charset' instance.  If CHARSET is `None', the `charset'
     parameter will be removed from the `Content-Type' header. Anything
     else will generate a `TypeError'.

     The message will be assumed to be of type `text/*' encoded with
     `charset.input_charset'.  It will be converted to
     `charset.output_charset' and encoded properly, if needed, when
     generating the plain text representation of the message.  MIME
     headers (`MIME-Version', `Content-Type',
     `Content-Transfer-Encoding') will be added as needed.

     _Added in Python version 2.2.2_

`get_charset()'
     Return the `Charset' instance associated with the message's
     payload.  _Added in Python version 2.2.2_

The following methods implement a mapping-like interface for accessing
the message's RFC 2822 headers.  Note that there are some semantic
differences between these methods and a normal mapping (i.e.
dictionary) interface.  For example, in a dictionary there are no
duplicate keys, but here there may be duplicate message headers.  Also,
in dictionaries there is no guaranteed order to the keys returned by
`keys()', but in a `Message' object, headers are always returned in the
order they appeared in the original message, or were added to the
message later.  Any header deleted and then re-added are always
appended to the end of the header list.

These semantic differences are intentional and are biased toward
maximal convenience.

Note that in all cases, any envelope header present in the message is
not included in the mapping interface.

`__len__()'
     Return the total number of headers, including duplicates.

`__contains__(name)'
     Return true if the message object has a field named NAME.
     Matching is done case-insensitively and NAME should not include the
     trailing colon.  Used for the `in' operator, e.g.:

          if 'message-id' in myMessage:
              print 'Message-ID:', myMessage['message-id']

`__getitem__(name)'
     Return the value of the named header field.  NAME should not
     include the colon field separator.  If the header is missing,
     `None' is returned; a `KeyError' is never raised.

     Note that if the named field appears more than once in the
     message's headers, exactly which of those field values will be
     returned is undefined.  Use the `get_all()' method to get the
     values of all the extant named headers.

`__setitem__(name, val)'
     Add a header to the message with field name NAME and value VAL.
     The field is appended to the end of the message's existing fields.

     Note that this does _not_ overwrite or delete any existing header
     with the same name.  If you want to ensure that the new header is
     the only one present in the message with field name NAME, delete
     the field first, e.g.:

          del msg['subject']
          msg['subject'] = 'Python roolz!'

`__delitem__(name)'
     Delete all occurrences of the field with name NAME from the
     message's headers.  No exception is raised if the named field isn't
     present in the headers.

`has_key(name)'
     Return true if the message contains a header field named NAME,
     otherwise return false.

`keys()'
     Return a list of all the message's header field names.

`values()'
     Return a list of all the message's field values.

`items()'
     Return a list of 2-tuples containing all the message's field
     headers and values.

`get(name[, failobj])'
     Return the value of the named header field.  This is identical to
     `__getitem__()' except that optional FAILOBJ is returned if the
     named header is missing (defaults to `None').

Here are some additional useful methods:

`get_all(name[, failobj])'
     Return a list of all the values for the field named NAME.  If
     there are no such named headers in the message, FAILOBJ is
     returned (defaults to `None').

`add_header(_name, _value, **_params)'
     Extended header setting.  This method is similar to
     `__setitem__()' except that additional header parameters can be
     provided as keyword arguments.  _NAME is the header field to add
     and _VALUE is the _primary_ value for the header.

     For each item in the keyword argument dictionary _PARAMS, the key
     is taken as the parameter name, with underscores converted to
     dashes (since dashes are illegal in Python identifiers).  Normally,
     the parameter will be added as `key="value"' unless the value is
     `None', in which case only the key will be added.

     Here's an example:

          msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')

     This will add a header that looks like

          Content-Disposition: attachment; filename="bud.gif"

`replace_header(_name, _value)'
     Replace a header.  Replace the first header found in the message
     that matches _NAME, retaining header order and field name case.  If
     no matching header was found, a `KeyError' is raised.

     _Added in Python version 2.2.2_

`get_content_type()'
     Return the message's content type.  The returned string is coerced
     to lower case of the form `maintype/subtype'.  If there was no
     `Content-Type' header in the message the default type as given by
     `get_default_type()' will be returned.  Since according to RFC 2045
     , messages always have a default type, `get_content_type()' will
     always return a value.

     RFC 2045 defines a message's default type to be `text/plain'
     unless it appears inside a `multipart/digest' container, in which
     case it would be `message/rfc822'.  If the `Content-Type' header
     has an invalid type specification, RFC 2045 mandates that the
     default type be `text/plain'.

     _Added in Python version 2.2.2_

`get_content_maintype()'
     Return the message's main content type.  This is the `maintype'
     part of the string returned by `get_content_type()'.

     _Added in Python version 2.2.2_

`get_content_subtype()'
     Return the message's sub-content type.  This is the `subtype' part
     of the string returned by `get_content_type()'.

     _Added in Python version 2.2.2_

`get_default_type()'
     Return the default content type.  Most messages have a default
     content type of `text/plain', except for messages that are subparts
     of `multipart/digest' containers.  Such subparts have a default
     content type of `message/rfc822'.

     _Added in Python version 2.2.2_

`set_default_type(ctype)'
     Set the default content type.  CTYPE should either be `text/plain'
     or `message/rfc822', although this is not enforced.  The default
     content type is not stored in the `Content-Type' header.

     _Added in Python version 2.2.2_

`get_params([failobj[, header[, unquote]]])'
     Return the message's `Content-Type' parameters, as a list.  The
     elements of the returned list are 2-tuples of key/value pairs, as
     split on the `=' sign.  The left hand side of the `=' is the key,
     while the right hand side is the value.  If there is no `=' sign
     in the parameter the value is the empty string, otherwise the
     value is as described in `get_param()' and is unquoted if optional
     UNQUOTE is `True' (the default).

     Optional FAILOBJ is the object to return if there is no
     `Content-Type' header.  Optional HEADER is the header to search
     instead of `Content-Type'.

     _Changed in Python version 2.2.2_

`get_param(param[, failobj[, header[, unquote]]])'
     Return the value of the `Content-Type' header's parameter PARAM as
     a string.  If the message has no `Content-Type' header or if there
     is no such parameter, then FAILOBJ is returned (defaults to
     `None').

     Optional HEADER if given, specifies the message header to use
     instead of `Content-Type'.

     Parameter keys are always compared case insensitively.  The return
     value can either be a string, or a 3-tuple if the parameter was
     RFC 2231 encoded.  When it's a 3-tuple, the elements of the value
     are of the form `(CHARSET, LANGUAGE, VALUE)'.  Note that both
     `CHARSET' and `LANGUAGE' can be `None', in which case you should
     consider `VALUE' to be encoded in the `us-ascii' charset.  You can
     usually ignore `LANGUAGE'.

     Your application should be prepared to deal with 3-tuple return
     values, and can convert the parameter to a Unicode string like so:

          param = msg.get_param('foo')
          if isinstance(param, tuple):
              param = unicode(param[2], param[0] or 'us-ascii')

     In any case, the parameter value (either the returned string, or
     the `VALUE' item in the 3-tuple) is always unquoted, unless
     UNQUOTE is set to `False'.

     _Changed in Python version 2.2.2_

`set_param(param, value[, header[, requote[, charset[, language]]]])'
     Set a parameter in the `Content-Type' header.  If the parameter
     already exists in the header, its value will be replaced with
     VALUE.  If the `Content-Type' header as not yet been defined for
     this message, it will be set to `text/plain' and the new parameter
     value will be appended as per RFC 2045 .

     Optional HEADER specifies an alternative header to `Content-Type',
     and all parameters will be quoted as necessary unless optional
     REQUOTE is `False' (the default is `True').

     If optional CHARSET is specified, the parameter will be encoded
     according to RFC 2231 . Optional LANGUAGE specifies the RFC 2231
     language, defaulting to the empty string.  Both CHARSET and
     LANGUAGE should be strings.

     _Added in Python version 2.2.2_

`del_param(param[, header[, requote]])'
     Remove the given parameter completely from the `Content-Type'
     header.  The header will be re-written in place without the
     parameter or its value.  All values will be quoted as necessary
     unless REQUOTE is `False' (the default is `True').  Optional
     HEADER specifies an alternative to `Content-Type'.

     _Added in Python version 2.2.2_

`set_type(type[, header][, requote])'
     Set the main type and subtype for the `Content-Type' header. TYPE
     must be a string in the form `maintype/subtype', otherwise a
     `ValueError' is raised.

     This method replaces the `Content-Type' header, keeping all the
     parameters in place.  If REQUOTE is `False', this leaves the
     existing header's quoting as is, otherwise the parameters will be
     quoted (the default).

     An alternative header can be specified in the HEADER argument.
     When the `Content-Type' header is set a `MIME-Version' header is
     also added.

     _Added in Python version 2.2.2_

`get_filename([failobj])'
     Return the value of the `filename' parameter of the
     `Content-Disposition' header of the message, or FAILOBJ if either
     the header is missing, or has no `filename' parameter.  The
     returned string will always be unquoted as per `Utils.unquote()'.

`get_boundary([failobj])'
     Return the value of the `boundary' parameter of the `Content-Type'
     header of the message, or FAILOBJ if either the header is missing,
     or has no `boundary' parameter.  The returned string will always
     be unquoted as per `Utils.unquote()'.

`set_boundary(boundary)'
     Set the `boundary' parameter of the `Content-Type' header to
     BOUNDARY.  `set_boundary()' will always quote BOUNDARY if
     necessary.  A `HeaderParseError' is raised if the message object
     has no `Content-Type' header.

     Note that using this method is subtly different than deleting the
     old `Content-Type' header and adding a new one with the new
     boundary via `add_header()', because `set_boundary()' preserves the
     order of the `Content-Type' header in the list of headers.
     However, it does _not_ preserve any continuation lines which may
     have been present in the original `Content-Type' header.

`get_content_charset([failobj])'
     Return the `charset' parameter of the `Content-Type' header,
     coerced to lower case.  If there is no `Content-Type' header, or
     if that header has no `charset' parameter, FAILOBJ is returned.

     Note that this method differs from `get_charset()' which returns
     the `Charset' instance for the default encoding of the message
     body.

     _Added in Python version 2.2.2_

`get_charsets([failobj])'
     Return a list containing the character set names in the message.
     If the message is a `multipart', then the list will contain one
     element for each subpart in the payload, otherwise, it will be a
     list of length 1.

     Each item in the list will be a string which is the value of the
     `charset' parameter in the `Content-Type' header for the
     represented subpart.  However, if the subpart has no
     `Content-Type' header, no `charset' parameter, or is not of the
     `text' main MIME type, then that item in the returned list will be
     FAILOBJ.

`walk()'
     The `walk()' method is an all-purpose generator which can be used
     to iterate over all the parts and subparts of a message object
     tree, in depth-first traversal order.  You will typically use
     `walk()' as the iterator in a `for' loop; each iteration returns
     the next subpart.

     Here's an example that prints the MIME type of every part of a
     multipart message structure:

          >>> for part in msg.walk():
          >>>     print part.get_content_type()
          multipart/report
          text/plain
          message/delivery-status
          text/plain
          text/plain
          message/rfc822

`Message' objects can also optionally contain two instance attributes,
which can be used when generating the plain text of a MIME message.

`preamble'
     The format of a MIME document allows for some text between the
     blank line following the headers, and the first multipart boundary
     string.  Normally, this text is never visible in a MIME-aware mail
     reader because it falls outside the standard MIME armor.  However,
     when viewing the raw text of the message, or when viewing the
     message in a non-MIME aware reader, this text can become visible.

     The PREAMBLE attribute contains this leading extra-armor text for
     MIME documents.  When the `Parser' discovers some text after the
     headers but before the first boundary string, it assigns this text
     to the message's PREAMBLE attribute.  When the `Generator' is
     writing out the plain text representation of a MIME message, and it
     finds the message has a PREAMBLE attribute, it will write this
     text in the area between the headers and the first boundary.  See
     `email.Parser' and `email.Generator' for details.

     Note that if the message object has no preamble, the PREAMBLE
     attribute will be `None'.

`epilogue'
     The EPILOGUE attribute acts the same way as the PREAMBLE
     attribute, except that it contains text that appears between the
     last boundary and the end of the message.

     One note: when generating the flat text for a `multipart' message
     that has no EPILOGUE (using the standard `Generator' class), no
     newline is added after the closing boundary line.  If the message
     object has an EPILOGUE and its value does not start with a
     newline, a newline is printed after the closing boundary.  This
     seems a little clumsy, but it makes the most practical sense.  The
     upshot is that if you want to ensure that a newline get printed
     after your closing `multipart' boundary, set the EPILOGUE to the
     empty string.

* Menu:

* Deprecated methods::


File: python-lib.info,  Node: Deprecated methods,  Prev: Representing an email message,  Up: Representing an email message

Deprecated methods
..................

The following methods are deprecated in `email' version 2.  They are
documented here for completeness.

`add_payload(payload)'
     Add PAYLOAD to the message object's existing payload.  If, prior
     to calling this method, the object's payload was `None' (i.e.
     never before set), then after this method is called, the payload
     will be the argument PAYLOAD.

     If the object's payload was already a list (i.e. `is_multipart()'
     returns 1), then PAYLOAD is appended to the end of the existing
     payload list.

     For any other type of existing payload, `add_payload()' will
     transform the new payload into a list consisting of the old payload
     and PAYLOAD, but only if the document is already a MIME multipart
     document.  This condition is satisfied if the message's
     `Content-Type' header's main type is either `multipart', or there
     is no `Content-Type' header.  In any other situation,
     `MultipartConversionError' is raised.

     _This is deprecated in Python 2.2.2.  Use the `attach()' method
     instead._

`get_type([failobj])'
     Return the message's content type, as a string of the form
     `maintype/subtype' as taken from the `Content-Type' header.  The
     returned string is coerced to lowercase.

     If there is no `Content-Type' header in the message, FAILOBJ is
     returned (defaults to `None').

     _This is deprecated in Python 2.2.2.  Use the `get_content_type()'
     method instead._

`get_main_type([failobj])'
     Return the message's _main_ content type.  This essentially
     returns the MAINTYPE part of the string returned by `get_type()',
     with the same semantics for FAILOBJ.

     _This is deprecated in Python 2.2.2.  Use the
     `get_content_maintype()' method instead._

`get_subtype([failobj])'
     Return the message's sub-content type.  This essentially returns
     the SUBTYPE part of the string returned by `get_type()', with the
     same semantics for FAILOBJ.

     _This is deprecated in Python 2.2.2.  Use the
     `get_content_subtype()' method instead._


File: python-lib.info,  Node: Parsing email messages,  Next: Generating MIME documents,  Prev: Representing an email message,  Up: email

Parsing email messages
----------------------

Parse flat text email messages to produce a message object structure.

Message object structures can be created in one of two ways: they can be
created from whole cloth by instantiating `Message' objects and
stringing them together via `attach()' and `set_payload()' calls, or
they can be created by parsing a flat text representation of the email
message.

The `email' package provides a standard parser that understands most
email document structures, including MIME documents.  You can pass the
parser a string or a file object, and the parser will return to you the
root `Message' instance of the object structure.  For simple, non-MIME
messages the payload of this root object will likely be a string
containing the text of the message.  For MIME messages, the root object
will return `True' from its `is_multipart()' method, and the subparts
can be accessed via the `get_payload()' and `walk()' methods.

Note that the parser can be extended in limited ways, and of course you
can implement your own parser completely from scratch.  There is no
magical connection between the `email' package's bundled parser and the
`Message' class, so your custom parser can create message object trees
any way it finds necessary.

The primary parser class is `Parser' which parses both the headers and
the payload of the message.  In the case of `multipart' messages, it
will recursively parse the body of the container message.  Two modes of
parsing are supported, _strict_ parsing, which will usually reject any
non-RFC compliant message, and _lax_ parsing, which attempts to adjust
for common MIME formatting problems.

The `email.Parser' module also provides a second class, called
`HeaderParser' which can be used if you're only interested in the
headers of the message. `HeaderParser' can be much faster in these
situations, since it does not attempt to parse the message body,
instead setting the payload to the raw body as a string.
`HeaderParser' has the same API as the `Parser' class.

* Menu:

* Parser class API::
* Additional notes::


File: python-lib.info,  Node: Parser class API,  Next: Additional notes,  Prev: Parsing email messages,  Up: Parsing email messages

Parser class API
................

`Parser([_class[, strict]])'
     The constructor for the `Parser' class takes an optional argument
     _CLASS.  This must be a callable factory (such as a function or a
     class), and it is used whenever a sub-message object needs to be
     created.  It defaults to `Message' (see `email.Message').  The
     factory will be called without arguments.

     The optional STRICT flag specifies whether strict or lax parsing
     should be performed.  Normally, when things like MIME terminating
     boundaries are missing, or when messages contain other formatting
     problems, the `Parser' will raise a `MessageParseError'.  However,
     when lax parsing is enabled, the `Parser' will attempt to work
     around such broken formatting to produce a usable message
     structure (this doesn't mean `MessageParseError's are never
     raised; some ill-formatted messages just can't be parsed).  The
     STRICT flag defaults to `False' since lax parsing usually provides
     the most convenient behavior.

     _Changed in Python version 2.2.2_

The other public `Parser' methods are:

`parse(fp[, headersonly])'
     Read all the data from the file-like object FP, parse the
     resulting text, and return the root message object.  FP must
     support both the `readline()' and the `read()' methods on
     file-like objects.

     The text contained in FP must be formatted as a block of RFC 2822

     style headers and header continuation lines, optionally preceded
     by a envelope header.  The header block is terminated either by the
     end of the data or by a blank line.  Following the header block is
     the body of the message (which may contain MIME-encoded subparts).

     Optional HEADERSONLY is as with the `parse()' method.

     _Changed in Python version 2.2.2_

`parsestr(text[, headersonly])'
     Similar to the `parse()' method, except it takes a string object
     instead of a file-like object.  Calling this method on a string is
     exactly equivalent to wrapping TEXT in a `StringIO' instance first
     and calling `parse()'.

     Optional HEADERSONLY is a flag specifying whether to stop parsing
     after reading the headers or not.  The default is `False', meaning
     it parses the entire contents of the file.

     _Changed in Python version 2.2.2_

Since creating a message object structure from a string or a file
object is such a common task, two functions are provided as a
convenience.  They are available in the top-level `email' package
namespace.

`message_from_string(s[, _class[, strict]])'
     Return a message object structure from a string.  This is exactly
     equivalent to `Parser().parsestr(s)'.  Optional _CLASS and STRICT
     are interpreted as with the `Parser' class constructor.

     _Changed in Python version 2.2.2_

`message_from_file(fp[, _class[, strict]])'
     Return a message object structure tree from an open file object.
     This is exactly equivalent to `Parser().parse(fp)'.  Optional
     _CLASS and STRICT are interpreted as with the `Parser' class
     constructor.

     _Changed in Python version 2.2.2_

Here's an example of how you might use this at an interactive Python
prompt:

     >>> import email
     >>> msg = email.message_from_string(myString)


File: python-lib.info,  Node: Additional notes,  Prev: Parser class API,  Up: Parsing email messages

Additional notes
................

Here are some notes on the parsing semantics:

   * Most non-`multipart' type messages are parsed as a single message
     object with a string payload.  These objects will return `False'
     for `is_multipart()'.  Their `get_payload()' method will return a
     string object.

   * All `multipart' type messages will be parsed as a container
     message object with a list of sub-message objects for their
     payload.  The outer container message will return `True' for
     `is_multipart()' and their `get_payload()' method will return the
     list of `Message' subparts.

   * Most messages with a content type of `message/*' (e.g.
     `message/deliver-status' and `message/rfc822') will also be parsed
     as container object containing a list payload of length 1.  Their
     `is_multipart()' method will return `True'.  The single element in
     the list payload will be a sub-message object.


File: python-lib.info,  Node: Generating MIME documents,  Next: Creating email and MIME objects from scratch,  Prev: Parsing email messages,  Up: email

Generating MIME documents
-------------------------

Generate flat text email messages from a message structure.

One of the most common tasks is to generate the flat text of the email
message represented by a message object structure.  You will need to do
this if you want to send your message via the `smtplib' module or the
`nntplib' module, or print the message on the console.  Taking a
message object structure and producing a flat text document is the job
of the `Generator' class.

Again, as with the `email.Parser' module, you aren't limited to the
functionality of the bundled generator; you could write one from
scratch yourself.  However the bundled generator knows how to generate
most email in a standards-compliant way, should handle MIME and
non-MIME email messages just fine, and is designed so that the
transformation from flat text, to a message structure via the `Parser'
class, and back to flat text, is idempotent (the input is identical to
the output).

Here are the public methods of the `Generator' class:

`Generator(outfp[, mangle_from_[, maxheaderlen]])'
     The constructor for the `Generator' class takes a file-like object
     called OUTFP for an argument.  OUTFP must support the `write()'
     method and be usable as the output file in a Python extended print
     statement.

     Optional MANGLE_FROM_ is a flag that, when `True', puts a `>'
     character in front of any line in the body that starts exactly as
     `From ', i.e. `From' followed by a space at the beginning of the
     line.  This is the only guaranteed portable way to avoid having
     such lines be mistaken for a Unix mailbox format envelope header
     separator (see WHY THE CONTENT-LENGTH FORMAT IS BAD for details).
     MANGLE_FROM_ defaults to `True', but you might want to set this to
     `False' if you are not writing Unix mailbox format files.

     Optional MAXHEADERLEN specifies the longest length for a
     non-continued header.  When a header line is longer than
     MAXHEADERLEN (in characters, with tabs expanded to 8 spaces), the
     header will be broken on semicolons and continued as per RFC 2822
     .  If no semicolon is found, then the header is left alone.  Set
     to zero to disable wrapping headers.  Default is 78, as
     recommended (but not required) by RFC 2822 .

The other public `Generator' methods are:

`flatten(msg[, unixfrom])'
     Print the textual representation of the message object structure
     rooted at MSG to the output file specified when the `Generator'
     instance was created.  Subparts are visited depth-first and the
     resulting text will be properly MIME encoded.

     Optional UNIXFROM is a flag that forces the printing of the
     envelope header delimiter before the first RFC 2822 header of the
     root message object.  If the root object has no envelope header, a
     standard one is crafted.  By default, this is set to `False' to
     inhibit the printing of the envelope delimiter.

     Note that for subparts, no envelope header is ever printed.

     _Added in Python version 2.2.2_

`clone(fp)'
     Return an independent clone of this `Generator' instance with the
     exact same options.

     _Added in Python version 2.2.2_

`write(s)'
     Write the string S to the underlying file object, i.e. OUTFP
     passed to `Generator''s constructor.  This provides just enough
     file-like API for `Generator' instances to be used in extended
     print statements.

As a convenience, see the methods `Message.as_string()' and
`str(aMessage)', a.k.a. `Message.__str__()', which simplify the
generation of a formatted string representation of a message object.
For more detail, see `email.Message'.

The `email.Generator' module also provides a derived class, called
`DecodedGenerator' which is like the `Generator' base class, except
that non-`text' parts are substituted with a format string representing
the part.

`DecodedGenerator(outfp[, mangle_from_[, maxheaderlen[, fmt]]])'
     This class, derived from `Generator' walks through all the
     subparts of a message.  If the subpart is of main type `text',
     then it prints the decoded payload of the subpart.  Optional
     _MANGLE_FROM_ and MAXHEADERLEN are as with the `Generator' base
     class.

     If the subpart is not of main type `text', optional FMT is a
     format string that is used instead of the message payload.  FMT is
     expanded with the following keywords, `%(keyword)s' format:

        * `type' - Full MIME type of the non-`text' part

        * `maintype' - Main MIME type of the non-`text' part

        * `subtype' - Sub-MIME type of the non-`text' part

        * `filename' - Filename of the non-`text' part

        * `description' - Description associated with the non-`text'
          part

        * `encoding' - Content transfer encoding of the non-`text' part


     The default value for FMT is `None', meaning

          [Non-text (%(type)s) part of message omitted, filename %(filename)s]

     _Added in Python version 2.2.2_

* Menu:

* Deprecated methods 2::


File: python-lib.info,  Node: Deprecated methods 2,  Prev: Generating MIME documents,  Up: Generating MIME documents

Deprecated methods
..................

The following methods are deprecated in `email' version 2.  They are
documented here for completeness.

`__call__(msg[, unixfrom])'
     This method is identical to the `flatten()' method.

     _This is deprecated in Python 2.2.2.  Use the `flatten()' method
     instead._


File: python-lib.info,  Node: Creating email and MIME objects from scratch,  Next: Internationalized headers,  Prev: Generating MIME documents,  Up: email

Creating email and MIME objects from scratch
--------------------------------------------

Ordinarily, you get a message object structure by passing a file or
some text to a parser, which parses the text and returns the root
message object.  However you can also build a complete message
structure from scratch, or even individual `Message' objects by hand.
In fact, you can also take an existing structure and add new `Message'
objects, move them around, etc.  This makes a very convenient interface
for slicing-and-dicing MIME messages.

You can create a new object structure by creating `Message' instances,
adding attachments and all the appropriate headers manually.  For MIME
messages though, the `email' package provides some convenient
subclasses to make things easier.  Each of these classes should be
imported from a module with the same name as the class, from within the
`email' package.  E.g.:

     import email.MIMEImage.MIMEImage

or

     from email.MIMEText import MIMEText

Here are the classes:

`MIMEBase(_maintype, _subtype, **_params)'
     This is the base class for all the MIME-specific subclasses of
     `Message'.  Ordinarily you won't create instances specifically of
     `MIMEBase', although you could.  `MIMEBase' is provided primarily
     as a convenient base class for more specific MIME-aware subclasses.

     _MAINTYPE is the `Content-Type' major type (e.g. `text' or
     `image'), and _SUBTYPE is the `Content-Type' minor type (e.g.
     `plain' or `gif').  _PARAMS is a parameter key/value dictionary
     and is passed directly to `Message.add_header()'.

     The `MIMEBase' class always adds a `Content-Type' header (based on
     _MAINTYPE, _SUBTYPE, and _PARAMS), and a `MIME-Version' header
     (always set to `1.0').

`MIMENonMultipart()'
     A subclass of `MIMEBase', this is an intermediate base class for
     MIME messages that are not `multipart'.  The primary purpose of
     this class is to prevent the use of the `attach()' method, which
     only makes sense for `multipart' messages.  If `attach()' is
     called, a `MultipartConversionError' exception is raised.

     _Added in Python version 2.2.2_

`MIMEMultipart([subtype[, boundary[, _subparts[, _params]]]])'
     A subclass of `MIMEBase', this is an intermediate base class for
     MIME messages that are `multipart'.  Optional _SUBTYPE defaults to
     `mixed', but can be used to specify the subtype of the message.  A
     `Content-Type' header of `multipart/'_SUBTYPE will be added to the
     message object.  A `MIME-Version' header will also be added.

     Optional BOUNDARY is the multipart boundary string.  When `None'
     (the default), the boundary is calculated when needed.

     _SUBPARTS is a sequence of initial subparts for the payload.  It
     must be possible to convert this sequence to a list.  You can
     always attach new subparts to the message by using the
     `Message.attach()' method.

     Additional parameters for the `Content-Type' header are taken from
     the keyword arguments, or passed into the _PARAMS argument, which
     is a keyword dictionary.

     _Added in Python version 2.2.2_

`MIMEAudio(_audiodata[, _subtype[, _encoder[, **_params]]])'
     A subclass of `MIMENonMultipart', the `MIMEAudio' class is used to
     create MIME message objects of major type `audio'.  _AUDIODATA is
     a string containing the raw audio data.  If this data can be
     decoded by the standard Python module `sndhdr', then the subtype
     will be automatically included in the `Content-Type' header.
     Otherwise you can explicitly specify the audio subtype via the
     _SUBTYPE parameter.  If the minor type could not be guessed and
     _SUBTYPE was not given, then `TypeError' is raised.

     Optional _ENCODER is a callable (i.e. function) which will perform
     the actual encoding of the audio data for transport.  This
     callable takes one argument, which is the `MIMEAudio' instance.
     It should use `get_payload()' and `set_payload()' to change the
     payload to encoded form.  It should also add any
     `Content-Transfer-Encoding' or other headers to the message object
     as necessary.  The default encoding is base64.  See the
     `email.Encoders' module for a list of the built-in encoders.

     _PARAMS are passed straight through to the base class constructor.

`MIMEImage(_imagedata[, _subtype[, _encoder[, **_params]]])'
     A subclass of `MIMENonMultipart', the `MIMEImage' class is used to
     create MIME message objects of major type `image'.  _IMAGEDATA is
     a string containing the raw image data.  If this data can be
     decoded by the standard Python module `imghdr', then the subtype
     will be automatically included in the `Content-Type' header.
     Otherwise you can explicitly specify the image subtype via the
     _SUBTYPE parameter.  If the minor type could not be guessed and
     _SUBTYPE was not given, then `TypeError' is raised.

     Optional _ENCODER is a callable (i.e. function) which will perform
     the actual encoding of the image data for transport.  This
     callable takes one argument, which is the `MIMEImage' instance.
     It should use `get_payload()' and `set_payload()' to change the
     payload to encoded form.  It should also add any
     `Content-Transfer-Encoding' or other headers to the message object
     as necessary.  The default encoding is base64.  See the
     `email.Encoders' module for a list of the built-in encoders.

     _PARAMS are passed straight through to the `MIMEBase' constructor.

`MIMEMessage(_msg[, _subtype])'
     A subclass of `MIMENonMultipart', the `MIMEMessage' class is used
     to create MIME objects of main type `message'.  _MSG is used as
     the payload, and must be an instance of class `Message' (or a
     subclass thereof), otherwise a `TypeError' is raised.

     Optional _SUBTYPE sets the subtype of the message; it defaults to
     `rfc822'.

`MIMEText(_text[, _subtype[, _charset[, _encoder]]])'
     A subclass of `MIMENonMultipart', the `MIMEText' class is used to
     create MIME objects of major type `text'.  _TEXT is the string for
     the payload.  _SUBTYPE is the minor type and defaults to `plain'.
     _CHARSET is the character set of the text and is passed as a
     parameter to the `MIMENonMultipart' constructor; it defaults to
     `us-ascii'.  No guessing or encoding is performed on the text data.

     _This is deprecated in Python 2.2.2.  The _ENCODING argument has
     been deprecated. Encoding now happens implicitly based on the
     _CHARSET argument._


File: python-lib.info,  Node: Internationalized headers,  Next: Representing character sets,  Prev: Creating email and MIME objects from scratch,  Up: email

Internationalized headers
-------------------------

Representing non-ASCII headers

RFC 2822 is the base standard that describes the format of email
messages.  It derives from the older RFC 822 standard which came into
widespread use at a time when most email was composed of ASCII
characters only.  RFC 2822 is a specification written assuming email
contains only 7-bit ASCII characters.

Of course, as email has been deployed worldwide, it has become
internationalized, such that language specific character sets can now
be used in email messages.  The base standard still requires email
messages to be transfered using only 7-bit ASCII characters, so a slew
of RFCs have been written describing how to encode email containing
non-ASCII characters into RFC 2822 -compliant format.  These RFCs
include RFC 2045 , RFC 2046 , RFC 2047 , and RFC 2231 .  The `email'
package supports these standards in its `email.Header' and
`email.Charset' modules.

If you want to include non-ASCII characters in your email headers, say
in the `Subject' or `To' fields, you should use the `Header' class and
assign the field in the `Message' object to an instance of `Header'
instead of using a string for the header value.  For example:

     >>> from email.Message import Message
     >>> from email.Header import Header
     >>> msg = Message()
     >>> h = Header('p\xf6stal', 'iso-8859-1')
     >>> msg['Subject'] = h
     >>> print msg.as_string()
     Subject: =?iso-8859-1?q?p=F6stal?=

Notice here how we wanted the `Subject' field to contain a non-ASCII
character?  We did this by creating a `Header' instance and passing in
the character set that the byte string was encoded in.  When the
subsequent `Message' instance was flattened, the `Subject' field was
properly RFC 2047

encoded.  MIME-aware mail readers would show this header using the
embedded ISO-8859-1 character.

_Added in Python version 2.2.2_

Here is the `Header' class description:

`Header([s[, charset[, maxlinelen[, header_name[, continuation_ws[, errors]]]]]])'
     Create a MIME-compliant header that can contain strings in
     different character sets.

     Optional S is the initial header value.  If `None' (the default),
     the initial header value is not set.  You can later append to the
     header with `append()' method calls.  S may be a byte string or a
     Unicode string, but see the `append()' documentation for semantics.

     Optional CHARSET serves two purposes: it has the same meaning as
     the CHARSET argument to the `append()' method.  It also sets the
     default character set for all subsequent `append()' calls that
     omit the CHARSET argument.  If CHARSET is not provided in the
     constructor (the default), the `us-ascii' character set is used
     both as S's initial charset and as the default for subsequent
     `append()' calls.

     The maximum line length can be specified explicit via MAXLINELEN.
     For splitting the first line to a shorter value (to account for
     the field header which isn't included in S, e.g. `Subject') pass
     in the name of the field in HEADER_NAME.  The default MAXLINELEN
     is 76, and the default value for HEADER_NAME is `None', meaning it
     is not taken into account for the first line of a long, split
     header.

     Optional CONTINUATION_WS must be RFC 2822 -compliant folding
     whitespace, and is usually either a space or a hard tab character.
     This character will be prepended to continuation lines.

Optional ERRORS is passed straight through to the `append()' method.

`append(s[, charset[, errors]])'
     Append the string S to the MIME header.

     Optional CHARSET, if given, should be a `Charset' instance (see
     `email.Charset') or the name of a character set, which will be
     converted to a `Charset' instance.  A value of `None' (the
     default) means that the CHARSET given in the constructor is used.

     S may be a byte string or a Unicode string.  If it is a byte
     string (i.e. `isinstance(s, str)' is true), then CHARSET is the
     encoding of that byte string, and a `UnicodeError' will be raised
     if the string cannot be decoded with that character set.

     If S is a Unicode string, then CHARSET is a hint specifying the
     character set of the characters in the string.  In this case, when
     producing an RFC 2822 -compliant header using RFC 2047

     rules, the Unicode string will be encoded using the following
     charsets in order: `us-ascii', the CHARSET hint, `utf-8'.  The
     first character set to not provoke a `UnicodeError' is used.

     Optional ERRORS is passed through to any `unicode()' or
     `ustr.encode()' call, and defaults to "strict".

`encode([splitchars])'
     Encode a message header into an RFC-compliant format, possibly
     wrapping long lines and encapsulating non-ASCII parts in base64 or
     quoted-printable encodings.  Optional SPLITCHARS is a string
     containing characters to split long ASCII lines on, in rough
     support of RFC 2822 's _highest level syntactic breaks_.  This
     doesn't affect RFC 2047 encoded lines.

The `Header' class also provides a number of methods to support
standard operators and built-in functions.

`__str__()'
     A synonym for `Header.encode()'.  Useful for `str(aHeader)'.

`__unicode__()'
     A helper for the built-in `unicode()' function.  Returns the
     header as a Unicode string.

`__eq__(other)'
     This method allows you to compare two `Header' instances for
     equality.

`__ne__(other)'
     This method allows you to compare two `Header' instances for
     inequality.

The `email.Header' module also provides the following convenient
functions.

`decode_header(header)'
     Decode a message header value without converting the character set.
     The header value is in HEADER.

     This function returns a list of `(decoded_string, charset)' pairs
     containing each of the decoded parts of the header.  CHARSET is
     `None' for non-encoded parts of the header, otherwise a lower case
     string containing the name of the character set specified in the
     encoded string.

     Here's an example:

          >>> from email.Header import decode_header
          >>> decode_header('=?iso-8859-1?q?p=F6stal?=')
          [('p\\xf6stal', 'iso-8859-1')]

`make_header(decoded_seq[, maxlinelen[, header_name[, continuation_ws]]])'
     Create a `Header' instance from a sequence of pairs as returned by
     `decode_header()'.

     `decode_header()' takes a header value string and returns a
     sequence of pairs of the format `(decoded_string, charset)' where
     CHARSET is the name of the character set.

     This function takes one of those sequence of pairs and returns a
     `Header' instance.  Optional MAXLINELEN, HEADER_NAME, and
     CONTINUATION_WS are as in the `Header' constructor.

