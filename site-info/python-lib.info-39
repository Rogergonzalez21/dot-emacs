This is python-lib.info, produced by makeinfo version 4.3 from
python-lib.texi.

October 3, 2003


File: python-lib.info,  Node: Type Mapping,  Next: Accessor Methods,  Prev: Conformance,  Up: Conformance

Type Mapping
............

The primitive IDL types used in the DOM specification are mapped to
Python types according to the following table.

IDL Type                             Python Type
------                               -----
boolean                              `IntegerType' (with a value of `0'
                                     or `1')
int                                  `IntegerType'
long int                             `IntegerType'
unsigned int                         `IntegerType'

Additionally, the `DOMString' defined in the recommendation is mapped
to a Python string or Unicode string.  Applications should be able to
handle Unicode whenever a string is returned from the DOM.

The IDL `null' value is mapped to `None', which may be accepted or
provided by the implementation whenever `null' is allowed by the API.


File: python-lib.info,  Node: Accessor Methods,  Prev: Type Mapping,  Up: Conformance

Accessor Methods
................

The mapping from OMG IDL to Python defines accessor functions for IDL
`attribute' declarations in much the way the Java mapping does.
Mapping the IDL declarations

     readonly attribute string someValue;
              attribute string anotherValue;

yields three accessor functions:  a "get" method for `someValue'
(`_get_someValue()'), and "get" and "set" methods for `anotherValue'
(`_get_anotherValue()' and `_set_anotherValue()').  The mapping, in
particular, does not require that the IDL attributes are accessible as
normal Python attributes:  `OBJECT.someValue' is _not_ required to
work, and may raise an `AttributeError'.

The Python DOM API, however, _does_ require that normal attribute
access work.  This means that the typical surrogates generated by
Python IDL compilers are not likely to work, and wrapper objects may be
needed on the client if the DOM objects are accessed via CORBA.  While
this does require some additional consideration for CORBA DOM clients,
the implementers with experience using DOM over CORBA from Python do
not consider this a problem.  Attributes that are declared `readonly'
may not restrict write access in all DOM implementations.

Additionally, the accessor functions are not required.  If provided,
they should take the form defined by the Python IDL mapping, but these
methods are considered unnecessary since the attributes are accessible
directly from Python.  "Set" accessors should never be provided for
`readonly' attributes.


File: python-lib.info,  Node: xmldomminidom,  Next: xmldompulldom,  Prev: xmldom,  Up: Structured Markup Processing Tools

Lightweight DOM implementation
==============================

Lightweight Document Object Model (DOM) implementation.

_Added in Python version 2.0_

`xml.dom.minidom' is a light-weight implementation of the Document
Object Model interface.  It is intended to be simpler than the full DOM
and also significantly smaller.

DOM applications typically start by parsing some XML into a DOM.  With
`xml.dom.minidom', this is done through the parse functions:

     from xml.dom.minidom import parse, parseString
     
     dom1 = parse('c:\\temp\\mydata.xml') # parse an XML file by name
     
     datasource = open('c:\\temp\\mydata.xml')
     dom2 = parse(datasource)   # parse an open file
     
     dom3 = parseString('<myxml>Some data<empty/> some more data</myxml>')

The `parse()' function can take either a filename or an open file
object.

`parse(filename_or_file{, parser})'
     Return a `Document' from the given input. FILENAME_OR_FILE may be
     either a file name, or a file-like object. PARSER, if given, must
     be a SAX2 parser object. This function will change the document
     handler of the parser and activate namespace support; other parser
     configuration (like setting an entity resolver) must have been
     done in advance.

If you have XML in a string, you can use the `parseString()' function
instead:

`parseString(string[, parser])'
     Return a `Document' that represents the STRING. This method
     creates a `StringIO' object for the string and passes that on to
     `parse'.

Both functions return a `Document' object representing the content of
the document.

What the `parse()' and `parseString()' functions do is connect an XML
parser with a "DOM builder" that can accept parse events from any SAX
parser and convert them into a DOM tree.  The name of the functions are
perhaps misleading, but are easy to grasp when learning the interfaces.
The parsing of the document will be completed before these functions
return; it's simply that these functions do not provide a parser
implementation themselves.

You can also create a `Document' by calling a method on a "DOM
Implementation" object.  You can get this object either by calling the
`getDOMImplementation()' function in the `xml.dom' package or the
`xml.dom.minidom' module.  Using the implementation from the
`xml.dom.minidom' module will always return a `Document' instance from
the minidom implementation, while the version from `xml.dom' may provide
an alternate implementation (this is likely if you have the PyXML
package installed).  Once you have a `Document', you can add child
nodes to it to populate the DOM:

     from xml.dom.minidom import getDOMImplementation
     
     impl = getDOMImplementation()
     
     newdoc = impl.createDocument(None, "some_tag", None)
     top_element = newdoc.documentElement
     text = newdoc.createTextNode('Some textual content.')
     top_element.appendChild(text)

Once you have a DOM document object, you can access the parts of your
XML document through its properties and methods.  These properties are
defined in the DOM specification.  The main property of the document
object is the `documentElement' property.  It gives you the main
element in the XML document: the one that holds all others.  Here is an
example program:

     dom3 = parseString("<myxml>Some data</myxml>")
     assert dom3.documentElement.tagName == "myxml"

When you are finished with a DOM, you should clean it up.  This is
necessary because some versions of Python do not support garbage
collection of objects that refer to each other in a cycle.  Until this
restriction is removed from all versions of Python, it is safest to
write your code as if cycles would not be cleaned up.

The way to clean up a DOM is to call its `unlink()' method:

     dom1.unlink()
     dom2.unlink()
     dom3.unlink()

`unlink()' is a `xml.dom.minidom'-specific extension to the DOM API.
After calling `unlink()' on a node, the node and its descendents are
essentially useless.

See also:
     `Document Object Model (DOM) Level 1 Specification' {The W3C
     recommendation for the DOM supported by `xml.dom.minidom'.}

* Menu:

* DOM Objects::
* DOM Example::
* minidom and the DOM standard::


File: python-lib.info,  Node: DOM Objects,  Next: DOM Example,  Prev: xmldomminidom,  Up: xmldomminidom

DOM Objects
-----------

The definition of the DOM API for Python is given as part of the
`xml.dom' module documentation.  This section lists the differences
between the API and `xml.dom.minidom'.

`unlink()'
     Break internal references within the DOM so that it will be garbage
     collected on versions of Python without cyclic GC.  Even when
     cyclic GC is available, using this can make large amounts of
     memory available sooner, so calling this on DOM objects as soon as
     they are no longer needed is good practice.  This only needs to be
     called on the `Document' object, but may be called on child nodes
     to discard children of that node.

`writexml(writer)'
     Write XML to the writer object.  The writer should have a
     `write()' method which matches that of the file object interface.

     _Added in Python version 2.1_

     _Added in Python version 2.3_

`toxml([encoding])'
     Return the XML that the DOM represents as a string.

     _Added in Python version 2.3_

     With no argument, the XML header does not specify an encoding, and
     the result is Unicode string if the default encoding cannot
     represent all characters in the document. Encoding this string in
     an encoding other than UTF-8 is likely incorrect, since UTF-8 is
     the default encoding of XML.

     With an explicit ENCODING argument, the result is a byte string in
     the specified encoding. It is recommended that this argument is
     always specified. To avoid UnicodeError exceptions in case of
     unrepresentable text data, the encoding argument should be
     specified as "utf-8".

`toprettyxml([indent[, newl]])'
     Return a pretty-printed version of the document. INDENT specifies
     the indentation string and defaults to a tabulator; NEWL specifies
     the string emitted at the end of each line and defaults to \n.

     _Added in Python version 2.1_

     _Added in Python version 2.3_

The following standard DOM methods have special considerations with
`xml.dom.minidom':

`cloneNode(deep)'
     Although this method was present in the version of
     `xml.dom.minidom' packaged with Python 2.0, it was seriously
     broken.  This has been corrected for subsequent releases.


File: python-lib.info,  Node: DOM Example,  Next: minidom and the DOM standard,  Prev: DOM Objects,  Up: xmldomminidom

DOM Example
-----------

This example program is a fairly realistic example of a simple program.
In this particular case, we do not take much advantage of the
flexibility of the DOM.

`minidom-example.py'


File: python-lib.info,  Node: minidom and the DOM standard,  Prev: DOM Example,  Up: xmldomminidom

minidom and the DOM standard
----------------------------

The `xml.dom.minidom' module is essentially a DOM 1.0-compatible DOM
with some DOM 2 features (primarily namespace features).

Usage of the DOM interface in Python is straight-forward.  The
following mapping rules apply:

   * Interfaces are accessed through instance objects. Applications
     should not instantiate the classes themselves; they should use the
     creator functions available on the `Document' object.  Derived
     interfaces support all operations (and attributes) from the base
     interfaces, plus any new operations.

   * Operations are used as methods. Since the DOM uses only `in'
     parameters, the arguments are passed in normal order (from left to
     right).   There are no optional arguments. `void' operations
     return `None'.

   * IDL attributes map to instance attributes. For compatibility with
     the OMG IDL language mapping for Python, an attribute `foo' can
     also be accessed through accessor methods `_get_foo()' and
     `_set_foo()'.  `readonly' attributes must not be changed; this is
     not enforced at runtime.

   * The types `short int', `unsigned int', `unsigned long long', and
     `boolean' all map to Python integer objects.

   * The type `DOMString' maps to Python strings.  `xml.dom.minidom'
     supports either byte or Unicode strings, but will normally produce
     Unicode strings.  Values of type `DOMString' may also be `None'
     where allowed to have the IDL `null' value by the DOM
     specification from the W3C.

   * `const' declarations map to variables in their respective scope
     (e.g. `xml.dom.minidom.Node.PROCESSING_INSTRUCTION_NODE'); they
     must not be changed.

   * `DOMException' is currently not supported in `xml.dom.minidom'.
     Instead, `xml.dom.minidom' uses standard Python exceptions such as
     `TypeError' and `AttributeError'.

   * `NodeList' objects are implemented using Python's built-in list
     type.  Starting with Python 2.2, these objects provide the
     interface defined in the DOM specification, but with earlier
     versions of Python they do not support the official API.  They
     are, however, much more "Pythonic" than the interface defined in
     the W3C recommendations.

The following interfaces have no implementation in `xml.dom.minidom':

   * `DOMTimeStamp'

   * `DocumentType' (added in Python 2.1)

   * `DOMImplementation' (added in Python 2.1)

   * `CharacterData'

   * `CDATASection'

   * `Notation'

   * `Entity'

   * `EntityReference'

   * `DocumentFragment'

Most of these reflect information in the XML document that is not of
general utility to most DOM users.


File: python-lib.info,  Node: xmldompulldom,  Next: xmlsax,  Prev: xmldomminidom,  Up: Structured Markup Processing Tools

Support for building partial DOM trees
======================================

Support for building partial DOM trees from SAX events.

_Added in Python version 2.0_

`xml.dom.pulldom' allows building only selected portions of a Document
Object Model representation of a document from SAX events.

`PullDOM([documentFactory])'
     `xml.sax.handler.ContentHandler' implementation that ...

`DOMEventStream(stream, parser, bufsize)'
     ...

`SAX2DOM([documentFactory])'
     `xml.sax.handler.ContentHandler' implementation that ...

`parse(stream_or_string[, parser[, bufsize]])'
     ...

`parseString(string[, parser])'
     ...

`default_bufsize'
     Default value for the BUSIZE parameter to `parse()'.  _Changed in
     Python version 2.1_

* Menu:

* DOMEventStream Objects::


File: python-lib.info,  Node: DOMEventStream Objects,  Prev: xmldompulldom,  Up: xmldompulldom

DOMEventStream Objects
----------------------

`getEvent()'
     ...

`expandNode(node)'
     ...

`reset()'
     ...


File: python-lib.info,  Node: xmlsax,  Next: xmlsaxhandler,  Prev: xmldompulldom,  Up: Structured Markup Processing Tools

Support for SAX2 parsers
========================

Package containing SAX2 base classes and convenience functions.

_Added in Python version 2.0_

The `xml.sax' package provides a number of modules which implement the
Simple API for XML (SAX) interface for Python.  The package itself
provides the SAX exceptions and the convenience functions which will be
most used by users of the SAX API.

The convenience functions are:

`make_parser([parser_list])'
     Create and return a SAX `XMLReader' object.  The first parser
     found will be used.  If PARSER_LIST is provided, it must be a
     sequence of strings which name modules that have a function named
     `create_parser()'.  Modules listed in PARSER_LIST will be used
     before modules in the default list of parsers.

`parse(filename_or_stream, handler[, error_handler])'
     Create a SAX parser and use it to parse a document.  The document,
     passed in as FILENAME_OR_STREAM, can be a filename or a file
     object.  The HANDLER parameter needs to be a SAX `ContentHandler'
     instance.  If ERROR_HANDLER is given, it must be a SAX
     `ErrorHandler' instance; if omitted, `SAXParseException' will be
     raised on all errors.  There is no return value; all work must be
     done by the HANDLER passed in.

`parseString(string, handler[, error_handler])'
     Similar to `parse()', but parses from a buffer STRING received as
     a parameter.

A typical SAX application uses three kinds of objects: readers,
handlers and input sources.  "Reader" in this context is another term
for parser, i.e. some piece of code that reads the bytes or characters
from the input source, and produces a sequence of events.  The events
then get distributed to the handler objects, i.e. the reader invokes a
method on the handler.  A SAX application must therefore obtain a
reader object, create or open the input sources, create the handlers,
and connect these objects all together.  As the final step of
preparation, the reader is called to parse the input.  During parsing,
methods on the handler objects are called based on structural and
syntactic events from the input data.

For these objects, only the interfaces are relevant; they are normally
not instantiated by the application itself.  Since Python does not have
an explicit notion of interface, they are formally introduced as
classes, but applications may use implementations which do not inherit
from the provided classes.  The `InputSource', `Locator', `Attributes',
`AttributesNS', and `XMLReader' interfaces are defined in the module
`xml.sax.xmlreader'.  The handler interfaces are defined in
`xml.sax.handler'.  For convenience, `InputSource' (which is often
instantiated directly) and the handler classes are also available from
`xml.sax'.  These interfaces are described below.

In addition to these classes, `xml.sax' provides the following
exception classes.

`SAXException(msg[, exception])'
     Encapsulate an XML error or warning.  This class can contain basic
     error or warning information from either the XML parser or the
     application: it can be subclassed to provide additional
     functionality or to add localization.  Note that although the
     handlers defined in the `ErrorHandler' interface receive instances
     of this exception, it is not required to actually raise the
     exception -- it is also useful as a container for information.

     When instantiated, MSG should be a human-readable description of
     the error.  The optional EXCEPTION parameter, if given, should be
     `None' or an exception that was caught by the parsing code and is
     being passed along as information.

     This is the base class for the other SAX exception classes.

`SAXParseException(msg, exception, locator)'
     Subclass of `SAXException' raised on parse errors.  Instances of
     this class are passed to the methods of the SAX `ErrorHandler'
     interface to provide information about the parse error.  This
     class supports the SAX `Locator' interface as well as the
     `SAXException' interface.

`SAXNotRecognizedException(msg[, exception])'
     Subclass of `SAXException' raised when a SAX `XMLReader' is
     confronted with an unrecognized feature or property.  SAX
     applications and extensions may use this class for similar
     purposes.

`SAXNotSupportedException(msg[, exception])'
     Subclass of `SAXException' raised when a SAX `XMLReader' is asked
     to enable a feature that is not supported, or to set a property to
     a value that the implementation does not support.  SAX
     applications and extensions may use this class for similar
     purposes.

See also:
     `SAX: The Simple API for XML'{This site is the focal point for the
     definition of the SAX API.  It provides a Java implementation and
     online documentation.  Links to implementations and historical
     information are also available.}

     *Note xmlsaxhandler:: Definitions of the interfaces for
     application-provided objects.

     *Note xmlsaxsaxutils:: Convenience functions for use in SAX
     applications.

     *Note xmlsaxxmlreader:: Definitions of the interfaces for
     parser-provided objects.

* Menu:

* SAXException Objects::


File: python-lib.info,  Node: SAXException Objects,  Prev: xmlsax,  Up: xmlsax

SAXException Objects
--------------------

The `SAXException' exception class supports the following methods:

`getMessage()'
     Return a human-readable message describing the error condition.

`getException()'
     Return an encapsulated exception object, or `None'.


File: python-lib.info,  Node: xmlsaxhandler,  Next: xmlsaxsaxutils,  Prev: xmlsax,  Up: Structured Markup Processing Tools

Base classes for SAX handlers
=============================

Base classes for SAX event handlers.

_Added in Python version 2.0_

The SAX API defines four kinds of handlers: content handlers, DTD
handlers, error handlers, and entity resolvers. Applications normally
only need to implement those interfaces whose events they are
interested in; they can implement the interfaces in a single object or
in multiple objects. Handler implementations should inherit from the
base classes provided in the module `xml.sax', so that all methods get
default implementations.

`ContentHandler'
     This is the main callback interface in SAX, and the one most
     important to applications. The order of events in this interface
     mirrors the order of the information in the document.

`DTDHandler'
     Handle DTD events.

     This interface specifies only those DTD events required for basic
     parsing (unparsed entities and attributes).

`EntityResolver'
     Basic interface for resolving entities. If you create an object
     implementing this interface, then register the object with your
     Parser, the parser will call the method in your object to resolve
     all external entities.

`ErrorHandler'
     Interface used by the parser to present error and warning messages
     to the application.  The methods of this object control whether
     errors are immediately converted to exceptions or are handled in
     some other way.

In addition to these classes, `xml.sax.handler' provides symbolic
constants for the feature and property names.

`feature_namespaces'
     Value: `"http://xml.org/sax/features/namespaces"'\ true: Perform
     Namespace processing.\ false: Optionally do not perform Namespace
     processing (implies namespace-prefixes; default).\ access:
     (parsing) read-only; (not parsing) read/write

`feature_namespace_prefixes'
     Value: `"http://xml.org/sax/features/namespace-prefixes"'\ true:
     Report the original prefixed names and attributes used for
     Namespace declarations.\ false: Do not report attributes used for
     Namespace declarations, and optionally do not report original
     prefixed names (default).\ access: (parsing) read-only; (not
     parsing) read/write

`feature_string_interning'
     Value: `"http://xml.org/sax/features/string-interning"' true: All
     element names, prefixes, attribute names, Namespace URIs, and
     local names are interned using the built-in intern function.\
     false: Names are not necessarily interned, although they may be
     (default).\ access: (parsing) read-only; (not parsing) read/write

`feature_validation'
     Value: `"http://xml.org/sax/features/validation"'\ true: Report
     all validation errors (implies external-general-entities and
     external-parameter-entities).\ false: Do not report validation
     errors.\ access: (parsing) read-only; (not parsing) read/write

`feature_external_ges'
     Value: `"http://xml.org/sax/features/external-general-entities"'\
     true: Include all external general (text) entities.\ false: Do not
     include external general entities.\ access: (parsing) read-only;
     (not parsing) read/write

`feature_external_pes'
     Value: `"http://xml.org/sax/features/external-parameter-entities"'\
     true: Include all external parameter entities, including the
     external DTD subset.\ false: Do not include any external parameter
     entities, even the external DTD subset.\ access: (parsing)
     read-only; (not parsing) read/write

`all_features'
     List of all features.

`property_lexical_handler'
     Value: `"http://xml.org/sax/properties/lexical-handler"'\ data
     type: xml.sax.sax2lib.LexicalHandler (not supported in Python 2)\
     description: An optional extension handler for lexical events like
     comments.\ access: read/write

`property_declaration_handler'
     Value: `"http://xml.org/sax/properties/declaration-handler"'\ data
     type: xml.sax.sax2lib.DeclHandler (not supported in Python 2)\
     description: An optional extension handler for DTD-related events
     other than notations and unparsed entities.\ access: read/write

`property_dom_node'
     Value: `"http://xml.org/sax/properties/dom-node"'\ data type:
     org.w3c.dom.Node (not supported in Python 2) \ description: When
     parsing, the current DOM node being visited if this is a DOM
     iterator; when not parsing, the root DOM node for iteration.\
     access: (parsing) read-only; (not parsing) read/write

`property_xml_string'
     Value: `"http://xml.org/sax/properties/xml-string"'\ data type:
     String\ description: The literal string of characters that was the
     source for the current event.\ access: read-only

`all_properties'
     List of all known property names.

* Menu:

* ContentHandler Objects::
* DTDHandler Objects::
* EntityResolver Objects::
* ErrorHandler Objects::


File: python-lib.info,  Node: ContentHandler Objects,  Next: DTDHandler Objects,  Prev: xmlsaxhandler,  Up: xmlsaxhandler

ContentHandler Objects
----------------------

Users are expected to subclass `ContentHandler' to support their
application.  The following methods are called by the parser on the
appropriate events in the input document:

`setDocumentLocator(locator)'
     Called by the parser to give the application a locator for locating
     the origin of document events.

     SAX parsers are strongly encouraged (though not absolutely
     required) to supply a locator: if it does so, it must supply the
     locator to the application by invoking this method before invoking
     any of the other methods in the DocumentHandler interface.

     The locator allows the application to determine the end position of
     any document-related event, even if the parser is not reporting an
     error. Typically, the application will use this information for
     reporting its own errors (such as character content that does not
     match an application's business rules). The information returned by
     the locator is probably not sufficient for use with a search
     engine.

     Note that the locator will return correct information only during
     the invocation of the events in this interface. The application
     should not attempt to use it at any other time.

`startDocument()'
     Receive notification of the beginning of a document.

     The SAX parser will invoke this method only once, before any other
     methods in this interface or in DTDHandler (except for
     `setDocumentLocator()').

`endDocument()'
     Receive notification of the end of a document.

     The SAX parser will invoke this method only once, and it will be
     the last method invoked during the parse. The parser shall not
     invoke this method until it has either abandoned parsing (because
     of an unrecoverable error) or reached the end of input.

`startPrefixMapping(prefix, uri)'
     Begin the scope of a prefix-URI Namespace mapping.

     The information from this event is not necessary for normal
     Namespace processing: the SAX XML reader will automatically replace
     prefixes for element and attribute names when the
     `feature_namespaces' feature is enabled (the default).

     There are cases, however, when applications need to use prefixes in
     character data or in attribute values, where they cannot safely be
     expanded automatically; the `startPrefixMapping()' and
     `endPrefixMapping()' events supply the information to the
     application to expand prefixes in those contexts itself, if
     necessary.

     Note that `startPrefixMapping()' and `endPrefixMapping()' events
     are not guaranteed to be properly nested relative to each-other:
     all `startPrefixMapping()' events will occur before the
     corresponding `startElement()' event, and all `endPrefixMapping()'
     events will occur after the corresponding `endElement()' event,
     but their order is not guaranteed.

`endPrefixMapping(prefix)'
     End the scope of a prefix-URI mapping.

     See `startPrefixMapping()' for details. This event will always
     occur after the corresponding `endElement()' event, but the order
     of `endPrefixMapping()' events is not otherwise guaranteed.

`startElement(name, attrs)'
     Signals the start of an element in non-namespace mode.

     The NAME parameter contains the raw XML 1.0 name of the element
     type as a string and the ATTRS parameter holds an object of the
     `Attributes' interface containing the attributes of the element.
     The object passed as ATTRS may be re-used by the parser; holding
     on to a reference to it is not a reliable way to keep a copy of
     the attributes.  To keep a copy of the attributes, use the
     `copy()' method of the ATTRS object.

`endElement(name)'
     Signals the end of an element in non-namespace mode.

     The NAME parameter contains the name of the element type, just as
     with the `startElement()' event.

`startElementNS(name, qname, attrs)'
     Signals the start of an element in namespace mode.

     The NAME parameter contains the name of the element type as a
     `(URI, LOCALNAME)' tuple, the QNAME parameter contains the raw XML
     1.0 name used in the source document, and the ATTRS parameter
     holds an instance of the `AttributesNS' interface containing the
     attributes of the element.  If no namespace is associated with the
     element, the URI component of NAME will be `None'.  The object
     passed as ATTRS may be re-used by the parser; holding on to a
     reference to it is not a reliable way to keep a copy of the
     attributes.  To keep a copy of the attributes, use the `copy()'
     method of the ATTRS object.

     Parsers may set the QNAME parameter to `None', unless the
     `feature_namespace_prefixes' feature is activated.

`endElementNS(name, qname)'
     Signals the end of an element in namespace mode.

     The NAME parameter contains the name of the element type, just as
     with the `startElementNS()' method, likewise the QNAME parameter.

`characters(content)'
     Receive notification of character data.

     The Parser will call this method to report each chunk of character
     data. SAX parsers may return all contiguous character data in a
     single chunk, or they may split it into several chunks; however,
     all of the characters in any single event must come from the same
     external entity so that the Locator provides useful information.

     CONTENT may be a Unicode string or a byte string; the `expat'
     reader module produces always Unicode strings.

     _Note:_ The earlier SAX 1 interface provided by the Python XML
     Special Interest Group used a more Java-like interface for this
     method.  Since most parsers used from Python did not take
     advantage of the older interface, the simpler signature was chosen
     to replace it.  To convert old code to the new interface, use
     CONTENT instead of slicing content with the old OFFSET and LENGTH
     parameters.

`ignorableWhitespace()'
     Receive notification of ignorable whitespace in element content.

     Validating Parsers must use this method to report each chunk of
     ignorable whitespace (see the W3C XML 1.0 recommendation, section
     2.10): non-validating parsers may also use this method if they are
     capable of parsing and using content models.

     SAX parsers may return all contiguous whitespace in a single
     chunk, or they may split it into several chunks; however, all of
     the characters in any single event must come from the same
     external entity, so that the Locator provides useful information.

`processingInstruction(target, data)'
     Receive notification of a processing instruction.

     The Parser will invoke this method once for each processing
     instruction found: note that processing instructions may occur
     before or after the main document element.

     A SAX parser should never report an XML declaration (XML 1.0,
     section 2.8) or a text declaration (XML 1.0, section 4.3.1) using
     this method.

`skippedEntity(name)'
     Receive notification of a skipped entity.

     The Parser will invoke this method once for each entity skipped.
     Non-validating processors may skip entities if they have not seen
     the declarations (because, for example, the entity was declared in
     an external DTD subset). All processors may skip external
     entities, depending on the values of the `feature_external_ges'
     and the `feature_external_pes' properties.


File: python-lib.info,  Node: DTDHandler Objects,  Next: EntityResolver Objects,  Prev: ContentHandler Objects,  Up: xmlsaxhandler

DTDHandler Objects
------------------

`DTDHandler' instances provide the following methods:

`notationDecl(name, publicId, systemId)'
     Handle a notation declaration event.

`unparsedEntityDecl(name, publicId, systemId, ndata)'
     Handle an unparsed entity declaration event.


File: python-lib.info,  Node: EntityResolver Objects,  Next: ErrorHandler Objects,  Prev: DTDHandler Objects,  Up: xmlsaxhandler

EntityResolver Objects
----------------------

`resolveEntity(publicId, systemId)'
     Resolve the system identifier of an entity and return either the
     system identifier to read from as a string, or an InputSource to
     read from. The default implementation returns SYSTEMID.


File: python-lib.info,  Node: ErrorHandler Objects,  Prev: EntityResolver Objects,  Up: xmlsaxhandler

ErrorHandler Objects
--------------------

Objects with this interface are used to receive error and warning
information from the `XMLReader'.  If you create an object that
implements this interface, then register the object with your
`XMLReader', the parser will call the methods in your object to report
all warnings and errors. There are three levels of errors available:
warnings, (possibly) recoverable errors, and unrecoverable errors.  All
methods take a `SAXParseException' as the only parameter.  Errors and
warnings may be converted to an exception by raising the passed-in
exception object.

`error(exception)'
     Called when the parser encounters a recoverable error.  If this
     method does not raise an exception, parsing may continue, but
     further document information should not be expected by the
     application.  Allowing the parser to continue may allow additional
     errors to be discovered in the input document.

`fatalError(exception)'
     Called when the parser encounters an error it cannot recover from;
     parsing is expected to terminate when this method returns.

`warning(exception)'
     Called when the parser presents minor warning information to the
     application.  Parsing is expected to continue when this method
     returns, and document information will continue to be passed to
     the application.  Raising an exception in this method will cause
     parsing to end.


File: python-lib.info,  Node: xmlsaxsaxutils,  Next: xmlsaxxmlreader,  Prev: xmlsaxhandler,  Up: Structured Markup Processing Tools

SAX Utilities
=============

Convenience functions and classes for use with SAX.

_Added in Python version 2.0_

The module `xml.sax.saxutils' contains a number of classes and
functions that are commonly useful when creating SAX applications,
either in direct use, or as base classes.

`escape(data[, entities])'
     Escape `&', `<', and `>' in a string of data.

     You can escape other strings of data by passing a dictionary as the
     optional ENTITIES parameter.  The keys and values must all be
     strings; each key will be replaced with its corresponding value.

`unescape(data[, entities])'
     Unescape `&amp;', `&lt;', and `&gt;' in a string of data.

     You can unescape other strings of data by passing a dictionary as
     the optional ENTITIES parameter.  The keys and values must all be
     strings; each key will be replaced with its corresponding value.

     _Added in Python version 2.3_

`quoteattr(data[, entities])'
     Similar to `escape()', but also prepares DATA to be used as an
     attribute value.  The return value is a quoted version of DATA
     with any additional required replacements.  `quoteattr()' will
     select a quote character based on the content of DATA, attempting
     to avoid encoding any quote characters in the string.  If both
     single- and double-quote characters are already in DATA, the
     double-quote characters will be encoded and DATA will be wrapped
     in doule-quotes.  The resulting string can be used directly as an
     attribute value:

          >>> print "<element attr=%s>" % quoteattr("ab ' cd \" ef")
          <element attr="ab ' cd &quot; ef">

     This function is useful when generating attribute values for HTML
     or any SGML using the reference concrete syntax.  _Added in Python
     version 2.2_

`XMLGenerator([out[, encoding]])'
     This class implements the `ContentHandler' interface by writing
     SAX events back into an XML document. In other words, using an
     `XMLGenerator' as the content handler will reproduce the original
     document being parsed. OUT should be a file-like object which will
     default to SYS.STDOUT. ENCODING is the encoding of the output
     stream which defaults to `'iso-8859-1''.

`XMLFilterBase(base)'
     This class is designed to sit between an `XMLReader' and the
     client application's event handlers.  By default, it does nothing
     but pass requests up to the reader and events on to the handlers
     unmodified, but subclasses can override specific methods to modify
     the event stream or the configuration requests as they pass
     through.

`prepare_input_source(source[, base])'
     This function takes an input source and an optional base URL and
     returns a fully resolved `InputSource' object ready for reading.
     The input source can be given as a string, a file-like object, or
     an `InputSource' object; parsers will use this function to
     implement the polymorphic SOURCE argument to their `parse()'
     method.


File: python-lib.info,  Node: xmlsaxxmlreader,  Next: xmllib,  Prev: xmlsaxsaxutils,  Up: Structured Markup Processing Tools

Interface for XML parsers
=========================

Interface which SAX-compliant XML parsers must implement.

_Added in Python version 2.0_

SAX parsers implement the `XMLReader' interface. They are implemented
in a Python module, which must provide a function `create_parser()'.
This function is invoked by `xml.sax.make_parser()' with no arguments
to create a new parser object.

`XMLReader()'
     Base class which can be inherited by SAX parsers.

`IncrementalParser()'
     In some cases, it is desirable not to parse an input source at
     once, but to feed chunks of the document as they get available.
     Note that the reader will normally not read the entire file, but
     read it in chunks as well; still `parse()' won't return until the
     entire document is processed. So these interfaces should be used
     if the blocking behaviour of `parse()' is not desirable.

     When the parser is instantiated it is ready to begin accepting data
     from the feed method immediately. After parsing has been finished
     with a call to close the reset method must be called to make the
     parser ready to accept new data, either from feed or using the
     parse method.

     Note that these methods must _not_ be called during parsing, that
     is, after parse has been called and before it returns.

     By default, the class also implements the parse method of the
     XMLReader interface using the feed, close and reset methods of the
     IncrementalParser interface as a convenience to SAX 2.0 driver
     writers.

`Locator()'
     Interface for associating a SAX event with a document location. A
     locator object will return valid results only during calls to
     DocumentHandler methods; at any other time, the results are
     unpredictable. If information is not available, methods may return
     `None'.

`InputSource([systemId])'
     Encapsulation of the information needed by the `XMLReader' to read
     entities.

     This class may include information about the public identifier,
     system identifier, byte stream (possibly with character encoding
     information) and/or the character stream of an entity.

     Applications will create objects of this class for use in the
     `XMLReader.parse()' method and for returning from
     EntityResolver.resolveEntity.

     An `InputSource' belongs to the application, the `XMLReader' is
     not allowed to modify `InputSource' objects passed to it from the
     application, although it may make copies and modify those.

`AttributesImpl(attrs)'
     This is an implementation of the `Attributes' interface (see
     section~*Note Attributes Interface::).  This is a dictionary-like
     object which represents the element attributes in a
     `startElement()' call. In addition to the most useful dictionary
     operations, it supports a number of other methods as described by
     the interface. Objects of this class should be instantiated by
     readers; ATTRS must be a dictionary-like object containing a
     mapping from attribute names to attribute values.

`AttributesNSImpl(attrs, qnames)'
     Namespace-aware variant of `AttributesImpl', which will be passed
     to `startElementNS()'. It is derived from `AttributesImpl', but
     understands attribute names as two-tuples of NAMESPACEURI and
     LOCALNAME. In addition, it provides a number of methods expecting
     qualified names as they appear in the original document.  This
     class implements the `AttributesNS' interface (see section~*Note
     xmllib::).

* Menu:

* XMLReader Objects::
* IncrementalParser Objects::
* Locator Objects::
* InputSource Objects::
* Attributes Interface::
* AttributesNS Interface::


File: python-lib.info,  Node: XMLReader Objects,  Next: IncrementalParser Objects,  Prev: xmlsaxxmlreader,  Up: xmlsaxxmlreader

XMLReader Objects
-----------------

The `XMLReader' interface supports the following methods:

`parse(source)'
     Process an input source, producing SAX events. The SOURCE object
     can be a system identifier (a string identifying the input source
     - typically a file name or an URL), a file-like object, or an
     `InputSource' object. When `parse()' returns, the input is
     completely processed, and the parser object can be discarded or
     reset. As a limitation, the current implementation only accepts
     byte streams; processing of character streams is for further study.

`getContentHandler()'
     Return the current `ContentHandler'.

`setContentHandler(handler)'
     Set the current `ContentHandler'.  If no `ContentHandler' is set,
     content events will be discarded.

`getDTDHandler()'
     Return the current `DTDHandler'.

`setDTDHandler(handler)'
     Set the current `DTDHandler'.  If no `DTDHandler' is set, DTD
     events will be discarded.

`getEntityResolver()'
     Return the current `EntityResolver'.

`setEntityResolver(handler)'
     Set the current `EntityResolver'.  If no `EntityResolver' is set,
     attempts to resolve an external entity will result in opening the
     system identifier for the entity, and fail if it is not available.

`getErrorHandler()'
     Return the current `ErrorHandler'.

`setErrorHandler(handler)'
     Set the current error handler.  If no `ErrorHandler' is set,
     errors will be raised as exceptions, and warnings will be printed.

`setLocale(locale)'
     Allow an application to set the locale for errors and warnings.

     SAX parsers are not required to provide localization for errors and
     warnings; if they cannot support the requested locale, however,
     they must throw a SAX exception.  Applications may request a
     locale change in the middle of a parse.

`getFeature(featurename)'
     Return the current setting for feature FEATURENAME.  If the
     feature is not recognized, `SAXNotRecognizedException' is raised.
     The well-known featurenames are listed in the module
     `xml.sax.handler'.

`setFeature(featurename, value)'
     Set the FEATURENAME to VALUE. If the feature is not recognized,
     `SAXNotRecognizedException' is raised. If the feature or its
     setting is not supported by the parser, SAXNOTSUPPORTEDEXCEPTION
     is raised.

`getProperty(propertyname)'
     Return the current setting for property PROPERTYNAME. If the
     property is not recognized, a `SAXNotRecognizedException' is
     raised. The well-known propertynames are listed in the module
     `xml.sax.handler'.

`setProperty(propertyname, value)'
     Set the PROPERTYNAME to VALUE. If the property is not recognized,
     `SAXNotRecognizedException' is raised. If the property or its
     setting is not supported by the parser, SAXNOTSUPPORTEDEXCEPTION
     is raised.


File: python-lib.info,  Node: IncrementalParser Objects,  Next: Locator Objects,  Prev: XMLReader Objects,  Up: xmlsaxxmlreader

IncrementalParser Objects
-------------------------

Instances of `IncrementalParser' offer the following additional methods:

`feed(data)'
     Process a chunk of DATA.

`close()'
     Assume the end of the document. That will check well-formedness
     conditions that can be checked only at the end, invoke handlers,
     and may clean up resources allocated during parsing.

`reset()'
     This method is called after close has been called to reset the
     parser so that it is ready to parse new documents. The results of
     calling parse or feed after close without calling reset are
     undefined.


File: python-lib.info,  Node: Locator Objects,  Next: InputSource Objects,  Prev: IncrementalParser Objects,  Up: xmlsaxxmlreader

Locator Objects
---------------

Instances of `Locator' provide these methods:

`getColumnNumber()'
     Return the column number where the current event ends.

`getLineNumber()'
     Return the line number where the current event ends.

`getPublicId()'
     Return the public identifier for the current event.

`getSystemId()'
     Return the system identifier for the current event.


File: python-lib.info,  Node: InputSource Objects,  Next: Attributes Interface,  Prev: Locator Objects,  Up: xmlsaxxmlreader

InputSource Objects
-------------------

`setPublicId(id)'
     Sets the public identifier of this `InputSource'.

`getPublicId()'
     Returns the public identifier of this `InputSource'.

`setSystemId(id)'
     Sets the system identifier of this `InputSource'.

`getSystemId()'
     Returns the system identifier of this `InputSource'.

`setEncoding(encoding)'
     Sets the character encoding of this `InputSource'.

     The encoding must be a string acceptable for an XML encoding
     declaration (see section 4.3.3 of the XML recommendation).

     The encoding attribute of the `InputSource' is ignored if the
     `InputSource' also contains a character stream.

`getEncoding()'
     Get the character encoding of this InputSource.

`setByteStream(bytefile)'
     Set the byte stream (a Python file-like object which does not
     perform byte-to-character conversion) for this input source.

     The SAX parser will ignore this if there is also a character stream
     specified, but it will use a byte stream in preference to opening a
     URI connection itself.

     If the application knows the character encoding of the byte stream,
     it should set it with the setEncoding method.

`getByteStream()'
     Get the byte stream for this input source.

     The getEncoding method will return the character encoding for this
     byte stream, or None if unknown.

`setCharacterStream(charfile)'
     Set the character stream for this input source. (The stream must be
     a Python 1.6 Unicode-wrapped file-like that performs conversion to
     Unicode strings.)

     If there is a character stream specified, the SAX parser will
     ignore any byte stream and will not attempt to open a URI
     connection to the system identifier.

`getCharacterStream()'
     Get the character stream for this input source.


File: python-lib.info,  Node: Attributes Interface,  Next: AttributesNS Interface,  Prev: InputSource Objects,  Up: xmlsaxxmlreader

The `Attributes' Interface
--------------------------

`Attributes' objects implement a portion of the mapping protocol,
including the methods `copy()', `get()', `has_key()', `items()',
`keys()', and `values()'.  The following methods are also provided:

`getLength()'
     Return the number of attributes.

`getNames()'
     Return the names of the attributes.

`getType(name)'
     Returns the type of the attribute NAME, which is normally
     `'CDATA''.

`getValue(name)'
     Return the value of attribute NAME.


File: python-lib.info,  Node: AttributesNS Interface,  Prev: Attributes Interface,  Up: xmlsaxxmlreader

The `AttributesNS' Interface
----------------------------

This interface is a subtype of the `Attributes' interface (see
section~*Note Attributes Interface::).  All methods supported by that
interface are also available on `AttributesNS' objects.

The following methods are also available:

`getValueByQName(name)'
     Return the value for a qualified name.

`getNameByQName(name)'
     Return the `(NAMESPACE, LOCALNAME)' pair for a qualified NAME.

`getQNameByName(name)'
     Return the qualified name for a `(NAMESPACE, LOCALNAME)' pair.

`getQNames()'
     Return the qualified names of all attributes.

