This is python-dist.info, produced by makeinfo version 4.3 from
python-dist.texi.


File: python-dist.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

Distributing Python Modules
***************************

     This document describes the Python Distribution Utilities
     ("Distutils") from the module developer's point of view, describing
     how to use the Distutils to make Python modules and extensions
     easily available to a wider audience with very little overhead for
     build/release/install mechanics.

* Menu:

* Introduction::
* Concepts & Terminology::
* Writing the Setup Script::
* Writing the Setup Configuration File::
* Creating a Source Distribution::
* Creating Built Distributions::
* Registering with the Package Index::
* Examples::
* Reference::
* distutilssysconfig::
* Function-Method-Variable Index::
* Miscellaneous Index::


File: python-dist.info,  Node: Introduction,  Next: Concepts & Terminology,  Prev: Top,  Up: Top

Introduction
************

This document covers using the Distutils to distribute your Python
modules, concentrating on the role of developer/distributor: if you're
looking for information on installing Python modules, you should refer
to the  manual.


File: python-dist.info,  Node: Concepts & Terminology,  Next: Writing the Setup Script,  Prev: Introduction,  Up: Top

Concepts & Terminology
**********************

Using the Distutils is quite simple, both for module developers and for
users/administrators installing third-party modules.  As a developer,
your responsibilities (apart from writing solid, well-documented and
well-tested code, of course!) are:
   * write a setup script (`setup.py' by convention)

   * (optional) write a setup configuration file

   * create a source distribution

   * (optional) create one or more built (binary) distributions

Each of these tasks is covered in this document.

Not all module developers have access to a multitude of platforms, so
it's not always feasible to expect them to create a multitude of built
distributions.  It is hoped that a class of intermediaries, called
_packagers_, will arise to address this need.  Packagers will take
source distributions released by module developers, build them on one or
more platforms, and release the resulting built distributions.  Thus,
users on the most popular platforms will be able to install most popular
Python module distributions in the most natural way for their platform,
without having to run a single setup script or compile a line of code.

* Menu:

* A Simple Example::
* General Python terminology::
* Distutils-specific terminology::


File: python-dist.info,  Node: A Simple Example,  Next: General Python terminology,  Prev: Concepts & Terminology,  Up: Concepts & Terminology

A Simple Example
================

The setup script is usually quite simple, although since it's written
in Python, there are no arbitrary limits to what you can do with it,
though you should be careful about putting arbitrarily expensive
operations in your setup script. Unlike, say, Autoconf-style configure
scripts, the setup script may be run multiple times in the course of
building and installing your module distribution.

If all you want to do is distribute a module called `foo', contained in
a file `foo.py', then your setup script can be as simple as this:

     from distutils.core import setup
     setup(name="foo",
           version="1.0",
           py_modules=["foo"])

Some observations:
   * most information that you supply to the Distutils is supplied as
     keyword arguments to the `setup()' function

   * those keyword arguments fall into two categories: package metadata
     (name, version number) and information about what's in the package
     (a list of pure Python modules, in this case)

   * modules are specified by module name, not filename (the same will
     hold true for packages and extensions)

   * it's recommended that you supply a little more metadata, in
     particular your name, email address and a URL for the project (see
     section~*Note Writing the Setup Script:: for an example)

To create a source distribution for this module, you would create a
setup script, `setup.py', containing the above code, and run:

     python setup.py sdist

which will create an archive file (e.g., tarball on UNIX, ZIP file on
Windows) containing your setup script `setup.py', and your module
`foo.py'.  The archive file will be named `foo-1.0.tar.gz' (or `.zip'),
and will unpack into a directory `foo-1.0'.

If an end-user wishes to install your `foo' module, all she has to do
is download `foo-1.0.tar.gz' (or `.zip'), unpack it, and--from the
`foo-1.0' directory--run

     python setup.py install

which will ultimately copy `foo.py' to the appropriate directory for
third-party modules in their Python installation.

This simple example demonstrates some fundamental concepts of the
Distutils. First, both developers and installers have the same basic
user interface, i.e. the setup script.  The difference is which
Distutils _commands_ they use: the `sdist' command is almost
exclusively for module developers, while `install' is more often for
installers (although most developers will want to install their own
code occasionally).

If you want to make things really easy for your users, you can create
one or more built distributions for them.  For instance, if you are
running on a Windows machine, and want to make things easy for other
Windows users, you can create an executable installer (the most
appropriate type of built distribution for this platform) with the
`bdist_wininst' command.  For example:

     python setup.py bdist_wininst

will create an executable installer, `foo-1.0.win32.exe', in the
current directory.

Other useful built distribution formats are RPM, implemented by the
`bdist_rpm' command, Solaris `pkgtool' (`bdist_pkgtool'), and HP-UX
`swinstall' (`bdist_sdux').  For example, the following command will
create an RPM file called `foo-1.0.noarch.rpm':

     python setup.py bdist_rpm

(The `bdist_rpm' command uses the `rpm' executable, therefore this has
to be run on an RPM-based system such as Red Hat Linux, SuSE Linux, or
Mandrake Linux.)

You can find out what distribution formats are available at any time by
running

     python setup.py bdist --help-formats


File: python-dist.info,  Node: General Python terminology,  Next: Distutils-specific terminology,  Prev: A Simple Example,  Up: Concepts & Terminology

General Python terminology
==========================

If you're reading this document, you probably have a good idea of what
modules, extensions, and so forth are.  Nevertheless, just to be sure
that everyone is operating from a common starting point, we offer the
following glossary of common Python terms:
`module'
     the basic unit of code reusability in Python: a block of code
     imported by some other code.  Three types of modules concern us
     here: pure Python modules, extension modules, and packages.

`pure Python module'
     a module written in Python and contained in a single `.py' file
     (and possibly associated `.pyc' and/or `.pyo' files).  Sometimes
     referred to as a "pure module."

`extension module'
     a module written in the low-level language of the Python
     implementation: C/C++ for Python, Java for Jython.  Typically
     contained in a single dynamically loadable pre-compiled file, e.g.
     a shared object (`.so') file for Python extensions on UNIX, a DLL
     (given the `.pyd' extension) for Python extensions on Windows, or
     a Java class file for Jython extensions.  (Note that currently,
     the Distutils only handles C/C++ extensions for Python.)

`package'
     a module that contains other modules; typically contained in a
     directory in the filesystem and distinguished from other
     directories by the presence of a file `__init__.py'.

`root package'
     the root of the hierarchy of packages.  (This isn't really a
     package, since it doesn't have an `__init__.py' file.  But we have
     to call it something.)  The vast majority of the standard library
     is in the root package, as are many small, standalone third-party
     modules that don't belong to a larger module collection.  Unlike
     regular packages, modules in the root package can be found in many
     directories: in fact, every directory listed in `sys.path'
     contributes modules to the root package.


File: python-dist.info,  Node: Distutils-specific terminology,  Prev: General Python terminology,  Up: Concepts & Terminology

Distutils-specific terminology
==============================

The following terms apply more specifically to the domain of
distributing Python modules using the Distutils:
`module distribution'
     a collection of Python modules distributed together as a single
     downloadable resource and meant to be installed _en masse_.
     Examples of some well-known module distributions are Numeric
     Python, PyXML, PIL (the Python Imaging Library), or mxBase.  (This
     would be called a _package_, except that term is already taken in
     the Python context: a single module distribution may contain zero,
     one, or many Python packages.)

`pure module distribution'
     a module distribution that contains only pure Python modules and
     packages.  Sometimes referred to as a "pure distribution."

`non-pure module distribution'
     a module distribution that contains at least one extension module.
     Sometimes referred to as a "non-pure distribution."

`distribution root'
     the top-level directory of your source tree (or source
     distribution); the directory where `setup.py' exists.  Generally
     `setup.py' will be run from this directory.


File: python-dist.info,  Node: Writing the Setup Script,  Next: Writing the Setup Configuration File,  Prev: Concepts & Terminology,  Up: Top

Writing the Setup Script
************************

The setup script is the centre of all activity in building,
distributing, and installing modules using the Distutils.  The main
purpose of the setup script is to describe your module distribution to
the Distutils, so that the various commands that operate on your modules
do the right thing.  As we saw in section~*Note A Simple Example::
above, the setup script consists mainly of a call to `setup()', and
most information supplied to the Distutils by the module developer is
supplied as keyword arguments to `setup()'.

Here's a slightly more involved example, which we'll follow for the next
couple of sections: the Distutils' own setup script.  (Keep in mind that
although the Distutils are included with Python 1.6 and later, they also
have an independent existence so that Python 1.5.2 users can use them to
install other module distributions.  The Distutils' own setup script,
shown here, is used to install the package into Python 1.5.2.)

     #!/usr/bin/env python
     
     from distutils.core import setup
     
     setup(name="Distutils",
           version="1.0",
           description="Python Distribution Utilities",
           author="Greg Ward",
           author_email="gward@python.net",
           url="http://www.python.org/sigs/distutils-sig/",
           packages=['distutils', 'distutils.command'],
          )

There are only two differences between this and the trivial one-file
distribution presented in section~*Note A Simple Example::: more
metadata, and the specification of pure Python modules by package,
rather than by module.  This is important since the Distutils consist of
a couple of dozen modules split into (so far) two packages; an explicit
list of every module would be tedious to generate and difficult to
maintain.  For more information on the additional meta-data, see
section~*Note Debugging the setup script::.

Note that any pathnames (files or directories) supplied in the setup
script should be written using the UNIX convention, i.e.
slash-separated.  The Distutils will take care of converting this
platform-neutral representation into whatever is appropriate on your
current platform before actually using the pathname.  This makes your
setup script portable across operating systems, which of course is one
of the major goals of the Distutils.  In this spirit, all pathnames in
this document are slash-separated.  (MacOS programmers should keep in
mind that the _absence_ of a leading slash indicates a relative path,
the opposite of the MacOS convention with colons.)

This, of course, only applies to pathnames given to Distutils
functions.  If you, for example, use standard Python functions such as
`glob.glob()' or `os.listdir()' to specify files, you should be careful
to write portable code instead of hardcoding path separators:

         glob.glob(os.path.join('mydir', 'subdir', '*.html'))
         os.listdir(os.path.join('mydir', 'subdir'))

* Menu:

* Listing whole packages::
* Listing individual modules::
* Describing extension modules::
* Installing Scripts::
* Installing Additional Files::
* Additional meta-data::
* Debugging the setup script::


File: python-dist.info,  Node: Listing whole packages,  Next: Listing individual modules,  Prev: Writing the Setup Script,  Up: Writing the Setup Script

Listing whole packages
======================

The `packages' option tells the Distutils to process (build,
distribute, install, etc.) all pure Python modules found in each package
mentioned in the `packages' list.  In order to do this, of course,
there has to be a correspondence between package names and directories
in the filesystem.  The default correspondence is the most obvious one,
i.e. package `distutils' is found in the directory `distutils' relative
to the distribution root.  Thus, when you say `packages = ['foo']' in
your setup script, you are promising that the Distutils will find a
file `foo/__init__.py' (which might be spelled differently on your
system, but you get the idea) relative to the directory where your
setup script lives.  If you break this promise, the Distutils will
issue a warning but still process the broken package anyways.

If you use a different convention to lay out your source directory,
that's no problem: you just have to supply the `package_dir' option to
tell the Distutils about your convention.  For example, say you keep
all Python source under `lib', so that modules in the "root package"
(i.e., not in any package at all) are in `lib', modules in the `foo'
package are in `lib/foo', and so forth.  Then you would put

     package_dir = {'': 'lib'}

in your setup script.  The keys to this dictionary are package names,
and an empty package name stands for the root package.  The values are
directory names relative to your distribution root.  In this case, when
you say `packages = ['foo']', you are promising that the file
`lib/foo/__init__.py' exists.

Another possible convention is to put the `foo' package right in `lib',
the `foo.bar' package in `lib/bar', etc.  This would be written in the
setup script as

     package_dir = {'foo': 'lib'}

A `PACKAGE: DIR' entry in the `package_dir' dictionary implicitly
applies to all packages below PACKAGE, so the `foo.bar' case is
automatically handled here.  In this example, having `packages =
['foo', 'foo.bar']' tells the Distutils to look for `lib/__init__.py'
and `lib/bar/__init__.py'.  (Keep in mind that although `package_dir'
applies recursively, you must explicitly list all packages in
`packages': the Distutils will _not_ recursively scan your source tree
looking for any directory with an `__init__.py' file.)


File: python-dist.info,  Node: Listing individual modules,  Next: Describing extension modules,  Prev: Listing whole packages,  Up: Writing the Setup Script

Listing individual modules
==========================

For a small module distribution, you might prefer to list all modules
rather than listing packages--especially the case of a single module
that goes in the "root package" (i.e., no package at all).  This
simplest case was shown in section~*Note A Simple Example::; here is a
slightly more involved example:

     py_modules = ['mod1', 'pkg.mod2']

This describes two modules, one of them in the "root" package, the
other in the `pkg' package.  Again, the default package/directory
layout implies that these two modules can be found in `mod1.py' and
`pkg/mod2.py', and that `pkg/__init__.py' exists as well.  And again,
you can override the package/directory correspondence using the
`package_dir' option.


File: python-dist.info,  Node: Describing extension modules,  Next: Installing Scripts,  Prev: Listing individual modules,  Up: Writing the Setup Script

Describing extension modules
============================

Just as writing Python extension modules is a bit more complicated than
writing pure Python modules, describing them to the Distutils is a bit
more complicated.  Unlike pure modules, it's not enough just to list
modules or packages and expect the Distutils to go out and find the
right files; you have to specify the extension name, source file(s), and
any compile/link requirements (include directories, libraries to link
with, etc.).

All of this is done through another keyword argument to `setup()', the
`extensions' option.  `extensions' is just a list of `Extension'
instances, each of which describes a single extension module.  Suppose
your distribution includes a single extension, called `foo' and
implemented by `foo.c'.  If no additional instructions to the
compiler/linker are needed, describing this extension is quite simple:

     uExtension("foo", ["foo.c"])

The `Extension' class can be imported from `distutils.core' along with
`setup()'.  Thus, the setup script for a module distribution that
contains only this one extension and nothing else might be:

     from distutils.core import setup, Extension
     setup(name="foo", version="1.0",
           ext_modules=[Extension("foo", ["foo.c"])])

The `Extension' class (actually, the underlying extension-building
machinery implemented by the `build_ext' command) supports a great deal
of flexibility in describing Python extensions, which is explained in
the following sections.

* Menu:

* Extension names and packages::
* Extension source files::
* Preprocessor options::
* Library options::
* Other options::


File: python-dist.info,  Node: Extension names and packages,  Next: Extension source files,  Prev: Describing extension modules,  Up: Describing extension modules

Extension names and packages
----------------------------

The first argument to the `Extension' constructor is always the name of
the extension, including any package names.  For example,

     Extension("foo", ["src/foo1.c", "src/foo2.c"])

describes an extension that lives in the root package, while

     Extension("pkg.foo", ["src/foo1.c", "src/foo2.c"])

describes the same extension in the `pkg' package.  The source files
and resulting object code are identical in both cases; the only
difference is where in the filesystem (and therefore where in Python's
namespace hierarchy) the resulting extension lives.

If you have a number of extensions all in the same package (or all under
the same base package), use the `ext_package' keyword argument to
`setup()'.  For example,

     setup(...
           ext_package="pkg",
           ext_modules=[Extension("foo", ["foo.c"]),
                        Extension("subpkg.bar", ["bar.c"])]
          )

will compile `foo.c' to the extension `pkg.foo', and `bar.c' to
`pkg.subpkg.bar'.


File: python-dist.info,  Node: Extension source files,  Next: Preprocessor options,  Prev: Extension names and packages,  Up: Describing extension modules

Extension source files
----------------------

The second argument to the `Extension' constructor is a list of source
files.  Since the Distutils currently only support C, C++, and
Objective-C extensions, these are normally C/C++/Objective-C source
files.  (Be sure to use appropriate extensions to distinguish C++
source files: `.cc' and `.cpp' seem to be recognized by both UNIX and
Windows compilers.)

However, you can also include SWIG interface (`.i') files in the list;
the `build_ext' command knows how to deal with SWIG extensions: it will
run SWIG on the interface file and compile the resulting C/C++ file
into your extension.

*SWIG support is rough around the edges and largely untested;
especially SWIG support for C++ extensions!  Explain in more detail
here when the interface firms up.*

On some platforms, you can include non-source files that are processed
by the compiler and included in your extension.  Currently, this just
means Windows message text (`.mc') files and resource definition
(`.rc') files for Visual C++. These will be compiled to binary resource
(`.res') files and linked into the executable.


File: python-dist.info,  Node: Preprocessor options,  Next: Library options,  Prev: Extension source files,  Up: Describing extension modules

Preprocessor options
--------------------

Three optional arguments to `Extension' will help if you need to
specify include directories to search or preprocessor macros to
define/undefine: `include_dirs', `define_macros', and `undef_macros'.

For example, if your extension requires header files in the `include'
directory under your distribution root, use the `include_dirs' option:

     Extension("foo", ["foo.c"], include_dirs=["include"])

You can specify absolute directories there; if you know that your
extension will only be built on UNIX systems with X11R6 installed to
`/usr', you can get away with

     Extension("foo", ["foo.c"], include_dirs=["/usr/include/X11"])

You should avoid this sort of non-portable usage if you plan to
distribute your code: it's probably better to write C code like
     #include <X11/Xlib.h>

If you need to include header files from some other Python extension,
you can take advantage of the fact that header files are installed in a
consistent way by the Distutils `install_header' command.  For example,
the Numerical Python header files are installed (on a standard Unix
installation) to `/usr/local/include/python1.5/Numerical'.  (The exact
location will differ according to your platform and Python
installation.)  Since the Python include
directory--`/usr/local/include/python1.5' in this case--is always
included in the search path when building Python extensions, the best
approach is to write C code like
     #include <Numerical/arrayobject.h>

If you must put the `Numerical' include directory right into your
header search path, though, you can find that directory using the
Distutils `sysconfig' module:

     from distutils.sysconfig import get_python_inc
     incdir = os.path.join(get_python_inc(plat_specific=1), "Numerical")
     setup(...,
           Extension(..., include_dirs=[incdir]))

Even though this is quite portable--it will work on any Python
installation, regardless of platform--it's probably easier to just
write your C code in the sensible way.

You can define and undefine pre-processor macros with the
`define_macros' and `undef_macros' options.  `define_macros' takes a
list of `(name, value)' tuples, where `name' is the name of the macro
to define (a string) and `value' is its value: either a string or
`None'.  (Defining a macro `FOO' to `None' is the equivalent of a bare
`#define FOO' in your C source: with most compilers, this sets `FOO' to
the string `1'.)  `undef_macros' is just a list of macros to undefine.

For example:

     Extension(...,
               define_macros=[('NDEBUG', '1')],
                              ('HAVE_STRFTIME', None),
               undef_macros=['HAVE_FOO', 'HAVE_BAR'])

is the equivalent of having this at the top of every C source file:

     #define NDEBUG 1
     #define HAVE_STRFTIME
     #undef HAVE_FOO
     #undef HAVE_BAR


File: python-dist.info,  Node: Library options,  Next: Other options,  Prev: Preprocessor options,  Up: Describing extension modules

Library options
---------------

You can also specify the libraries to link against when building your
extension, and the directories to search for those libraries.  The
`libraries' option is a list of libraries to link against,
`library_dirs' is a list of directories to search for libraries at
link-time, and `runtime_library_dirs' is a list of directories to
search for shared (dynamically loaded) libraries at run-time.

For example, if you need to link against libraries known to be in the
standard library search path on target systems

     Extension(...,
               libraries=["gdbm", "readline"])

If you need to link with libraries in a non-standard location, you'll
have to include the location in `library_dirs':

     Extension(...,
               library_dirs=["/usr/X11R6/lib"],
               libraries=["X11", "Xt"])

(Again, this sort of non-portable construct should be avoided if you
intend to distribute your code.)

*Should mention clib libraries here or somewhere else!*


File: python-dist.info,  Node: Other options,  Prev: Library options,  Up: Describing extension modules

Other options
-------------

There are still some other options which can be used to handle special
cases.

The `extra_objects' option is a list of object files to be passed to
the linker. These files must not have extensions, as the default
extension for the compiler is used.

`extra_compile_args' and `extra_link_args' can be used to specify
additional command line options for the respective compiler and linker
command lines.

`export_symbols' is only useful on Windows.  It can contain a list of
symbols (functions or variables) to be exported. This option is not
needed when building compiled extensions: Distutils will automatically
add `initmodule' to the list of exported symbols.


File: python-dist.info,  Node: Installing Scripts,  Next: Installing Additional Files,  Prev: Describing extension modules,  Up: Writing the Setup Script

Installing Scripts
==================

So far we have been dealing with pure and non-pure Python modules,
which are usually not run by themselves but imported by scripts.

Scripts are files containing Python source code, intended to be started
from the command line.  Scripts don't require Distutils to do anything
very complicated.  The only clever feature is that if the first line of
the script starts with `#!' and contains the word "python", the
Distutils will adjust the first line to refer to the current
interpreter location.

The `scripts' option simply is a list of files to be handled in this
way.  From the PyXML setup script:

     setup (...
            scripts = ['scripts/xmlproc_parse', 'scripts/xmlproc_val']
           )


File: python-dist.info,  Node: Installing Additional Files,  Next: Additional meta-data,  Prev: Installing Scripts,  Up: Writing the Setup Script

Installing Additional Files
===========================

The `data_files' option can be used to specify additional files needed
by the module distribution: configuration files, message catalogs, data
files, anything which doesn't fit in the previous categories.

`data_files' specifies a sequence of (DIRECTORY, FILES) pairs in the
following way:

     setup(...
           data_files=[('bitmaps', ['bm/b1.gif', 'bm/b2.gif']),
                       ('config', ['cfg/data.cfg']),
                       ('/etc/init.d', ['init-script'])]
          )

Note that you can specify the directory names where the data files will
be installed, but you cannot rename the data files themselves.

Each (DIRECTORY, FILES) pair in the sequence specifies the installation
directory and the files to install there.  If DIRECTORY is a relative
path, it is interpreted relative to the installation prefix (Python's
`sys.prefix' for pure-Python packages, `sys.exec_prefix' for packages
that contain extension modules).  Each file name in FILES is
interpreted relative to the `setup.py' script at the top of the package
source distribution.  No directory information from FILES is used to
determine the final location of the installed file; only the name of
the file is used.

You can specify the `data_files' options as a simple sequence of files
without specifying a target directory, but this is not recommended, and
the `install' command will print a warning in this case.  To install
data files directly in the target directory, an empty string should be
given as the directory.


File: python-dist.info,  Node: Additional meta-data,  Next: Debugging the setup script,  Prev: Installing Additional Files,  Up: Writing the Setup Script

Additional meta-data
====================

The setup script may include additional meta-data beyond the name and
version. This information includes:

Meta-Data          Description        Value              Notes
------             ------             ------             ------
name               name of the        short string       (1)
                   package                               
version            version of this    short string       (1)(2)
                   release                               
author             package author's   short string       (3)
                   name                                  
author_email       email address of   email address      (3)
                   the package                           
                   author                                
maintainer         package            short string       (3)
                   maintainer's name                     
maintainer_email   email address of   email address      (3)
                   the package                           
                   maintainer                            
url                home page for the  URL                (1)
                   package                               
description        short, summary     short string       
                   description of                        
                   the package                           
long_description   longer             long string        
                   description of                        
                   the package                           
download_url       location where     URL                (4)
                   the package may                       
                   be downloaded                         
classifiers        a list of Trove    list of strings    (4)
                   classifiers                           

Notes:
`(1)'
     These fields are required.

`(2)'
     It is recommended that versions take the form
     _major.minor[.patch[.sub]]_.

`(3)'
     Either the author or the maintainer must be identified.

`(4)'
     These fields should not be used if your package is to be
     compatible with Python versions prior to 2.2.3 or 2.3.  The list is
     available from the PyPI website.

`"short string"'
     A single line of text, not more than 200 characters.

`"long string"'
     Multiple lines of plain text in ReStructuredText format (see
     <http://docutils.sf.net/>).

`"list of strings"'
     See below.

None of the string values may be Unicode.

Encoding the version information is an art in itself. Python packages
generally adhere to the version format _major.minor[.patch][sub]_. The
major number is 0 for initial, experimental releases of software. It is
incremented for releases that represent major milestones in a package.
The minor number is incremented when important new features are added
to the package. The patch number increments when bug-fix releases are
made. Additional trailing version information is sometimes used to
indicate sub-releases.  These are "a1,a2,...,aN" (for alpha releases,
where functionality and API may change), "b1,b2,...,bN" (for beta
releases, which only fix bugs) and "pr1,pr2,...,prN" (for final
pre-release release testing). Some examples:

`0.1.0'
     the first, experimental release of a package

`1.0.1a2'
     the second alpha release of the first patch version of 1.0

`classifiers' are specified in a python list:

     setup(...
           classifiers = [
               'Development Status :: 4 - Beta',
               'Environment :: Console',
               'Environment :: Web Environment',
               'Intended Audience :: End Users/Desktop',
               'Intended Audience :: Developers',
               'Intended Audience :: System Administrators',
               'License :: OSI Approved :: Python Software Foundation License',
               'Operating System :: MacOS :: MacOS X',
               'Operating System :: Microsoft :: Windows',
               'Operating System :: POSIX',
               'Programming Language :: Python',
               'Topic :: Communications :: Email',
               'Topic :: Office/Business',
               'Topic :: Software Development :: Bug Tracking',
               ],
           )

If you wish to include classifiers in your `setup.py' file and also
wish to remain backwards-compatible with Python releases prior to 2.2.3,
then you can include the following code fragment in your `setup.py'
before the `setup()' call.

     # patch distutils if it can't cope with the "classifiers" or
     # "download_url" keywords
     if sys.version < '2.2.3':
         from distutils.dist import DistributionMetadata
         DistributionMetadata.classifiers = None
         DistributionMetadata.download_url = None


File: python-dist.info,  Node: Debugging the setup script,  Prev: Additional meta-data,  Up: Writing the Setup Script

Debugging the setup script
==========================

Sometimes things go wrong, and the setup script doesn't do what the
developer wants.

Distutils catches any exceptions when running the setup script, and
print a simple error message before the script is terminated.  The
motivation for this behaviour is to not confuse administrators who
don't know much about Python and are trying to install a package.  If
they get a big long traceback from deep inside the guts of Distutils,
they may think the package or the Python installation is broken because
they don't read all the way down to the bottom and see that it's a
permission problem.

On the other hand, this doesn't help the developer to find the cause of
the failure. For this purpose, the DISTUTILS_DEBUG environment variable
can be set to anything except an empty string, and distutils will now
print detailed information what it is doing, and prints the full
traceback in case an exception occurrs.


File: python-dist.info,  Node: Writing the Setup Configuration File,  Next: Creating a Source Distribution,  Prev: Writing the Setup Script,  Up: Top

Writing the Setup Configuration File
************************************

Often, it's not possible to write down everything needed to build a
distribution _a priori_: you may need to get some information from the
user, or from the user's system, in order to proceed.  As long as that
information is fairly simple--a list of directories to search for C
header files or libraries, for example--then providing a configuration
file, `setup.cfg', for users to edit is a cheap and easy way to solicit
it.  Configuration files also let you provide default values for any
command option, which the installer can then override either on the
command-line or by editing the config file.

The setup configuration file is a useful middle-ground between the setup
script--which, ideally, would be opaque to installers(1)--and the
command-line to the setup script, which is outside of your control and
entirely up to the installer.  In fact, `setup.cfg' (and any other
Distutils configuration files present on the target system) are
processed after the contents of the setup script, but before the
command-line.  This has several useful consequences:
   * installers can override some of what you put in `setup.py' by
     editing `setup.cfg'

   * you can provide non-standard defaults for options that are not
     easily set in `setup.py'

   * installers can override anything in `setup.cfg' using the
     command-line options to `setup.py'

The basic syntax of the configuration file is simple:

     [command]
     option=value
     ...

where COMMAND is one of the Distutils commands (e.g.  `build_py',
`install'), and OPTION is one of the options that command supports.
Any number of options can be supplied for each command, and any number
of command sections can be included in the file.  Blank lines are
ignored, as are comments, which run from a `#' character until the end
of the line.  Long option values can be split across multiple lines
simply by indenting the continuation lines.

You can find out the list of options supported by a particular command
with the universal `--help' option, e.g.

     > python setup.py --help build_ext
     [...]
     Options for 'build_ext' command:
       --build-lib (-b)     directory for compiled extension modules
       --build-temp (-t)    directory for temporary files (build by-products)
       --inplace (-i)       ignore build-lib and put compiled extensions into the
                            source directory alongside your pure Python modules
       --include-dirs (-I)  list of directories to search for header files
       --define (-D)        C preprocessor macros to define
       --undef (-U)         C preprocessor macros to undefine
     [...]

Note that an option spelled `--foo-bar' on the command-line is spelled
`foo_bar' in configuration files.

For example, say you want your extensions to be built "in-place"--that
is, you have an extension `pkg.ext', and you want the compiled
extension file (`ext.so' on UNIX, say) to be put in the same source
directory as your pure Python modules `pkg.mod1' and `pkg.mod2'.  You
can always use the `--inplace' option on the command-line to ensure
this:

     python setup.py build_ext --inplace

But this requires that you always specify the `build_ext' command
explicitly, and remember to provide `--inplace'.  An easier way is to
"set and forget" this option, by encoding it in `setup.cfg', the
configuration file for this distribution:

     [build_ext]
     inplace=1

This will affect all builds of this module distribution, whether or not
you explcitly specify `build_ext'.  If you include `setup.cfg' in your
source distribution, it will also affect end-user builds--which is
probably a bad idea for this option, since always building extensions
in-place would break installation of the module distribution.  In
certain peculiar cases, though, modules are built right in their
installation directory, so this is conceivably a useful ability.
(Distributing extensions that expect to be built in their installation
directory is almost always a bad idea, though.)

Another example: certain commands take a lot of options that don't
change from run to run; for example, `bdist_rpm' needs to know
everything required to generate a "spec" file for creating an RPM
distribution.  Some of this information comes from the setup script, and
some is automatically generated by the Distutils (such as the list of
files installed).  But some of it has to be supplied as options to
`bdist_rpm', which would be very tedious to do on the command-line for
every run.  Hence, here is a snippet from the Distutils' own
`setup.cfg':

     [bdist_rpm]
     release = 1
     packager = Greg Ward <gward@python.net>
     doc_files = CHANGES.txt
                 README.txt
                 USAGE.txt
                 doc/
                 examples/

Note that the `doc_files' option is simply a whitespace-separated
string split across multiple lines for readability.

See also:
     `Installing Python Modules'{More information on the configuration
     files is available in the manual for system administrators.}

---------- Footnotes ----------

(1) This ideal probably won't be achieved until auto-configuration is
fully supported by the Distutils.


File: python-dist.info,  Node: Creating a Source Distribution,  Next: Creating Built Distributions,  Prev: Writing the Setup Configuration File,  Up: Top

Creating a Source Distribution
******************************

As shown in section~*Note A Simple Example::, you use the `sdist'
command to create a source distribution.  In the simplest case,

     python setup.py sdist

(assuming you haven't specified any `sdist' options in the setup script
or config file), `sdist' creates the archive of the default format for
the current platform.  The default format is a gzip'ed tar file
(`.tar.gz') on UNIX, and ZIP file on Windows.  *no MacOS support here*

You can specify as many formats as you like using the `--formats'
option, for example:

     python setup.py sdist --formats=gztar,zip

to create a gzipped tarball and a zip file.  The available formats are:
Format                   Description              Notes
------                   -----                    -----
zip                      zip file (`.zip')        (1),(3)
gztar                    gzip'ed tar file         (2),(4)
                         (`.tar.gz')              
bztar                    bzip2'ed tar file        (4)
                         (`.tar.bz2')             
ztar                     compressed tar file      (4)
                         (`.tar.Z')               
tar                      tar file (`.tar')        (4)

Notes:
`(1)'
     default on Windows

`(2)'
     default on UNIX

`(3)'
     requires either external `zip' utility or `zipfile' module (part
     of the standard Python library since Python~1.6)

`(4)'
     requires external utilities: `tar' and possibly one of `gzip',
     `bzip2', or `compress'

* Menu:

* Specifying the files to distribute::
* Manifest-related options::


File: python-dist.info,  Node: Specifying the files to distribute,  Next: Manifest-related options,  Prev: Creating a Source Distribution,  Up: Creating a Source Distribution

Specifying the files to distribute
==================================

If you don't supply an explicit list of files (or instructions on how to
generate one), the `sdist' command puts a minimal default set into the
source distribution:
   * all Python source files implied by the `py_modules' and `packages'
     options

   * all C source files mentioned in the `ext_modules' or `libraries'
     options (*getting C library sources currently broken - no
     get_source_files() method in build_clib.py!*)

   * anything that looks like a test script: `test/test*.py'
     (currently, the Distutils don't do anything with test scripts
     except include them in source distributions, but in the future
     there will be a standard for testing Python module distributions)

   * `README.txt' (or `README'), `setup.py' (or whatever you called
     your setup script), and `setup.cfg'

Sometimes this is enough, but usually you will want to specify
additional files to distribute.  The typical way to do this is to write
a _manifest template_, called `MANIFEST.in' by default.  The manifest
template is just a list of instructions for how to generate your
manifest file, `MANIFEST', which is the exact list of files to include
in your source distribution.  The `sdist' command processes this
template and generates a manifest based on its instructions and what it
finds in the filesystem.

If you prefer to roll your own manifest file, the format is simple: one
filename per line, regular files (or symlinks to them) only.  If you do
supply your own `MANIFEST', you must specify everything: the default
set of files described above does not apply in this case.

The manifest template has one command per line, where each command
specifies a set of files to include or exclude from the source
distribution.  For an example, again we turn to the Distutils' own
manifest template:

     include *.txt
     recursive-include examples *.txt *.py
     prune examples/sample?/build

The meanings should be fairly clear: include all files in the
distribution root matching `*.txt', all files anywhere under the
`examples' directory matching `*.txt' or `*.py', and exclude all
directories matching `examples/sample?/build'.  All of this is done
_after_ the standard include set, so you can exclude files from the
standard set with explicit instructions in the manifest template.  (Or,
you can use the `--no-defaults' option to disable the standard set
entirely.)  There are several other commands available in the manifest
template mini-language; see section~*Note Creating a source
distribution the sdist command::.

The order of commands in the manifest template matters: initially, we
have the list of default files as described above, and each command in
the template adds to or removes from that list of files.  Once we have
fully processed the manifest template, we remove files that should not
be included in the source distribution:
   * all files in the Distutils "build" tree (default `build/')

   * all files in directories named `RCS' or `CVS'

Now we have our complete list of files, which is written to the manifest
for future reference, and then used to build the source distribution
archive(s).

You can disable the default set of included files with the
`--no-defaults' option, and you can disable the standard exclude set
with `--no-prune'.

Following the Distutils' own manifest template, let's trace how the
`sdist' command builds the list of files to include in the Distutils
source distribution:
  1. include all Python source files in the `distutils' and
     `distutils/command' subdirectories (because packages corresponding
     to those two directories were mentioned in the `packages' option
     in the setup script--see section~*Note Writing the Setup Script::)

  2. include `README.txt', `setup.py', and `setup.cfg' (standard files)

  3. include `test/test*.py' (standard files)

  4. include `*.txt' in the distribution root (this will find
     `README.txt' a second time, but such redundancies are weeded out
     later)

  5. include anything matching `*.txt' or `*.py' in the sub-tree under
     `examples',

  6. exclude all files in the sub-trees starting at directories
     matching `examples/sample?/build'--this may exclude files included
     by the previous two steps, so it's important that the `prune'
     command in the manifest template comes after the
     `recursive-include' command

  7. exclude the entire `build' tree, and any `RCS' or `CVS' directories
     Just like in the setup script, file and directory names in the
manifest template should always be slash-separated; the Distutils will
take care of converting them to the standard representation on your
platform.  That way, the manifest template is portable across operating
systems.


File: python-dist.info,  Node: Manifest-related options,  Prev: Specifying the files to distribute,  Up: Creating a Source Distribution

Manifest-related options
========================

The normal course of operations for the `sdist' command is as follows:
   * if the manifest file, `MANIFEST' doesn't exist, read `MANIFEST.in'
     and create the manifest

   * if neither `MANIFEST' nor `MANIFEST.in' exist, create a manifest
     with just the default file set

   * if either `MANIFEST.in' or the setup script (`setup.py') are more
     recent than `MANIFEST', recreate `MANIFEST' by reading
     `MANIFEST.in'

   * use the list of files now in `MANIFEST' (either just generated or
     read in) to create the source distribution archive(s)

There are a couple of options that modify this behaviour.  First, use
the `--no-defaults' and `--no-prune' to disable the standard "include"
and "exclude" sets.

Second, you might want to force the manifest to be regenerated--for
example, if you have added or removed files or directories that match an
existing pattern in the manifest template, you should regenerate the
manifest:

     python setup.py sdist --force-manifest

Or, you might just want to (re)generate the manifest, but not create a
source distribution:

     python setup.py sdist --manifest-only

`--manifest-only' implies `--force-manifest'.  `-o' is a shortcut for
`--manifest-only', and `-f' for `--force-manifest'.

