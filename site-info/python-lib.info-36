This is python-lib.info, produced by makeinfo version 4.3 from
python-lib.texi.

October 3, 2003


File: python-lib.info,  Node: mimetypes,  Next: MimeWriter,  Prev: mimetools,  Up: Internet Data Handling

Map filenames to MIME types
===========================

Mapping of filename extensions to MIME types.

The `mimetypes' module converts between a filename or URL and the MIME
type associated with the filename extension.  Conversions are provided
from filename to MIME type and from MIME type to filename extension;
encodings are not supported for the latter conversion.

The module provides one class and a number of convenience functions.
The functions are the normal interface to this module, but some
applications may be interested in the class as well.

The functions described below provide the primary interface for this
module.  If the module has not been initialized, they will call
`init()' if they rely on the information `init()' sets up.

`guess_type(filename[, strict])'
     Guess the type of a file based on its filename or URL, given by
     FILENAME.  The return value is a tuple `(TYPE, ENCODING)' where
     TYPE is `None' if the type can't be guessed (missing or unknown
     suffix) or a string of the form `'TYPE/SUBTYPE'', usable for a MIME
     `content-type' header .

     ENCODING is `None' for no encoding or the name of the program used
     to encode (e.g. `compress' or `gzip').  The encoding is suitable
     for use as a `Content-Encoding' header, _not_ as a
     `Content-Transfer-Encoding' header.  The mappings are table
     driven.  Encoding suffixes are case sensitive; type suffixes are
     first tried case sensitively, then case insensitively.

     Optional STRICT is a flag specifying whether the list of known
     MIME types is limited to only the official types registered with
     IANA are recognized.  When STRICT is true (the default), only the
     IANA types are supported; when STRICT is false, some additional
     non-standard but commonly used MIME types are also recognized.

`guess_all_extensions(type[, strict])'
     Guess the extensions for a file based on its MIME type, given by
     TYPE.  The return value is a list of strings giving all possible
     filename extensions, including the leading dot (`.').  The
     extensions are not guaranteed to have been associated with any
     particular data stream, but would be mapped to the MIME type TYPE
     by `guess_type()'.

     Optional STRICT has the same meaning as with the `guess_type()'
     function.

`guess_extension(type[, strict])'
     Guess the extension for a file based on its MIME type, given by
     TYPE.  The return value is a string giving a filename extension,
     including the leading dot (`.').  The extension is not guaranteed
     to have been associated with any particular data stream, but would
     be mapped to the MIME type TYPE by `guess_type()'.  If no
     extension can be guessed for TYPE, `None' is returned.

     Optional STRICT has the same meaning as with the `guess_type()'
     function.

Some additional functions and data items are available for controlling
the behavior of the module.

`init([files])'
     Initialize the internal data structures.  If given, FILES must be
     a sequence of file names which should be used to augment the
     default type map.  If omitted, the file names to use are taken from
     `knownfiles'.  Each file named in FILES or `knownfiles' takes
     precedence over those named before it.  Calling `init()'
     repeatedly is allowed.

`read_mime_types(filename)'
     Load the type map given in the file FILENAME, if it exists.  The
     type map is returned as a dictionary mapping filename extensions,
     including the leading dot (`.'), to strings of the form
     `'TYPE/SUBTYPE''.  If the file FILENAME does not exist or cannot
     be read, `None' is returned.

`add_type(type, ext[, strict])'
     Add a mapping from the mimetype TYPE to the extension EXT.  When
     the extension is already known, the new type will replace the old
     one. When the type is already known the extension will be added to
     the list of known extensions.

     When STRICT is the mapping will added to the official MIME types,
     otherwise to the non-standard ones.

`inited'
     Flag indicating whether or not the global data structures have been
     initialized.  This is set to true by `init()'.

`knownfiles'
     List of type map file names commonly installed.  These files are
     typically named `mime.types' and are installed in different
     locations by different packages.

`suffix_map'
     Dictionary mapping suffixes to suffixes.  This is used to allow
     recognition of encoded files for which the encoding and the type
     are indicated by the same extension.  For example, the `.tgz'
     extension is mapped to `.tar.gz' to allow the encoding and type to
     be recognized separately.

`encodings_map'
     Dictionary mapping filename extensions to encoding types.

`types_map'
     Dictionary mapping filename extensions to MIME types.

`common_types'
     Dictionary mapping filename extensions to non-standard, but
     commonly found MIME types.

The `MimeTypes' class may be useful for applications which may want
more than one MIME-type database:

`MimeTypes([filenames])'
     This class represents a MIME-types database.  By default, it
     provides access to the same database as the rest of this module.
     The initial database is a copy of that provided by the module, and
     may be extended by loading additional `mime.types'-style files
     into the database using the `read()' or `readfp()' methods.  The
     mapping dictionaries may also be cleared before loading additional
     data if the default data is not desired.

     The optional FILENAMES parameter can be used to cause additional
     files to be loaded "on top" of the default database.

     _Added in Python version 2.2_

* Menu:

* MimeTypes Objects::


File: python-lib.info,  Node: MimeTypes Objects,  Prev: mimetypes,  Up: mimetypes

MimeTypes Objects
-----------------

`MimeTypes' instances provide an interface which is very like that of
the `mimetypes' module.

`suffix_map'
     Dictionary mapping suffixes to suffixes.  This is used to allow
     recognition of encoded files for which the encoding and the type
     are indicated by the same extension.  For example, the `.tgz'
     extension is mapped to `.tar.gz' to allow the encoding and type to
     be recognized separately.  This is initially a copy of the global
     `suffix_map' defined in the module.

`encodings_map'
     Dictionary mapping filename extensions to encoding types.  This is
     initially a copy of the global `encodings_map' defined in the
     module.

`types_map'
     Dictionary mapping filename extensions to MIME types.  This is
     initially a copy of the global `types_map' defined in the module.

`common_types'
     Dictionary mapping filename extensions to non-standard, but
     commonly found MIME types.  This is initially a copy of the global
     `common_types' defined in the module.

`guess_extension(type[, strict])'
     Similar to the `guess_extension()' function, using the tables
     stored as part of the object.

`guess_type(url[, strict])'
     Similar to the `guess_type()' function, using the tables stored as
     part of the object.

`read(path)'
     Load MIME information from a file named PATH.  This uses
     `readfp()' to parse the file.

`readfp(file)'
     Load MIME type information from an open file.  The file must have
     the format of the standard `mime.types' files.


File: python-lib.info,  Node: MimeWriter,  Next: mimify,  Prev: mimetypes,  Up: Internet Data Handling

Generic MIME file writer
========================

Generic MIME file writer.

_This is deprecated in Python 2.3.  The `email' package should be used
in preference to the `MimeWriter' module.  This module is present only
to maintain backward compatibility._

This module defines the class `MimeWriter'.  The `MimeWriter' class
implements a basic formatter for creating MIME multi-part files.  It
doesn't seek around the output file nor does it use large amounts of
buffer space. You must write the parts out in the order that they
should occur in the final file. `MimeWriter' does buffer the headers
you add, allowing you to rearrange their order.

`MimeWriter(fp)'
     Return a new instance of the `MimeWriter' class.  The only
     argument passed, FP, is a file object to be used for writing. Note
     that a `StringIO' object could also be used.

* Menu:

* MimeWriter Objects::


File: python-lib.info,  Node: MimeWriter Objects,  Prev: MimeWriter,  Up: MimeWriter

MimeWriter Objects
------------------

`MimeWriter' instances have the following methods:

`addheader(key, value[, prefix])'
     Add a header line to the MIME message. The KEY is the name of the
     header, where the VALUE obviously provides the value of the
     header. The optional argument PREFIX determines where the header
     is inserted; `0' means append at the end, `1' is insert at the
     start. The default is to append.

`flushheaders()'
     Causes all headers accumulated so far to be written out (and
     forgotten). This is useful if you don't need a body part at all,
     e.g. for a subpart of type `message/rfc822' that's (mis)used to
     store some header-like information.

`startbody(ctype[, plist[, prefix]])'
     Returns a file-like object which can be used to write to the body
     of the message.  The content-type is set to the provided CTYPE,
     and the optional parameter PLIST provides additional parameters
     for the content-type declaration. PREFIX functions as in
     `addheader()' except that the default is to insert at the start.

`startmultipartbody(subtype[, boundary[, plist[, prefix]]])'
     Returns a file-like object which can be used to write to the body
     of the message.  Additionally, this method initializes the
     multi-part code, where SUBTYPE provides the multipart subtype,
     BOUNDARY may provide a user-defined boundary specification, and
     PLIST provides optional parameters for the subtype.  PREFIX
     functions as in `startbody()'.  Subparts should be created using
     `nextpart()'.

`nextpart()'
     Returns a new instance of `MimeWriter' which represents an
     individual part in a multipart message.  This may be used to write
     the part as well as used for creating recursively complex multipart
     messages. The message must first be initialized with
     `startmultipartbody()' before using `nextpart()'.

`lastpart()'
     This is used to designate the last part of a multipart message, and
     should _always_ be used when writing multipart messages.


File: python-lib.info,  Node: mimify,  Next: multifile,  Prev: MimeWriter,  Up: Internet Data Handling

MIME processing of mail messages
================================

Mimification and unmimification of mail messages.

_This is deprecated in Python 2.3.  The `email' package should be used
in preference to the `mimify' module.  This module is present only to
maintain backward compatibility._

The `mimify' module defines two functions to convert mail messages to
and from MIME format.  The mail message can be either a simple message
or a so-called multipart message.  Each part is treated separately.
Mimifying (a part of) a message entails encoding the message as
quoted-printable if it contains any characters that cannot be
represented using 7-bit ASCII.  Unmimifying (a part of) a message
entails undoing the quoted-printable encoding.  Mimify and unmimify are
especially useful when a message has to be edited before being sent.
Typical use would be:

     unmimify message
     edit message
     mimify message
     send message

The modules defines the following user-callable functions and
user-settable variables:

`mimify(infile, outfile)'
     Copy the message in INFILE to OUTFILE, converting parts to
     quoted-printable and adding MIME mail headers when necessary.
     INFILE and OUTFILE can be file objects (actually, any object that
     has a `readline()' method (for INFILE) or a `write()' method (for
     OUTFILE)) or strings naming the files.  If INFILE and OUTFILE are
     both strings, they may have the same value.

`unmimify(infile, outfile[, decode_base64])'
     Copy the message in INFILE to OUTFILE, decoding all
     quoted-printable parts.  INFILE and OUTFILE can be file objects
     (actually, any object that has a `readline()' method (for INFILE)
     or a `write()' method (for OUTFILE)) or strings naming the files.
     If INFILE and OUTFILE are both strings, they may have the same
     value.  If the DECODE_BASE64 argument is provided and tests true,
     any parts that are coded in the base64 encoding are decoded as
     well.

`mime_decode_header(line)'
     Return a decoded version of the encoded header line in LINE.  This
     only supports the ISO 8859-1 charset (Latin-1).

`mime_encode_header(line)'
     Return a MIME-encoded version of the header line in LINE.

`MAXLEN'
     By default, a part will be encoded as quoted-printable when it
     contains any non-ASCII characters (characters with the 8th bit
     set), or if there are any lines longer than `MAXLEN' characters
     (default value 200).

`CHARSET'
     When not specified in the mail headers, a character set must be
     filled in.  The string used is stored in `CHARSET', and the default
     value is ISO-8859-1 (also known as Latin1 (latin-one)).

This module can also be used from the command line.  Usage is as
follows:
     mimify.py -e [-l length] [infile [outfile]]
     mimify.py -d [-b] [infile [outfile]]

to encode (mimify) and decode (unmimify) respectively.  INFILE defaults
to standard input, OUTFILE defaults to standard output.  The same file
can be specified for input and output.

If the *-l* option is given when encoding, if there are any lines
longer than the specified LENGTH, the containing part will be encoded.

If the *-b* option is given when decoding, any base64 parts will be
decoded as well.

See also:
     *Note quopri:: Encode and decode MIME quoted-printable files.


File: python-lib.info,  Node: multifile,  Next: rfc822,  Prev: mimify,  Up: Internet Data Handling

Support for files containing distinct parts
===========================================

Support for reading files which contain distinct parts, such as some
MIME data.

The `MultiFile' object enables you to treat sections of a text file as
file-like input objects, with `''' being returned by `readline()' when
a given delimiter pattern is encountered.  The defaults of this class
are designed to make it useful for parsing MIME multipart messages, but
by subclassing it and overriding methods it can be easily adapted for
more general use.

`MultiFile(fp[, seekable])'
     Create a multi-file.  You must instantiate this class with an input
     object argument for the `MultiFile' instance to get lines from,
     such as a file object returned by `open()'.

     `MultiFile' only ever looks at the input object's `readline()',
     `seek()' and `tell()' methods, and the latter two are only needed
     if you want random access to the individual MIME parts. To use
     `MultiFile' on a non-seekable stream object, set the optional
     SEEKABLE argument to false; this will prevent using the input
     object's `seek()' and `tell()' methods.

It will be useful to know that in `MultiFile''s view of the world, text
is composed of three kinds of lines: data, section-dividers, and
end-markers.  MultiFile is designed to support parsing of messages that
may have multiple nested message parts, each with its own pattern for
section-divider and end-marker lines.

See also:
     *Note email:: Comprehensive email handling package; supercedes the
     `multifile' module.

* Menu:

* MultiFile Objects::
* MultiFile Example::


File: python-lib.info,  Node: MultiFile Objects,  Next: MultiFile Example,  Prev: multifile,  Up: multifile

MultiFile Objects
-----------------

A `MultiFile' instance has the following methods:

`readline(str)'
     Read a line.  If the line is data (not a section-divider or
     end-marker or real EOF) return it.  If the line matches the
     most-recently-stacked boundary, return `''' and set `self.last' to
     1 or 0 according as the match is or is not an end-marker.  If the
     line matches any other stacked boundary, raise an error.  On
     encountering end-of-file on the underlying stream object, the
     method raises `Error' unless all boundaries have been popped.

`readlines(str)'
     Return all lines remaining in this part as a list of strings.

`read()'
     Read all lines, up to the next section.  Return them as a single
     (multiline) string.  Note that this doesn't take a size argument!

`seek(pos[, whence])'
     Seek.  Seek indices are relative to the start of the current
     section.  The POS and WHENCE arguments are interpreted as for a
     file seek.

`tell()'
     Return the file position relative to the start of the current
     section.

`next()'
     Skip lines to the next section (that is, read lines until a
     section-divider or end-marker has been consumed).  Return true if
     there is such a section, false if an end-marker is seen.  Re-enable
     the most-recently-pushed boundary.

`is_data(str)'
     Return true if STR is data and false if it might be a section
     boundary.  As written, it tests for a prefix other than `'-'`-'' at
     start of line (which all MIME boundaries have) but it is declared
     so it can be overridden in derived classes.

     Note that this test is used intended as a fast guard for the real
     boundary tests; if it always returns false it will merely slow
     processing, not cause it to fail.

`push(str)'
     Push a boundary string.  When an appropriately decorated version of
     this boundary is found as an input line, it will be interpreted as
     a section-divider or end-marker.  All subsequent reads will return
     the empty string to indicate end-of-file, until a call to `pop()'
     removes the boundary a or `next()' call reenables it.

     It is possible to push more than one boundary.  Encountering the
     most-recently-pushed boundary will return EOF; encountering any
     other boundary will raise an error.

`pop()'
     Pop a section boundary.  This boundary will no longer be
     interpreted as EOF.

`section_divider(str)'
     Turn a boundary into a section-divider line.  By default, this
     method prepends `'-'`-'' (which MIME section boundaries have) but
     it is declared so it can be overridden in derived classes.  This
     method need not append LF or CR-LF, as comparison with the result
     ignores trailing whitespace.

`end_marker(str)'
     Turn a boundary string into an end-marker line.  By default, this
     method prepends `'-'`-'' and appends `'-'`-'' (like a
     MIME-multipart end-of-message marker) but it is declared so it can
     be overridden in derived classes.  This method need not append LF
     or CR-LF, as comparison with the result ignores trailing
     whitespace.

Finally, `MultiFile' instances have two public instance variables:

`level'
     Nesting depth of the current part.

`last'
     True if the last end-of-file was for an end-of-message marker.


File: python-lib.info,  Node: MultiFile Example,  Prev: MultiFile Objects,  Up: multifile

`MultiFile' Example
-------------------

     import mimetools
     import multifile
     import StringIO
     
     def extract_mime_part_matching(stream, mimetype):
         """Return the first element in a multipart MIME message on stream
         matching mimetype."""
     
         msg = mimetools.Message(stream)
         msgtype = msg.gettype()
         params = msg.getplist()
     
         data = StringIO.StringIO()
         if msgtype[:10] == "multipart/":
     
             file = multifile.MultiFile(stream)
             file.push(msg.getparam("boundary"))
             while file.next():
                 submsg = mimetools.Message(file)
                 try:
                     data = StringIO.StringIO()
                     mimetools.decode(file, data, submsg.getencoding())
                 except ValueError:
                     continue
                 if submsg.gettype() == mimetype:
                     break
             file.pop()
         return data.getvalue()


File: python-lib.info,  Node: rfc822,  Next: base64,  Prev: multifile,  Up: Internet Data Handling

Parse RFC 2822 mail headers
===========================

Parse RFC 2822 style mail messages.

_This is deprecated in Python 2.3.  The `email' package should be used
in preference to the `rfc822' module.  This module is present only to
maintain backward compatibility._

This module defines a class, `Message', which represents an "email
message" as defined by the Internet standard RFC 2822 .(1)  Such
messages consist of a collection of message headers, and a message
body.  This module also defines a helper class `AddressList' for
parsing RFC 2822 addresses.  Please refer to the RFC for information on
the specific syntax of RFC 2822 messages.

The `mailbox'  module provides classes to read mailboxes produced by
various end-user mail programs.

`Message(file[, seekable])'
     A `Message' instance is instantiated with an input object as
     parameter.  Message relies only on the input object having a
     `readline()' method; in particular, ordinary file objects qualify.
     Instantiation reads headers from the input object up to a
     delimiter line (normally a blank line) and stores them in the
     instance.  The message body, following the headers, is not
     consumed.

     This class can work with any input object that supports a
     `readline()' method.  If the input object has seek and tell
     capability, the `rewindbody()' method will work; also, illegal
     lines will be pushed back onto the input stream.  If the input
     object lacks seek but has an `unread()' method that can push back a
     line of input, `Message' will use that to push back illegal lines.
     Thus this class can be used to parse messages coming from a
     buffered stream.

     The optional SEEKABLE argument is provided as a workaround for
     certain stdio libraries in which `tell()' discards buffered data
     before discovering that the `lseek()' system call doesn't work.
     For maximum portability, you should set the seekable argument to
     zero to prevent that initial `tell()' when passing in an
     unseekable object such as a file object created from a socket
     object.

     Input lines as read from the file may either be terminated by
     CR-LF or by a single linefeed; a terminating CR-LF is replaced by
     a single linefeed before the line is stored.

     All header matching is done independent of upper or lower case;
     e.g. `M['From']', `M['from']' and `M['FROM']' all yield the same
     result.

`AddressList(field)'
     You may instantiate the `AddressList' helper class using a single
     string parameter, a comma-separated list of RFC 2822 addresses to
     be parsed.  (The parameter `None' yields an empty list.)

`quote(str)'
     Return a new string with backslashes in STR replaced by two
     backslashes and double quotes replaced by backslash-double quote.

`unquote(str)'
     Return a new string which is an _unquoted_ version of STR.  If STR
     ends and begins with double quotes, they are stripped off.
     Likewise if STR ends and begins with angle brackets, they are
     stripped off.

`parseaddr(address)'
     Parse ADDRESS, which should be the value of some
     address-containing field such as `To' or `Cc', into its
     constituent "realname" and "email address" parts.  Returns a tuple
     of that information, unless the parse fails, in which case a
     2-tuple `(None, None)' is returned.

`dump_address_pair(pair)'
     The inverse of `parseaddr()', this takes a 2-tuple of the form
     `(REALNAME, EMAIL_ADDRESS)' and returns the string value suitable
     for a `To' or `Cc' header.  If the first element of PAIR is false,
     then the second element is returned unmodified.

`parsedate(date)'
     Attempts to parse a date according to the rules in RFC 2822 .
     however, some mailers don't follow that format as specified, so
     `parsedate()' tries to guess correctly in such cases.  DATE is a
     string containing an RFC 2822 date, such as `'Mon, 20 Nov 1995
     19:12:08 -0500''.  If it succeeds in parsing the date,
     `parsedate()' returns a 9-tuple that can be passed directly to
     `time.mktime()'; otherwise `None' will be returned.  Note that
     fields 6, 7, and 8 of the result tuple are not usable.

`parsedate_tz(date)'
     Performs the same function as `parsedate()', but returns either
     `None' or a 10-tuple; the first 9 elements make up a tuple that
     can be passed directly to `time.mktime()', and the tenth is the
     offset of the date's timezone from UTC (which is the official term
     for Greenwich Mean Time).  (Note that the sign of the timezone
     offset is the opposite of the sign of the `time.timezone' variable
     for the same timezone; the latter variable follows the POSIX
     standard while this module follows RFC 2822 .)  If the input
     string has no timezone, the last element of the tuple returned is
     `None'.  Note that fields 6, 7, and 8 of the result tuple are not
     usable.

`mktime_tz(tuple)'
     Turn a 10-tuple as returned by `parsedate_tz()' into a UTC
     timestamp.  If the timezone item in the tuple is `None', assume
     local time.  Minor deficiency: this first interprets the first 8
     elements as a local time and then compensates for the timezone
     difference; this may yield a slight error around daylight savings
     time switch dates.  Not enough to worry about for common use.

See also:
     *Note email:: Comprehensive email handling package; supercedes the
     `rfc822' module.  *Note mailbox:: Classes to read various mailbox
     formats produced  by end-user mail programs.  *Note mimetools::
     Subclass of `rfc822.Message' that handles MIME encoded messages.

* Menu:

* Message Objects 2::
* AddressList Objects::

---------- Footnotes ----------

(1) This module originally conformed to RFC 822 , hence the name.
Since then, RFC 2822 has been released as an update to RFC 822 .  This
module should be considered RFC 2822 -conformant, especially in cases
where the syntax or semantics have changed since RFC 822 .


File: python-lib.info,  Node: Message Objects 2,  Next: AddressList Objects,  Prev: rfc822,  Up: rfc822

Message Objects
---------------

A `Message' instance has the following methods:

`rewindbody()'
     Seek to the start of the message body.  This only works if the file
     object is seekable.

`isheader(line)'
     Returns a line's canonicalized fieldname (the dictionary key that
     will be used to index it) if the line is a legal RFC 2822 header;
     otherwise returns `None' (implying that parsing should stop here
     and the line be pushed back on the input stream).  It is sometimes
     useful to override this method in a subclass.

`islast(line)'
     Return true if the given line is a delimiter on which Message
     should stop.  The delimiter line is consumed, and the file
     object's read location positioned immediately after it.  By
     default this method just checks that the line is blank, but you
     can override it in a subclass.

`iscomment(line)'
     Return `True' if the given line should be ignored entirely, just
     skipped.  By default this is a stub that always returns `False',
     but you can override it in a subclass.

`getallmatchingheaders(name)'
     Return a list of lines consisting of all headers matching NAME, if
     any.  Each physical line, whether it is a continuation line or
     not, is a separate list item.  Return the empty list if no header
     matches NAME.

`getfirstmatchingheader(name)'
     Return a list of lines comprising the first header matching NAME,
     and its continuation line(s), if any.  Return `None' if there is
     no header matching NAME.

`getrawheader(name)'
     Return a single string consisting of the text after the colon in
     the first header matching NAME.  This includes leading whitespace,
     the trailing linefeed, and internal linefeeds and whitespace if
     there any continuation line(s) were present.  Return `None' if
     there is no header matching NAME.

`getheader(name[, default])'
     Like `getrawheader(NAME)', but strip leading and trailing
     whitespace.  Internal whitespace is not stripped.  The optional
     DEFAULT argument can be used to specify a different default to be
     returned when there is no header matching NAME.

`get(name[, default])'
     An alias for `getheader()', to make the interface more compatible
     with regular dictionaries.

`getaddr(name)'
     Return a pair `(FULL NAME, EMAIL ADDRESS)' parsed from the string
     returned by `getheader(NAME)'.  If no header matching NAME exists,
     return `(None, None)'; otherwise both the full name and the
     address are (possibly empty) strings.

     Example: If M's first `From' header contains the string
     `'jack@cwi.nl (Jack Jansen)'', then `m.getaddr('From')' will yield
     the pair `('Jack Jansen', 'jack@cwi.nl')'.  If the header contained
     `'Jack Jansen <jack@cwi.nl>'' instead, it would yield the exact
     same result.

`getaddrlist(name)'
     This is similar to `getaddr(LIST)', but parses a header containing
     a list of email addresses (e.g. a `To' header) and returns a list
     of `(FULL NAME, EMAIL ADDRESS)' pairs (even if there was only one
     address in the header).  If there is no header matching NAME,
     return an empty list.

     If multiple headers exist that match the named header (e.g. if
     there are several `Cc' headers), all are parsed for addresses.
     Any continuation lines the named headers contain are also parsed.

`getdate(name)'
     Retrieve a header using `getheader()' and parse it into a 9-tuple
     compatible with `time.mktime()'; note that fields 6, 7, and 8 are
     not usable.  If there is no header matching NAME, or it is
     unparsable, return `None'.

     Date parsing appears to be a black art, and not all mailers adhere
     to the standard.  While it has been tested and found correct on a
     large collection of email from many sources, it is still possible
     that this function may occasionally yield an incorrect result.

`getdate_tz(name)'
     Retrieve a header using `getheader()' and parse it into a
     10-tuple; the first 9 elements will make a tuple compatible with
     `time.mktime()', and the 10th is a number giving the offset of the
     date's timezone from UTC.  Note that fields 6, 7, and 8 are not
     usable.  Similarly to `getdate()', if there is no header matching
     NAME, or it is unparsable, return `None'.

`Message' instances also support a limited mapping interface.  In
particular: `M[name]' is like `M.getheader(name)' but raises `KeyError'
if there is no matching header; and `len(M)', `M.get(NAME[, DEFAULT])',
`M.has_key(NAME)', `M.keys()', `M.values()' `M.items()', and
`M.setdefault(NAME[, DEFAULT])' act as expected, with the one
difference that `setdefault()' uses an empty string as the default
value.  `Message' instances also support the mapping writable interface
`M[name] = value' and `del M[name]'.  `Message' objects do not support
the `clear()', `copy()', `popitem()', or `update()' methods of the
mapping interface.  (Support for `get()' and `setdefault()' was only
added in Python 2.2.)

Finally, `Message' instances have some public instance variables:

`headers'
     A list containing the entire set of header lines, in the order in
     which they were read (except that setitem calls may disturb this
     order). Each line contains a trailing newline.  The blank line
     terminating the headers is not contained in the list.

`fp'
     The file or file-like object passed at instantiation time.  This
     can be used to read the message content.

`unixfrom'
     The UNIX `From~' line, if the message had one, or an empty string.
     This is needed to regenerate the message in some contexts, such
     as an `mbox'-style mailbox file.


File: python-lib.info,  Node: AddressList Objects,  Prev: Message Objects 2,  Up: rfc822

AddressList Objects
-------------------

An `AddressList' instance has the following methods:

`__len__()'
     Return the number of addresses in the address list.

`__str__()'
     Return a canonicalized string representation of the address list.
     Addresses are rendered in "name" <host@domain> form,
     comma-separated.

`__add__(alist)'
     Return a new `AddressList' instance that contains all addresses in
     both `AddressList' operands, with duplicates removed (set union).

`__iadd__(alist)'
     In-place version of `__add__()'; turns this `AddressList' instance
     into the union of itself and the right-hand instance, ALIST.

`__sub__(alist)'
     Return a new `AddressList' instance that contains every address in
     the left-hand `AddressList' operand that is not present in the
     right-hand address operand (set difference).

`__isub__(alist)'
     In-place version of `__sub__()', removing addresses in this list
     which are also in ALIST.

Finally, `AddressList' instances have one public instance variable:

`addresslist'
     A list of tuple string pairs, one per address.  In each member, the
     first is the canonicalized name part, the second is the actual
     route-address (`@'-separated username-host.domain pair).


File: python-lib.info,  Node: base64,  Next: binascii,  Prev: rfc822,  Up: Internet Data Handling

Encode and decode MIME base64 data
==================================

Encode and decode files using the MIME base64 data.

This module performs base64 encoding and decoding of arbitrary binary
strings into text strings that can be safely sent by email or included
as part of an HTTP POST request.  The encoding scheme is defined in RFC
1521 (_MIME (Multipurpose Internet Mail Extensions) Part One:
Mechanisms for Specifying and Describing the Format of Internet Message
Bodies_, section 5.2, "Base64 Content-Transfer-Encoding") and is used
for MIME email and various other Internet-related applications; it is
not the same as the output produced by the `uuencode' program.  For
example, the string `'www.python.org'' is encoded as the string
`'d3d3LnB5dGhvbi5vcmc=\n''.

`decode(input, output)'
     Decode the contents of the INPUT file and write the resulting
     binary data to the OUTPUT file.  INPUT and OUTPUT must either be
     file objects or objects that mimic the file object interface.
     INPUT will be read until `INPUT.read()' returns an empty string.

`decodestring(s)'
     Decode the string S, which must contain one or more lines of
     base64 encoded data, and return a string containing the resulting
     binary data.

`encode(input, output)'
     Encode the contents of the INPUT file and write the resulting
     base64 encoded data to the OUTPUT file.  INPUT and OUTPUT must
     either be file objects or objects that mimic the file object
     interface. INPUT will be read until `INPUT.read()' returns an
     empty string.  `encode()' returns the encoded data plus a trailing
     newline character (`'\n'').

`encodestring(s)'
     Encode the string S, which can contain arbitrary binary data, and
     return a string containing one or more lines of base64-encoded
     data.  `encodestring()' returns a string containing one or more
     lines of base64-encoded data always including an extra trailing
     newline (`'\n'').

See also:
     *Note binascii:: Support module containing ASCII-to-binary and
     binary-to-ASCII conversions.

    *RFC1521 MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies*
          Section 5.2, "Base64 Content-Transfer-Encoding," provides the
          definition of the base64 encoding.


File: python-lib.info,  Node: binascii,  Next: binhex,  Prev: base64,  Up: Internet Data Handling

Convert between binary and ASCII
================================

Tools for converting between binary and various ASCII-encoded binary
representations.

The `binascii' module contains a number of methods to convert between
binary and various ASCII-encoded binary representations. Normally, you
will not use these functions directly but use wrapper modules like `uu'
or `binhex'  instead, this module solely exists because
bit-manipulation of large amounts of data is slow in Python.

The `binascii' module defines the following functions:

`a2b_uu(string)'
     Convert a single line of uuencoded data back to binary and return
     the binary data. Lines normally contain 45 (binary) bytes, except
     for the last line. Line data may be followed by whitespace.

`b2a_uu(data)'
     Convert binary data to a line of ASCII characters, the return value
     is the converted line, including a newline char. The length of
     DATA should be at most 45.

`a2b_base64(string)'
     Convert a block of base64 data back to binary and return the
     binary data. More than one line may be passed at a time.

`b2a_base64(data)'
     Convert binary data to a line of ASCII characters in base64 coding.
     The return value is the converted line, including a newline char.
     The length of DATA should be at most 57 to adhere to the base64
     standard.

`a2b_qp(string[, header])'
     Convert a block of quoted-printable data back to binary and return
     the binary data. More than one line may be passed at a time.  If
     the optional argument HEADER is present and true, underscores will
     be decoded as spaces.

`b2a_qp(data[, quotetabs, istext, header])'
     Convert binary data to a line(s) of ASCII characters in
     quoted-printable encoding.  The return value is the converted
     line(s).  If the optional argument QUOTETABS is present and true,
     all tabs and spaces will be encoded.  If the optional argument
     HEADER is present and true, spaces will be encoded as underscores
     per RFC1522.  If the optional argument HEADER is present and
     false, newline characters will be encoded as well, otherwise
     linefeed conversion might corrupt the binary data stream.

`a2b_hqx(string)'
     Convert binhex4 formatted ASCII data to binary, without doing
     RLE-decompression. The string should contain a complete number of
     binary bytes, or (in case of the last portion of the binhex4 data)
     have the remaining bits zero.

`rledecode_hqx(data)'
     Perform RLE-decompression on the data, as per the binhex4
     standard. The algorithm uses `0x90' after a byte as a repeat
     indicator, followed by a count. A count of `0' specifies a byte
     value of `0x90'. The routine returns the decompressed data, unless
     data input data ends in an orphaned repeat indicator, in which
     case the `Incomplete' exception is raised.

`rlecode_hqx(data)'
     Perform binhex4 style RLE-compression on DATA and return the
     result.

`b2a_hqx(data)'
     Perform hexbin4 binary-to-ASCII translation and return the
     resulting string. The argument should already be RLE-coded, and
     have a length divisible by 3 (except possibly the last fragment).

`crc_hqx(data, crc)'
     Compute the binhex4 crc value of DATA, starting with an initial
     CRC and returning the result.

`crc32(data[, crc])'
     Compute CRC-32, the 32-bit checksum of data, starting with an
     initial crc.  This is consistent with the ZIP file checksum.
     Since the algorithm is designed for use as a checksum algorithm,
     it is not suitable for use as a general hash algorithm.  Use as
     follows:
              print binascii.crc32("hello world")
              # Or, in two pieces:
              crc = binascii.crc32("hello")
              crc = binascii.crc32(" world", crc)
              print crc

`b2a_hex(data)'

`hexlify data'
     Return the hexadecimal representation of the binary DATA.  Every
     byte of DATA is converted into the corresponding 2-digit hex
     representation.  The resulting string is therefore twice as long as
     the length of DATA.

`a2b_hex(hexstr)'

`unhexlify hexstr'
     Return the binary data represented by the hexadecimal string
     HEXSTR.  This function is the inverse of `b2a_hex()'.  HEXSTR must
     contain an even number of hexadecimal digits (which can be upper
     or lower case), otherwise a `TypeError' is raised.

`Error'
     Exception raised on errors. These are usually programming errors.

`Incomplete'
     Exception raised on incomplete data. These are usually not
     programming errors, but may be handled by reading a little more
     data and trying again.

See also:
     *Note base64:: Support for base64 encoding used in MIME email
     messages.

     *Note binhex:: Support for the binhex format used on the Macintosh.

     *Note uu:: Support for UU encoding used on UNIX.

     *Note quopri:: Support for quoted-printable encoding used in MIME
     email messages.


File: python-lib.info,  Node: binhex,  Next: quopri,  Prev: binascii,  Up: Internet Data Handling

Encode and decode binhex4 files
===============================

Encode and decode files in binhex4 format.

This module encodes and decodes files in binhex4 format, a format
allowing representation of Macintosh files in ASCII.  On the Macintosh,
both forks of a file and the finder information are encoded (or
decoded), on other platforms only the data fork is handled.

The `binhex' module defines the following functions:

`binhex(input, output)'
     Convert a binary file with filename INPUT to binhex file OUTPUT.
     The OUTPUT parameter can either be a filename or a file-like
     object (any object supporting a `write()' and `close()' method).

`hexbin(input[, output])'
     Decode a binhex file INPUT. INPUT may be a filename or a file-like
     object supporting `read()' and `close()' methods.  The resulting
     file is written to a file named OUTPUT, unless the argument is
     omitted in which case the output filename is read from the binhex
     file.

The following exception is also defined:

`Error'
     Exception raised when something can't be encoded using the binhex
     format (for example, a filename is too long to fit in the filename
     field), or when input is not properly encoded binhex data.

See also:
     *Note binascii:: Support module containing ASCII-to-binary and
     binary-to-ASCII conversions.

* Menu:

* Notes::


File: python-lib.info,  Node: Notes,  Prev: binhex,  Up: binhex

Notes
-----

There is an alternative, more powerful interface to the coder and
decoder, see the source for details.

If you code or decode textfiles on non-Macintosh platforms they will
still use the Macintosh newline convention (carriage-return as end of
line).

As of this writing, `hexbin()' appears to not work in all cases.


File: python-lib.info,  Node: quopri,  Next: uu,  Prev: binhex,  Up: Internet Data Handling

Encode and decode MIME quoted-printable data
============================================

Encode and decode files using the MIME quoted-printable encoding.

This module performs quoted-printable transport encoding and decoding,
as defined in RFC 1521 : "MIME (Multipurpose Internet Mail Extensions)
Part One: Mechanisms for Specifying and Describing the Format of
Internet Message Bodies".  The quoted-printable encoding is designed
for data where there are relatively few nonprintable characters; the
base64 encoding scheme available via the `base64' module is more
compact if there are many such characters, as when sending a graphics
file.

`decode(input, output[,header])'
     Decode the contents of the INPUT file and write the resulting
     decoded binary data to the OUTPUT file.  INPUT and OUTPUT must
     either be file objects or objects that mimic the file object
     interface. INPUT will be read until `INPUT.readline()' returns an
     empty string.  If the optional argument HEADER is present and
     true, underscore will be decoded as space. This is used to decode
     "Q"-encoded headers as described in RFC 1522 : "MIME (Multipurpose
     Internet Mail Extensions) Part Two: Message Header Extensions for
     Non-ASCII Text".

`encode(input, output, quotetabs)'
     Encode the contents of the INPUT file and write the resulting
     quoted-printable data to the OUTPUT file.  INPUT and OUTPUT must
     either be file objects or objects that mimic the file object
     interface. INPUT will be read until `INPUT.readline()' returns an
     empty string.  QUOTETABS is a flag which controls whether to
     encode embedded spaces and tabs; when true it encodes such
     embedded whitespace, and when false it leaves them unencoded.
     Note that spaces and tabs appearing at the end of lines are always
     encoded, as per RFC 1521 .

`decodestring(s[,header])'
     Like `decode()', except that it accepts a source string and
     returns the corresponding decoded string.

`encodestring(s[, quotetabs])'
     Like `encode()', except that it accepts a source string and
     returns the corresponding encoded string.  QUOTETABS is optional
     (defaulting to 0), and is passed straight through to `encode()'.

See also:
     *Note mimify:: General utilities for processing of MIME messages.
     *Note base64:: Encode and decode MIME base64 data


File: python-lib.info,  Node: uu,  Next: xdrlib,  Prev: quopri,  Up: Internet Data Handling

Encode and decode uuencode files
================================

Encode and decode files in uuencode format.

This module encodes and decodes files in uuencode format, allowing
arbitrary binary data to be transferred over ASCII-only connections.
Wherever a file argument is expected, the methods accept a file-like
object.  For backwards compatibility, a string containing a pathname is
also accepted, and the corresponding file will be opened for reading
and writing; the pathname `'-'' is understood to mean the standard
input or output.  However, this interface is deprecated; it's better
for the caller to open the file itself, and be sure that, when
required, the mode is `'rb'' or `'wb'' on Windows.

This code was contributed by Lance Ellinghouse, and modified by Jack
Jansen.

The `uu' module defines the following functions:

`encode(in_file, out_file[, name[, mode]])'
     Uuencode file IN_FILE into file OUT_FILE.  The uuencoded file will
     have the header specifying NAME and MODE as the defaults for the
     results of decoding the file. The default defaults are taken from
     IN_FILE, or `'-'' and `0666' respectively.

`decode(in_file[, out_file[, mode]])'
     This call decodes uuencoded file IN_FILE placing the result on
     file OUT_FILE. If OUT_FILE is a pathname, MODE is used to set the
     permission bits if the file must be created. Defaults for OUT_FILE
     and MODE are taken from the uuencode header.  However, if the file
     specified in the header already exists, a `uu.Error' is raised.

`Error()'
     Subclass of `Exception', this can be raised by `uu.decode()' under
     various situations, such as described above, but also including a
     badly formated header, or truncated input file.

See also:
     *Note binascii:: Support module containing ASCII-to-binary and
     binary-to-ASCII conversions.


File: python-lib.info,  Node: xdrlib,  Next: netrc,  Prev: uu,  Up: Internet Data Handling

Encode and decode XDR data
==========================

Encoders and decoders for the External Data Representation (XDR).

The `xdrlib' module supports the External Data Representation Standard
as described in RFC 1014 , written by Sun Microsystems, Inc. June 1987.
It supports most of the data types described in the RFC.

The `xdrlib' module defines two classes, one for packing variables into
XDR representation, and another for unpacking from XDR representation.
There are also two exception classes.

`Packer()'
     `Packer' is the class for packing data into XDR representation.
     The `Packer' class is instantiated with no arguments.

`Unpacker(data)'
     `Unpacker' is the complementary class which unpacks XDR data
     values from a string buffer.  The input buffer is given as DATA.

See also:
    *RFC1014 XDR: External Data Representation Standard*
          This RFC defined the encoding of data which was XDR at the
          time this module was originally written.  It has apparently
          been obsoleted by RFC 1832 .

    *RFC1832 XDR: External Data Representation Standard*
          Newer RFC that provides a revised definition of XDR.

* Menu:

* Packer Objects::
* Unpacker Objects::
* Exceptions::

