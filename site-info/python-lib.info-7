This is python-lib.info, produced by makeinfo version 4.3 from
python-lib.texi.

October 3, 2003


File: python-lib.info,  Node: Relationship to other Python modules,  Next: Data stream format,  Prev: pickle,  Up: pickle

Relationship to other Python modules
------------------------------------

The `pickle' module has an optimized cousin called the `cPickle'
module.  As its name implies, `cPickle' is written in C, so it can be
up to 1000 times faster than `pickle'.  However it does not support
subclassing of the `Pickler()' and `Unpickler()' classes, because in
`cPickle' these are functions, not classes.  Most applications have no
need for this functionality, and can benefit from the improved
performance of `cPickle'.  Other than that, the interfaces of the two
modules are nearly identical; the common interface is described in this
manual and differences are pointed out where necessary.  In the
following discussions, we use the term "pickle" to collectively
describe the `pickle' and `cPickle' modules.

The data streams the two modules produce are guaranteed to be
interchangeable.

Python has a more primitive serialization module called `marshal', but
in general `pickle' should always be the preferred way to serialize
Python objects.  `marshal' exists primarily to support Python's `.pyc'
files.

The `pickle' module differs from `marshal' several significant ways:

   * The `pickle' module keeps track of the objects it has already
     serialized, so that later references to the same object won't be
     serialized again.  `marshal' doesn't do this.

     This has implications both for recursive objects and object
     sharing.  Recursive objects are objects that contain references to
     themselves.  These are not handled by marshal, and in fact,
     attempting to marshal recursive objects will crash your Python
     interpreter.  Object sharing happens when there are multiple
     references to the same object in different places in the object
     hierarchy being serialized.  `pickle' stores such objects only
     once, and ensures that all other references point to the master
     copy.  Shared objects remain shared, which can be very important
     for mutable objects.

   * `marshal' cannot be used to serialize user-defined classes and
     their instances.  `pickle' can save and restore class instances
     transparently, however the class definition must be importable and
     live in the same module as when the object was stored.

   * The `marshal' serialization format is not guaranteed to be
     portable across Python versions.  Because its primary job in life
     is to support `.pyc' files, the Python implementers reserve the
     right to change the serialization format in non-backwards
     compatible ways should the need arise.  The `pickle' serialization
     format is guaranteed to be backwards compatible across Python
     releases.


_Notice:_ [warning] The `pickle' module is not intended to be secure
against erroneous or maliciously constructed data.  Never unpickle data
received from an untrusted or unauthenticated source.

Note that serialization is a more primitive notion than persistence;
although `pickle' reads and writes file objects, it does not handle the
issue of naming persistent objects, nor the (even more complicated)
issue of concurrent access to persistent objects.  The `pickle' module
can transform a complex object into a byte stream and it can transform
the byte stream into an object with the same internal structure.
Perhaps the most obvious thing to do with these byte streams is to
write them onto a file, but it is also conceivable to send them across
a network or store them in a database.  The module `shelve' provides a
simple interface to pickle and unpickle objects on DBM-style database
files.


File: python-lib.info,  Node: Data stream format,  Next: Usage,  Prev: Relationship to other Python modules,  Up: pickle

Data stream format
------------------

The data format used by `pickle' is Python-specific.  This has the
advantage that there are no restrictions imposed by external standards
such as XDR (which can't represent pointer sharing); however it means
that non-Python programs may not be able to reconstruct pickled Python
objects.

By default, the `pickle' data format uses a printable ASCII
representation.  This is slightly more voluminous than a binary
representation.  The big advantage of using printable ASCII (and of
some other characteristics of `pickle''s representation) is that for
debugging or recovery purposes it is possible for a human to read the
pickled file with a standard text editor.

There are currently 3 different protocols which can be used for
pickling.

   * Protocol version 0 is the original ASCII protocol and is backwards
     compatible with earlier versions of Python.

   * Protocol version 1 is the old binary format which is also
     compatible with earlier versions of Python.

   * Protocol version 2 was introduced in Python 2.3.  It provides much
     more efficient pickling of new-style classes.


Refer to PEP 307 for more information.

If a PROTOCOL is not specified, protocol 0 is used.  If PROTOCOL is
specified as a negative value or `HIGHEST_PROTOCOL', the highest
protocol version available will be used.

_Changed in Python version 2.3_

A binary format, which is slightly more efficient, can be chosen by
specifying a true value for the BIN argument to the `Pickler'
constructor or the `dump()' and `dumps()' functions.  A PROTOCOL
version >= 1 implies use of a binary format.


File: python-lib.info,  Node: Usage,  Next: What can be pickled and unpickled?,  Prev: Data stream format,  Up: pickle

Usage
-----

To serialize an object hierarchy, you first create a pickler, then you
call the pickler's `dump()' method.  To de-serialize a data stream, you
first create an unpickler, then you call the unpickler's `load()'
method.  The `pickle' module provides the following constant:

`HIGHEST_PROTOCOL'
     The highest protocol version available.  This value can be passed
     as a PROTOCOL value.  _Added in Python version 2.3_

The `pickle' module provides the following functions to make this
process more convenient:

`dump(object, file[, protocol[, bin]])'
     Write a pickled representation of OBJECT to the open file object
     FILE.  This is equivalent to `Pickler(FILE, PROTOCOL,
     BIN).dump(OBJECT)'.

     If the PROTOCOL parameter is ommitted, protocol 0 is used.  If
     PROTOCOL is specified as a negative value or `HIGHEST_PROTOCOL',
     the highest protocol version will be used.

     _Changed in Python version 2.3_

     If the optional BIN argument is true, the binary pickle format is
     used; otherwise the (less efficient) text pickle format is used
     (for backwards compatibility, this is the default).

     FILE must have a `write()' method that accepts a single string
     argument.  It can thus be a file object opened for writing, a
     `StringIO' object, or any other custom object that meets this
     interface.

`load(file)'
     Read a string from the open file object FILE and interpret it as a
     pickle data stream, reconstructing and returning the original
     object hierarchy.  This is equivalent to `Unpickler(FILE).load()'.

     FILE must have two methods, a `read()' method that takes an
     integer argument, and a `readline()' method that requires no
     arguments.  Both methods should return a string.  Thus FILE can be
     a file object opened for reading, a `StringIO' object, or any
     other custom object that meets this interface.

     This function automatically determines whether the data stream was
     written in binary mode or not.

`dumps(object[, protocol[, bin]])'
     Return the pickled representation of the object as a string,
     instead of writing it to a file.

     If the PROTOCOL parameter is ommitted, protocol 0 is used.  If
     PROTOCOL is specified as a negative value or `HIGHEST_PROTOCOL',
     the highest protocol version will be used.

     _Changed in Python version 2.3_

     If the optional BIN argument is true, the binary pickle format is
     used; otherwise the (less efficient) text pickle format is used
     (this is the default).

`loads(string)'
     Read a pickled object hierarchy from a string.  Characters in the
     string past the pickled object's representation are ignored.

The `pickle' module also defines three exceptions:

`PickleError'
     A common base class for the other exceptions defined below.  This
     inherits from `Exception'.

`PicklingError'
     This exception is raised when an unpicklable object is passed to
     the `dump()' method.

`UnpicklingError'
     This exception is raised when there is a problem unpickling an
     object.  Note that other exceptions may also be raised during
     unpickling, including (but not necessarily limited to)
     `AttributeError', `EOFError', `ImportError', and `IndexError'.

The `pickle' module also exports two callables,(1) `Pickler' and
`Unpickler':

`Pickler(file[, protocol[, bin]])'
     This takes a file-like object to which it will write a pickle data
     stream.

     If the PROTOCOL parameter is ommitted, protocol 0 is used.  If
     PROTOCOL is specified as a negative value, the highest protocol
     version will be used.

     _Changed in Python version 2.3_

     Optional BIN if true, tells the pickler to use the more efficient
     binary pickle format, otherwise the ASCII format is used (this is
     the default).

     FILE must have a `write()' method that accepts a single string
     argument.  It can thus be an open file object, a `StringIO'
     object, or any other custom object that meets this interface.

`Pickler' objects define one (or two) public methods:

`dump(object)'
     Write a pickled representation of OBJECT to the open file object
     given in the constructor.  Either the binary or ASCII format will
     be used, depending on the value of the BIN flag passed to the
     constructor.

`clear_memo()'
     Clears the pickler's "memo".  The memo is the data structure that
     remembers which objects the pickler has already seen, so that
     shared or recursive objects pickled by reference and not by value.
     This method is useful when re-using picklers.

     _Notice:_ Prior to Python 2.3, `clear_memo()' was only available
     on the picklers created by `cPickle'.  In the `pickle' module,
     picklers have an instance variable called `memo' which is a Python
     dictionary.  So to clear the memo for a `pickle' module pickler,
     you could do the following:

          mypickler.memo.clear()

     Code that does not need to support older versions of Python should
     simply use `clear_memo()'.

It is possible to make multiple calls to the `dump()' method of the
same `Pickler' instance.  These must then be matched to the same number
of calls to the `load()' method of the corresponding `Unpickler'
instance.  If the same object is pickled by multiple `dump()' calls,
the `load()' will all yield references to the same object(2).

`Unpickler' objects are defined as:

`Unpickler(file)'
     This takes a file-like object from which it will read a pickle data
     stream.  This class automatically determines whether the data
     stream was written in binary mode or not, so it does not need a
     flag as in the `Pickler' factory.

     FILE must have two methods, a `read()' method that takes an
     integer argument, and a `readline()' method that requires no
     arguments.  Both methods should return a string.  Thus FILE can be
     a file object opened for reading, a `StringIO' object, or any
     other custom object that meets this interface.

`Unpickler' objects have one (or two) public methods:

`load()'
     Read a pickled object representation from the open file object
     given in the constructor, and return the reconstituted object
     hierarchy specified therein.

`noload()'
     This is just like `load()' except that it doesn't actually create
     any objects.  This is useful primarily for finding what's called
     "persistent ids" that may be referenced in a pickle data stream.
     See section~*Note pickle protocol:: below for more details.

     *Note:* the `noload()' method is currently only available on
     `Unpickler' objects created with the `cPickle' module.  `pickle'
     module `Unpickler's do not have the `noload()' method.

---------- Footnotes ----------

(1) In the `pickle' module these callables are classes, which you could
subclass to customize the behavior.  However, in the `cPickle' module
these callables are factory functions and so cannot be subclassed.  One
common reason to subclass is to control what objects can actually be
unpickled.  See section~*Note Subclassing Unpicklers:: for more details.

(2) _Warning_: this is intended for pickling multiple objects without
intervening modifications to the objects or their parts.  If you modify
an object and then pickle it again using the same `Pickler' instance,
the object is not pickled again -- a reference to it is pickled and the
`Unpickler' will return the old value, not the modified one. There are
two problems here: (1) detecting changes, and (2) marshalling a minimal
set of changes.  Garbage Collection may also become a problem here.


File: python-lib.info,  Node: What can be pickled and unpickled?,  Next: pickle protocol,  Prev: Usage,  Up: pickle

What can be pickled and unpickled?
----------------------------------

The following types can be pickled:

   * `None', `True', and `False'

   * integers, long integers, floating point numbers, complex numbers

   * normal and Unicode strings

   * tuples, lists, and dictionaries containing only picklable objects

   * functions defined at the top level of a module

   * built-in functions defined at the top level of a module

   * classes that are defined at the top level of a module

   * instances of such classes whose `__dict__' or `__setstate__()' is
     picklable  (see section~*Note pickle protocol:: for details)


Attempts to pickle unpicklable objects will raise the `PicklingError'
exception; when this happens, an unspecified number of bytes may have
already been written to the underlying file.

Note that functions (built-in and user-defined) are pickled by "fully
qualified" name reference, not by value.  This means that only the
function name is pickled, along with the name of module the function is
defined in.  Neither the function's code, nor any of its function
attributes are pickled.  Thus the defining module must be importable in
the unpickling environment, and the module must contain the named
object, otherwise an exception will be raised(1).

Similarly, classes are pickled by named reference, so the same
restrictions in the unpickling environment apply.  Note that none of
the class's code or data is pickled, so in the following example the
class attribute `attr' is not restored in the unpickling environment:

     class Foo:
         attr = 'a class attr'
     
     picklestring = pickle.dumps(Foo)

These restrictions are why picklable functions and classes must be
defined in the top level of a module.

Similarly, when class instances are pickled, their class's code and
data are not pickled along with them.  Only the instance data are
pickled.  This is done on purpose, so you can fix bugs in a class or
add methods to the class and still load objects that were created with
an earlier version of the class.  If you plan to have long-lived
objects that will see many versions of a class, it may be worthwhile to
put a version number in the objects so that suitable conversions can be
made by the class's `__setstate__()' method.

---------- Footnotes ----------

(1) The exception raised will likely be an `ImportError' or an
`AttributeError' but it could be something else.


File: python-lib.info,  Node: pickle protocol,  Next: Subclassing Unpicklers,  Prev: What can be pickled and unpickled?,  Up: pickle

The pickle protocol
-------------------

This section describes the "pickling protocol" that defines the
interface between the pickler/unpickler and the objects that are being
serialized.  This protocol provides a standard way for you to define,
customize, and control how your objects are serialized and
de-serialized.  The description in this section doesn't cover specific
customizations that you can employ to make the unpickling environment
slightly safer from untrusted pickle data streams; see section~*Note
Subclassing Unpicklers:: for more details.

* Menu:

* Pickling and unpickling normal class instances::
* Pickling and unpickling extension types::
* Pickling and unpickling external objects::


File: python-lib.info,  Node: Pickling and unpickling normal class instances,  Next: Pickling and unpickling extension types,  Prev: pickle protocol,  Up: pickle protocol

Pickling and unpickling normal class instances
..............................................

When a pickled class instance is unpickled, its `__init__()' method is
normally _not_ invoked.  If it is desirable that the `__init__()'
method be called on unpickling, a class can define a method
`__getinitargs__()', which should return a _tuple_ containing the
arguments to be passed to the class constructor (i.e. `__init__()').
The `__getinitargs__()' method is called at pickle time; the tuple it
returns is incorporated in the pickle for the instance.

Classes can further influence how their instances are pickled; if the
class defines the method `__getstate__()', it is called and the return
state is pickled as the contents for the instance, instead of the
contents of the instance's dictionary.  If there is no `__getstate__()'
method, the instance's `__dict__' is pickled.

Upon unpickling, if the class also defines the method `__setstate__()',
it is called with the unpickled state(1).  If there is no
`__setstate__()' method, the pickled state must be a dictionary and its
items are assigned to the new instance's dictionary.  If a class
defines both `__getstate__()' and `__setstate__()', the state object
needn't be a dictionary and these methods can do what they want.(2)

_Notice:_ [warning] For new-style classes, if `__getstate__()' returns
a false value, the `__setstate__()' method will not be called.

---------- Footnotes ----------

(1) These methods can also be used to implement copying class instances.

(2) This protocol is also used by the shallow and deep copying
operations defined in the `copy' module.


File: python-lib.info,  Node: Pickling and unpickling extension types,  Next: Pickling and unpickling external objects,  Prev: Pickling and unpickling normal class instances,  Up: pickle protocol

Pickling and unpickling extension types
.......................................

When the `Pickler' encounters an object of a type it knows nothing
about -- such as an extension type -- it looks in two places for a hint
of how to pickle it.  One alternative is for the object to implement a
`__reduce__()' method.  If provided, at pickling time `__reduce__()'
will be called with no arguments, and it must return either a string or
a tuple.

If a string is returned, it names a global variable whose contents are
pickled as normal.  When a tuple is returned, it must be of length two
or three, with the following semantics:

   * A callable object, which in the unpickling environment must be
     either a class, a callable registered as a "safe constructor" (see
     below), or it must have an attribute `__safe_for_unpickling__'
     with a true value.  Otherwise, an `UnpicklingError' will be raised
     in the unpickling environment.  Note that as usual, the callable
     itself is pickled by name.

   * A tuple of arguments for the callable object, or `None'.  _This is
     deprecated in Python 2.3.  Use the tuple of arguments instead_

   * Optionally, the object's state, which will be passed to the
     object's `__setstate__()' method as described in section~*Note
     Pickling and unpickling external objects::.  If the object has no
     `__setstate__()' method, then, as above, the value must be a
     dictionary and it will be added to the object's `__dict__'.


Upon unpickling, the callable will be called (provided that it meets
the above criteria), passing in the tuple of arguments; it should
return the unpickled object.

If the second item was `None', then instead of calling the callable
directly, its `__basicnew__()' method is called without arguments.  It
should also return the unpickled object.

_This is deprecated in Python 2.3.  Use the tuple of arguments instead_

An alternative to implementing a `__reduce__()' method on the object to
be pickled, is to register the callable with the `copy_reg' module.
This module provides a way for programs to register "reduction
functions" and constructors for user-defined types.   Reduction
functions have the same semantics and interface as the `__reduce__()'
method described above, except that they are called with a single
argument, the object to be pickled.

The registered constructor is deemed a "safe constructor" for purposes
of unpickling as described above.


File: python-lib.info,  Node: Pickling and unpickling external objects,  Prev: Pickling and unpickling extension types,  Up: pickle protocol

Pickling and unpickling external objects
........................................

For the benefit of object persistence, the `pickle' module supports the
notion of a reference to an object outside the pickled data stream.
Such objects are referenced by a "persistent id", which is just an
arbitrary string of printable ASCII characters.  The resolution of such
names is not defined by the `pickle' module; it will delegate this
resolution to user defined functions on the pickler and unpickler(1).

To define external persistent id resolution, you need to set the
`persistent_id' attribute of the pickler object and the
`persistent_load' attribute of the unpickler object.

To pickle objects that have an external persistent id, the pickler must
have a custom `persistent_id()' method that takes an object as an
argument and returns either `None' or the persistent id for that
object.  When `None' is returned, the pickler simply pickles the object
as normal.  When a persistent id string is returned, the pickler will
pickle that string, along with a marker so that the unpickler will
recognize the string as a persistent id.

To unpickle external objects, the unpickler must have a custom
`persistent_load()' function that takes a persistent id string and
returns the referenced object.

Here's a silly example that _might_ shed more light:

     import pickle
     from cStringIO import StringIO
     
     src = StringIO()
     p = pickle.Pickler(src)
     
     def persistent_id(obj):
         if hasattr(obj, 'x'):
             return 'the value %d' % obj.x
         else:
             return None
     
     p.persistent_id = persistent_id
     
     class Integer:
         def __init__(self, x):
             self.x = x
         def __str__(self):
             return 'My name is integer %d' % self.x
     
     i = Integer(7)
     print i
     p.dump(i)
     
     datastream = src.getvalue()
     print repr(datastream)
     dst = StringIO(datastream)
     
     up = pickle.Unpickler(dst)
     
     class FancyInteger(Integer):
         def __str__(self):
             return 'I am the integer %d' % self.x
     
     def persistent_load(persid):
         if persid.startswith('the value '):
             value = int(persid.split()[2])
             return FancyInteger(value)
         else:
             raise pickle.UnpicklingError, 'Invalid persistent id'
     
     up.persistent_load = persistent_load
     
     j = up.load()
     print j

In the `cPickle' module, the unpickler's `persistent_load' attribute
can also be set to a Python list, in which case, when the unpickler
reaches a persistent id, the persistent id string will simply be
appended to this list.  This functionality exists so that a pickle data
stream can be "sniffed" for object references without actually
instantiating all the objects in a pickle(2).  Setting
`persistent_load' to a list is usually used in conjunction with the
`noload()' method on the Unpickler.

---------- Footnotes ----------

(1) The actual mechanism for associating these user defined functions
is slightly different for `pickle' and `cPickle'.  The description
given here works the same for both implementations.  Users of the
`pickle' module could also use subclassing to effect the same results,
overriding the `persistent_id()' and `persistent_load()' methods in the
derived classes.

(2) We'll leave you with the image of Guido and Jim sitting around
sniffing pickles in their living rooms.


File: python-lib.info,  Node: Subclassing Unpicklers,  Next: Example 3,  Prev: pickle protocol,  Up: pickle

Subclassing Unpicklers
----------------------

By default, unpickling will import any class that it finds in the
pickle data.  You can control exactly what gets unpickled and what gets
called by customizing your unpickler.  Unfortunately, exactly how you
do this is different depending on whether you're using `pickle' or
`cPickle'.(1).

In the `pickle' module, you need to derive a subclass from `Unpickler',
overriding the `load_global()' method.  `load_global()' should read two
lines from the pickle data stream where the first line will the name of
the module containing the class and the second line will be the name of
the instance's class.  It then looks up the class, possibly importing
the module and digging out the attribute, then it appends what it finds
to the unpickler's stack.  Later on, this class will be assigned to the
`__class__' attribute of an empty class, as a way of magically creating
an instance without calling its class's `__init__()'.  Your job (should
you choose to accept it), would be to have `load_global()' push onto
the unpickler's stack, a known safe version of any class you deem safe
to unpickle.  It is up to you to produce such a class.  Or you could
raise an error if you want to disallow all unpickling of instances.  If
this sounds like a hack, you're right.  Refer to the source code to
make this work.

Things are a little cleaner with `cPickle', but not by much.  To
control what gets unpickled, you can set the unpickler's `find_global'
attribute to a function or `None'.  If it is `None' then any attempts
to unpickle instances will raise an `UnpicklingError'.  If it is a
function, then it should accept a module name and a class name, and
return the corresponding class object.  It is responsible for looking
up the class and performing any necessary imports, and it may raise an
error to prevent instances of the class from being unpickled.

The moral of the story is that you should be really careful about the
source of the strings your application unpickles.

---------- Footnotes ----------

(1) A word of caution: the mechanisms described here use internal
attributes and methods, which are subject to change in future versions
of Python.  We intend to someday provide a common interface for
controlling this behavior, which will work in either `pickle' or
`cPickle'.


File: python-lib.info,  Node: Example 3,  Prev: Subclassing Unpicklers,  Up: pickle

Example
-------

Here's a simple example of how to modify pickling behavior for a class.
The `TextReader' class opens a text file, and returns the line number
and line contents each time its `readline()' method is called. If a
`TextReader' instance is pickled, all attributes _except_ the file
object member are saved. When the instance is unpickled, the file is
reopened, and reading resumes from the last location. The
`__setstate__()' and `__getstate__()' methods are used to implement
this behavior.

     class TextReader:
         """Print and number lines in a text file."""
         def __init__(self, file):
             self.file = file
             self.fh = open(file)
             self.lineno = 0
     
         def readline(self):
             self.lineno = self.lineno + 1
             line = self.fh.readline()
             if not line:
                 return None
             if line.endswith("\n"):
                 line = line[:-1]
             return "%d: %s" % (self.lineno, line)
     
         def __getstate__(self):
             odict = self.__dict__.copy() # copy the dict since we change it
             del odict['fh']              # remove filehandle entry
             return odict
     
         def __setstate__(self,dict):
             fh = open(dict['file'])      # reopen file
             count = dict['lineno']       # read from file...
             while count:                 # until line count is restored
                 fh.readline()
                 count = count - 1
             self.__dict__.update(dict)   # update attributes
             self.fh = fh                 # save the file object

A sample usage might be something like this:

     >>> import TextReader
     >>> obj = TextReader.TextReader("TextReader.py")
     >>> obj.readline()
     '1: #!/usr/local/bin/python'
     >>> # (more invocations of obj.readline() here)
     ... obj.readline()
     '7: class TextReader:'
     >>> import pickle
     >>> pickle.dump(obj,open('save.p','w'))

If you want to see that `pickle' works across Python processes, start
another Python session, before continuing.  What follows can happen
from either the same process or a new process.

     >>> import pickle
     >>> reader = pickle.load(open('save.p'))
     >>> reader.readline()
     '8:     "Print and number lines in a text file."'

See also:
     *Note copy_reg:: Pickle interface constructor registration for
     extension types.

     *Note shelve:: Indexed databases of objects; uses `pickle'.

     *Note copy:: Shallow and deep object copying.

     *Note marshal:: High-performance serialization of built-in types.


File: python-lib.info,  Node: cPickle,  Next: copy_reg,  Prev: pickle,  Up: Python Runtime Services

A faster `pickle'
=================

Faster version of `pickle', but not subclassable.

The `cPickle' module supports serialization and de-serialization of
Python objects, providing an interface and functionality nearly
identical to the `pickle'  module.  There are several differences, the
most important being performance and subclassability.

First, `cPickle' can be up to 1000 times faster than `pickle' because
the former is implemented in C.  Second, in the `cPickle' module the
callables `Pickler()' and `Unpickler()' are functions, not classes.
This means that you cannot use them to derive custom pickling and
unpickling subclasses.  Most applications have no need for this
functionality and should benefit from the greatly improved performance
of the `cPickle' module.

The pickle data stream produced by `pickle' and `cPickle' are
identical, so it is possible to use `pickle' and `cPickle'
interchangeably with existing pickles(1).

There are additional minor differences in API between `cPickle' and
`pickle', however for most applications, they are interchangable.  More
documentation is provided in the `pickle' module documentation, which
includes a list of the documented differences.

---------- Footnotes ----------

(1) Since the pickle data format is actually a tiny stack-oriented
programming language, and some freedom is taken in the encodings of
certain objects, it is possible that the two modules produce different
data streams for the same input objects.  However it is guaranteed that
they will always be able to read each other's data streams.


File: python-lib.info,  Node: copy_reg,  Next: shelve,  Prev: cPickle,  Up: Python Runtime Services

Register `pickle' support functions
===================================

Register `pickle' support functions.

The `copy_reg' module provides support for the `pickle'  and `cPickle'
modules.  The `copy'  module is likely to use this in the future as
well.  It provides configuration information about object constructors
which are not classes.  Such constructors may be factory functions or
class instances.

`constructor(object)'
     Declares OBJECT to be a valid constructor.  If OBJECT is not
     callable (and hence not valid as a constructor), raises
     `TypeError'.

`pickle(type, function[, constructor])'
     Declares that FUNCTION should be used as a "reduction" function
     for objects of type TYPE; TYPE must not be a "classic" class
     object.  (Classic classes are handled differently; see the
     documentation for the `pickle' module for details.)  FUNCTION
     should return either a string or a tuple containing two or three
     elements.

     The optional CONSTRUCTOR parameter, if provided, is a callable
     object which can be used to reconstruct the object when called
     with the tuple of arguments returned by FUNCTION at pickling time.
     `TypeError' will be raised if OBJECT is a class or CONSTRUCTOR is
     not callable.

     See the `pickle' module for more details on the interface expected
     of FUNCTION and CONSTRUCTOR.


File: python-lib.info,  Node: shelve,  Next: copy,  Prev: copy_reg,  Up: Python Runtime Services

Python object persistence
=========================

Python object persistence.

A "shelf" is a persistent, dictionary-like object.  The difference with
"dbm" databases is that the values (not the keys!) in a shelf can be
essentially arbitrary Python objects -- anything that the `pickle'
module can handle.  This includes most class instances, recursive data
types, and objects containing lots of shared sub-objects.  The keys are
ordinary strings.

`open(filename[,flag='c'[,protocol=`None'[,writeback=`False'[,binary=`None']]]])'
     Open a persistent dictionary.  The filename specified is the base
     filename for the underlying database.  As a side-effect, an
     extension may be added to the filename and more than one file may
     be created.  By default, the underlying database file is opened
     for reading and writing.  The optional {}FLAG pararameter has the
     same interpretation as the FLAG parameter of `anydbm.open'.

     By default, version 0 pickles are used to serialize values.  The
     version of the pickle protocol can be specified with the PROTOCOL
     parameter. _Changed in Python version 2.3_

     By default, mutations to persistent-dictionary mutable entries are
     not automatically written back.  If the optional WRITEBACK
     parameter is set to {}TRUE, all entries accessed are cached in
     memory, and written back at close time; this can make it handier
     to mutate mutable entries in the persistent dictionary, but, if
     many entries are accessed, it can consume vast amounts of memory
     for the cache, and it can make the close operation very slow since
     all accessed entries are written back (there is no way to
     determine which accessed entries are mutable, nor which ones were
     actually mutated).

Shelve objects support all methods supported by dictionaries.  This
eases the transition from dictionary based scripts to those requiring
persistent storage.

* Menu:

* Restrictions::
* Example 4::


File: python-lib.info,  Node: Restrictions,  Next: Example 4,  Prev: shelve,  Up: shelve

Restrictions
------------

   * The choice of which database package will be used (such as `dbm',
     `gdbm' or `bsddb') depends on which interface is available.
     Therefore it is not safe to open the database directly using
     `dbm'.  The database is also (unfortunately) subject to the
     limitations of `dbm', if it is used -- this means that (the
     pickled representation of) the objects stored in the database
     should be fairly small, and in rare cases key collisions may cause
     the database to refuse updates.

   * Depending on the implementation, closing a persistent dictionary
     may or may not be necessary to flush changes to disk.  The
     `__del__' method of the `Shelf' class calls the `close' method, so
     the programmer generally need not do this explicitly.

   * The `shelve' module does not support _concurrent_ read/write
     access to shelved objects.  (Multiple simultaneous read accesses
     are safe.)  When a program has a shelf open for writing, no other
     program should have it open for reading or writing.  UNIX file
     locking can be used to solve this, but this differs across UNIX
     versions and requires knowledge about the database implementation
     used.


`Shelf(dict[, protocol=None[, writeback=False[, binary=None]]])'
     A subclass of `UserDict.DictMixin' which stores pickled values in
     the DICT object.

     By default, version 0 pickles are used to serialize values.  The
     version of the pickle protocol can be specified with the PROTOCOL
     parameter. See the `pickle' documentation for a discussion of the
     pickle protocols. _Changed in Python version 2.3_

     If the WRITEBACK parameter is `True', the object will hold a cache
     of all entries accessed and write them back to the DICT at sync
     and close times.  This allows natural operations on mutable
     entries, but can consume much more memory and make sync and close
     take a long time.

`BsdDbShelf(dict[, protocol=None[, writeback=False[, binary=None]]])'
     A subclass of `Shelf' which exposes `first', `next', `previous',
     `last' and `set_location' which are available in the `bsddb' module
     but not in other database modules.  The DICT object passed to the
     constructor must support those methods.  This is generally
     accomplished by calling one of `bsddb.hashopen', `bsddb.btopen' or
     `bsddb.rnopen'.  The optional PROTOCOL, WRITEBACK, and BINARY
     parameters have the same interpretation as for the `Shelf' class.

`DbfilenameShelf(filename[, flag='c'[, protocol=None[, writeback=False[, binary=None]]]])'
     A subclass of `Shelf' which accepts a FILENAME instead of a
     dict-like object.  The underlying file will be opened using
     {}`anydbm.open'.  By default, the file will be created and opened
     for both read and write.  The optional FLAG parameter has the same
     interpretation as for the `open' function.  The optional PROTOCOL,
     WRITEBACK, and BINARY parameters have the same interpretation as
     for the `Shelf' class.


File: python-lib.info,  Node: Example 4,  Prev: Restrictions,  Up: shelve

Example
-------

To summarize the interface (`key' is a string, `data' is an arbitrary
object):

     import shelve
     
     d = shelve.open(filename) # open -- file may get suffix added by low-level
                               # library
     
     d[key] = data   # store data at key (overwrites old data if
                     # using an existing key)
     data = d[key]   # retrieve a COPY of data at key (raise KeyError if no
                     # such key)
     del d[key]      # delete data stored at key (raises KeyError
                     # if no such key)
     flag = d.has_key(key)   # true if the key exists
     list = d.keys() # a list of all existing keys (slow!)
     
     # as d was opened WITHOUT writeback=True, beware:
     d['xx'] = range(4)  # this works as expected, but...
     d['xx'].append(5)   # *this doesn't!* -- d['xx'] is STILL range(4)!!!
     # having opened d without writeback=True, you need to code carefully:
     temp = d['xx']      # extracts the copy
     temp.append(5)      # mutates the copy
     d['xx'] = temp      # stores the copy right back, to persist it
     # or, d=shelve.open(filename,writeback=True) would let you just code
     # d['xx'].append(5) and have it work as expected, BUT it would also
     # consume more memory and make the d.close() operation slower.
     
     d.close()       # close it

See also:
     *Note anydbm:: Generic interface to `dbm'-style databases.  *Note
     bsddb:: BSD `db' database interface.  *Note dbhash:: Thin layer
     around the `bsddb' which provides an `open' function like the
     other database modules.  *Note dbm:: Standard UNIX database
     interface.  *Note dumbdbm:: Portable implementation of the `dbm'
     interface.  *Note gdbm:: GNU database interface, based on the
     `dbm' interface.  *Note pickle:: Object serialization used by
     `shelve'.  *Note cPickle:: High-performance version of `pickle'.


File: python-lib.info,  Node: copy,  Next: marshal,  Prev: shelve,  Up: Python Runtime Services

Shallow and deep copy operations
================================

Shallow and deep copy operations.

This module provides generic (shallow and deep) copying operations.

Interface summary:

     import copy
     
     x = copy.copy(y)        # make a shallow copy of y
     x = copy.deepcopy(y)    # make a deep copy of y

For module specific errors, `copy.error' is raised.

The difference between shallow and deep copying is only relevant for
compound objects (objects that contain other objects, like lists or
class instances):

   * A _shallow copy_ constructs a new compound object and then (to the
     extent possible) inserts _references_ into it to the objects found
     in the original.

   * A _deep copy_ constructs a new compound object and then,
     recursively, inserts _copies_ into it of the objects found in the
     original.


Two problems often exist with deep copy operations that don't exist
with shallow copy operations:

   * Recursive objects (compound objects that, directly or indirectly,
     contain a reference to themselves) may cause a recursive loop.

   * Because deep copy copies _everything_ it may copy too much, e.g.,
     administrative data structures that should be shared even between
     copies.


The `deepcopy()' function avoids these problems by:

   * keeping a "memo" dictionary of objects already copied during the
     current copying pass; and

   * letting user-defined classes override the copying operation or the
     set of components copied.


This version does not copy types like module, class, function, method,
stack trace, stack frame, file, socket, window, array, or any similar
types.

Classes can use the same interfaces to control copying that they use to
control pickling: they can define methods called `__getinitargs__()',
`__getstate__()' and `__setstate__()'.  See the description of module
`pickle'  for information on these methods.  The `copy' module does not
use the `copy_reg' registration module.

In order for a class to define its own copy implementation, it can
define special methods `__copy__()' and `__deepcopy__()'.  The former
is called to implement the shallow copy operation; no additional
arguments are passed.  The latter is called to implement the deep copy
operation; it is passed one argument, the memo dictionary.  If the
`__deepcopy__()' implementation needs to make a deep copy of a
component, it should call the `deepcopy()' function with the component
as first argument and the memo dictionary as second argument.

See also:
     *Note pickle:: Discussion of the special methods used to support
     object state retrieval and restoration.


File: python-lib.info,  Node: marshal,  Next: warnings,  Prev: copy,  Up: Python Runtime Services

Internal Python object serialization
====================================

Convert Python objects to streams of bytes and back (with different
constraints).

This module contains functions that can read and write Python values in
a binary format.  The format is specific to Python, but independent of
machine architecture issues (e.g., you can write a Python value to a
file on a PC, transport the file to a Sun, and read it back there).
Details of the format are undocumented on purpose; it may change
between Python versions (although it rarely does).(1)

This is not a general "persistence" module.  For general persistence
and transfer of Python objects through RPC calls, see the modules
`pickle' and `shelve'.  The `marshal' module exists mainly to support
reading and writing the "pseudo-compiled" code for Python modules of
`.pyc' files.  Therefore, the Python maintainers reserve the right to
modify the marshal format in backward incompatible ways should the need
arise.  If you're serializing and de-serializing Python objects, use
the `pickle' module instead.

_Notice:_ [warning] The `marshal' module is not intended to be secure
against erroneous or maliciously constructed data.  Never unmarshal data
received from an untrusted or unauthenticated source.

Not all Python object types are supported; in general, only objects
whose value is independent from a particular invocation of Python can
be written and read by this module.  The following types are supported:
`None', integers, long integers, floating point numbers, strings,
Unicode objects, tuples, lists, dictionaries, and code objects, where
it should be understood that tuples, lists and dictionaries are only
supported as long as the values contained therein are themselves
supported; and recursive lists and dictionaries should not be written
(they will cause infinite loops).

*Caveat:* On machines where C's `long int' type has more than 32 bits
(such as the DEC Alpha), it is possible to create plain Python integers
that are longer than 32 bits.  If such an integer is marshaled and read
back in on a machine where C's `long int' type has only 32 bits, a
Python long integer object is returned instead.  While of a different
type, the numeric value is the same.  (This behavior is new in Python
2.2.  In earlier versions, all but the least-significant 32 bits of the
value were lost, and a warning message was printed.)

There are functions that read/write files as well as functions
operating on strings.

The module defines these functions:

`dump(value, file)'
     Write the value on the open file.  The value must be a supported
     type.  The file must be an open file object such as `sys.stdout'
     or returned by `open()' or `posix.popen()'.  It must be opened in
     binary mode (`'wb'' or `'w+b'').

     If the value has (or contains an object that has) an unsupported
     type, a `ValueError' exception is raised -- but garbage data will
     also be written to the file.  The object will not be properly read
     back by `load()'.

`load(file)'
     Read one value from the open file and return it.  If no valid value
     is read, raise `EOFError', `ValueError' or `TypeError'.  The file
     must be an open file object opened in binary mode (`'rb'' or
     `'r+b'').

     _If an object containing an unsupported type was marshalled with
     `dump()', `load()' will substitute `None' for the unmarshallable
     type._

`dumps(value)'
     Return the string that would be written to a file by `dump(VALUE,
     FILE)'.  The value must be a supported type.  Raise a `ValueError'
     exception if value has (or contains an object that has) an
     unsupported type.

`loads(string)'
     Convert the string to a value.  If no valid value is found, raise
     `EOFError', `ValueError' or `TypeError'.  Extra characters in the
     string are ignored.

---------- Footnotes ----------

(1) The name of this module stems from a bit of terminology used by the
designers of Modula-3 (amongst others), who use the term "marshalling"
for shipping of data around in a self-contained form. Strictly
speaking, "to marshal" means to convert some data from internal to
external form (in an RPC buffer for instance) and "unmarshalling" for
the reverse process.


File: python-lib.info,  Node: warnings,  Next: imp,  Prev: marshal,  Up: Python Runtime Services

Warning control
===============

Issue warning messages and control their disposition.

_Added in Python version 2.1_

Warning messages are typically issued in situations where it is useful
to alert the user of some condition in a program, where that condition
(normally) doesn't warrant raising an exception and terminating the
program.  For example, one might want to issue a warning when a program
uses an obsolete module.

Python programmers issue warnings by calling the `warn()' function
defined in this module.  (C programmers use `PyErr_Warn()'; see the
for details).

Warning messages are normally written to `sys.stderr', but their
disposition can be changed flexibly, from ignoring all warnings to
turning them into exceptions.  The disposition of warnings can vary
based on the warning category (see below), the text of the warning
message, and the source location where it is issued.  Repetitions of a
particular warning for the same source location are typically
suppressed.

There are two stages in warning control: first, each time a warning is
issued, a determination is made whether a message should be issued or
not; next, if a message is to be issued, it is formatted and printed
using a user-settable hook.

The determination whether to issue a warning message is controlled by
the warning filter, which is a sequence of matching rules and actions.
Rules can be added to the filter by calling `filterwarnings()' and
reset to its default state by calling `resetwarnings()'.

The printing of warning messages is done by calling `showwarning()',
which may be overidden; the default implementation of this function
formats the message by calling `formatwarning()', which is also
available for use by custom implementations.

* Menu:

* Warning Categories::
* Warnings Filter::
* Available Functions::

