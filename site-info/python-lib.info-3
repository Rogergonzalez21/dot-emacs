This is python-lib.info, produced by makeinfo version 4.3 from
python-lib.texi.

October 3, 2003


File: python-lib.info,  Node: Comparisons,  Next: Numeric Types,  Prev: Boolean Operations,  Up: Built-in Types

Comparisons
-----------

Comparison operations are supported by all objects.  They all have the
same priority (which is higher than that of the Boolean operations).
Comparisons can be chained arbitrarily; for example, `X < Y <= Z' is
equivalent to `X < Y and Y <= Z', except that Y is evaluated only once
(but in both cases Z is not evaluated at all when `X < Y' is found to
be false).

This table summarizes the comparison operations:

Operation                Meaning                  Notes
------                   -----                    -----
<                        strictly less than       
<=                       less than or equal       
>                        strictly greater than    
>=                       greater than or equal    
==                       equal                    
!=                       not equal                (1)
<>                       not equal                (1)
is                       object identity          
is not                   negated object identity  

Notes:

`(1)'
     `<>' and `!=' are alternate spellings for the same operator.  `!='
     is the preferred spelling; `<>' is obsolescent.

Objects of different types, except different numeric types and
different string types, never compare equal; such objects are ordered
consistently but arbitrarily (so that sorting a heterogeneous array
yields a consistent result).  Furthermore, some types (for example,
file objects) support only a degenerate notion of comparison where any
two objects of that type are unequal.  Again, such objects are ordered
arbitrarily but consistently. The `<', `<=', `>' and `>=' operators
will raise a `TypeError' exception when any operand is a complex number.

Instances of a class normally compare as non-equal unless the class
defines the `__cmp__()' method.  Refer to the  for information on the
use of this method to effect object comparisons.

*Implementation note:* Objects of different types except numbers are
ordered by their type names; objects of the same types that don't
support proper comparison are ordered by their address.

Two more operations with the same syntactic priority, `in'  and `not in'
, are supported only by sequence types (below).


File: python-lib.info,  Node: Numeric Types,  Next: Iterator Types,  Prev: Comparisons,  Up: Built-in Types

Numeric Types
-------------

There are four distinct numeric types: "plain integers", "long
integers", "floating point numbers", and "complex numbers".  In
addition, Booleans are a subtype of plain integers.  Plain integers
(also just called "integers") are implemented using `long' in C, which
gives them at least 32 bits of precision.  Long integers have unlimited
precision.  Floating point numbers are implemented using `double' in C.
All bets on their precision are off unless you happen to know the
machine you are working with.

Complex numbers have a real and imaginary part, which are each
implemented using `double' in C.  To extract these parts from a complex
number Z, use `Z.real' and `Z.imag'.

Numbers are created by numeric literals or as the result of built-in
functions and operators.  Unadorned integer literals (including hex and
octal numbers) yield plain integers unless the value they denote is too
large to be represented as a plain integer, in which case they yield a
long integer.  Integer literals with an `L' or `l' suffix yield long
integers (`L' is preferred because `1l' looks too much like eleven!).
Numeric literals containing a decimal point or an exponent sign yield
floating point numbers.  Appending `j' or `J' to a numeric literal
yields a complex number with a zero real part. A complex numeric
literal is the sum of a real and an imaginary part.

Python fully supports mixed arithmetic: when a binary arithmetic
operator has operands of different numeric types, the operand with the
"narrower" type is widened to that of the other, where plain integer is
narrower than long integer is narrower than floating point is narrower
than complex.  Comparisons between numbers of mixed type use the same
rule.(1) The constructors `int()', `long()', `float()', and `complex()'
can be used to produce numbers of a specific type.

All numeric types (except complex) support the following operations,
sorted by ascending priority (operations in the same box have the same
priority; all numeric operations have a higher priority than comparison
operations):

Operation                Result                   Notes
------                   -----                    -----
X + Y                    sum of X and Y           
X - Y                    difference of X and Y    
X * Y                    product of X and Y       
X / Y                    quotient of X and Y      (1)
X %{} Y                  remainder of `X / Y'     (4)
-X                       X negated                
+X                       X unchanged              
abs(X)                   absolute value or        
                         magnitude of X           
int(X)                   X converted to integer   (2)
long(X)                  X converted to long      (2)
                         integer                  
float(X)                 X converted to floating  
                         point                    
complex(RE,IM)           a complex number with    
                         real part RE, imaginary  
                         part IM.  IM defaults    
                         to zero.                 
C.conjugate()            conjugate of the         
                         complex number C         
divmod(X, Y)             the pair `(X / Y, X %{}  (3)(4)
                         Y)'                      
pow(X, Y)                X to the power Y         
X ** Y                   X to the power Y         

Notes:
`(1)'
     For (plain or long) integer division, the result is an integer.
     The result is always rounded towards minus infinity: 1/2 is 0,
     (-1)/2 is -1, 1/(-2) is -1, and (-1)/(-2) is 0.  Note that the
     result is a long integer if either operand is a long integer,
     regardless of the numeric value.

`(2)'
     Conversion from floating point to (long or plain) integer may
     round or truncate as in C; see functions `floor()' and `ceil()' in
     the `math'  module for well-defined conversions.

`(3)'
     See section *Note Built-in Functions::, "Built-in Functions," for
     a full description.

`(4)'
     Complex floor division operator, modulo operator, and `divmod()'.

     _This is deprecated in Python 2.3.  Instead convert to float using
     `abs()' if appropriate._

* Menu:

* Bit-string Operations::

---------- Footnotes ----------

(1)  As a consequence, the list `[1, 2]' is considered equal to `[1.0,
2.0]', and similarly for tuples.


File: python-lib.info,  Node: Bit-string Operations,  Prev: Numeric Types,  Up: Numeric Types

Bit-string Operations on Integer Types
......................................

Plain and long integer types support additional operations that make
sense only for bit-strings.  Negative numbers are treated as their 2's
complement value (for long integers, this assumes a sufficiently large
number of bits that no overflow occurs during the operation).

The priorities of the binary bit-wise operations are all lower than the
numeric operations and higher than the comparisons; the unary operation
`~' has the same priority as the other unary numeric operations (`+'
and `-').

This table lists the bit-string operations sorted in ascending priority
(operations in the same box have the same priority):

Operation                Result                   Notes
------                   -----                    -----
X | Y                    bitwise "or" of X and Y  
X ^{} Y                  bitwise "exclusive or"   
                         of X and Y               
X &{} Y                  bitwise "and" of X and   
                         Y                        
X << N                   X shifted left by N      (1), (2)
                         bits                     
X >> N                   X shifted right by N     (1), (3)
                         bits                     
~X                       the bits of X inverted   

Notes:
`(1)'
     Negative shift counts are illegal and cause a `ValueError' to be
     raised.

`(2)'
     A left shift by N bits is equivalent to multiplication by `pow(2,
     N)' without overflow check.

`(3)'
     A right shift by N bits is equivalent to division by `pow(2, N)'
     without overflow check.


File: python-lib.info,  Node: Iterator Types,  Next: Sequence Types,  Prev: Numeric Types,  Up: Built-in Types

Iterator Types
--------------

_Added in Python version 2.2_

Python supports a concept of iteration over containers.  This is
implemented using two distinct methods; these are used to allow
user-defined classes to support iteration.  Sequences, described below
in more detail, always support the iteration methods.

One method needs to be defined for container objects to provide
iteration support:

`__iter__()'
     Return an iterator object.  The object is required to support the
     iterator protocol described below.  If a container supports
     different types of iteration, additional methods can be provided to
     specifically request iterators for those iteration types.  (An
     example of an object supporting multiple forms of iteration would
     be a tree structure which supports both breadth-first and
     depth-first traversal.)  This method corresponds to the `tp_iter'
     slot of the type structure for Python objects in the Python/C API.

The iterator objects themselves are required to support the following
two methods, which together form the "iterator protocol":

`__iter__()'
     Return the iterator object itself.  This is required to allow both
     containers and iterators to be used with the `for' and `in'
     statements.  This method corresponds to the `tp_iter' slot of the
     type structure for Python objects in the Python/C API.

`next()'
     Return the next item from the container.  If there are no further
     items, raise the `StopIteration' exception.  This method
     corresponds to the `tp_iternext' slot of the type structure for
     Python objects in the Python/C API.

Python defines several iterator objects to support iteration over
general and specific sequence types, dictionaries, and other more
specialized forms.  The specific types are not important beyond their
implementation of the iterator protocol.

The intention of the protocol is that once an iterator's `next()'
method raises `StopIteration', it will continue to do so on subsequent
calls.  Implementations that do not obey this property are deemed
broken.  (This constraint was added in Python 2.3; in Python 2.2,
various iterators are broken according to this rule.)

Python's generators provide a convenient way to implement the iterator
protocol.  If a container object's `__iter__()' method is implemented
as a generator, it will automatically return an iterator object
(technically, a generator object) supplying the `__iter__()' and
`next()' methods.


File: python-lib.info,  Node: Sequence Types,  Next: Mapping Types,  Prev: Iterator Types,  Up: Built-in Types

Sequence Types
--------------

There are six sequence types: strings, Unicode strings, lists, tuples,
buffers, and xrange objects.

String literals are written in single or double quotes: `'xyzzy'',
`"frobozz"'.  See chapter 2 of the  for more about string literals.
Unicode strings are much like strings, but are specified in the syntax
using a preceeding `u' character: `u'abc'', `u"def"'.  Lists are
constructed with square brackets, separating items with commas: `[a, b,
c]'.  Tuples are constructed by the comma operator (not within square
brackets), with or without enclosing parentheses, but an empty tuple
must have the enclosing parentheses, such as `a, b, c' or `()'.  A
single item tuple must have a trailing comma, such as `(d,)'.

Buffer objects are not directly supported by Python syntax, but can be
created by calling the builtin function `buffer()'.    They don't
support concatenation or repetition.

Xrange objects are similar to buffers in that there is no specific
syntax to create them, but they are created using the `xrange()'
function.    They don't support slicing, concatenation or repetition,
and using `in', `not in', `min()' or `max()' on them is inefficient.

Most sequence types support the following operations.  The `in' and
`not in' operations have the same priorities as the comparison
operations.  The `+' and `*' operations have the same priority as the
corresponding numeric operations.(1)

This table lists the sequence operations sorted in ascending priority
(operations in the same box have the same priority).  In the table, S
and T are sequences of the same type; N, I and J are integers:

Operation                Result                   Notes
------                   -----                    -----
X in S                   `1' if an item of S is   (1)
                         equal to X, else `0'     
X not in S               `0' if an item of S is   (1)
                         equal to X, else `1'     
S + T                    the concatenation of S   
                         and T                    
S * N, N * S             N shallow copies of S    (2)
                         concatenated             
S[I]                     I'th item of S, origin   (3)
                         0                        
S[I:J]                   slice of S from I to J   (3), (4)
S[I:J:K]                 slice of S from I to J   (3), (5)
                         with step K              
len(S)                   length of S              
min(S)                   smallest item of S       
max(S)                   largest item of S        

Notes:

`(1)'
     When S is a string or Unicode string object the `in' and `not in'
     operations act like a substring test.  In Python versions before
     2.3, X had to be a string of length 1.  In Python 2.3 and beyond,
     X may be a string of any length.

`(2)'
     Values of N less than `0' are treated as `0' (which yields an
     empty sequence of the same type as S).  Note also that the copies
     are shallow; nested structures are not copied.  This often haunts
     new Python programmers; consider:

          >>> lists = [[]] * 3
          >>> lists
          [[], [], []]
          >>> lists[0].append(3)
          >>> lists
          [[3], [3], [3]]

     What has happened is that `lists' is a list containing three
     copies of the list `[[]]' (a one-element list containing an empty
     list), but the contained list is shared by each copy.  You can
     create a list of different lists this way:

          >>> lists = [[] for i in range(3)]
          >>> lists[0].append(3)
          >>> lists[1].append(5)
          >>> lists[2].append(7)
          >>> lists
          [[3], [5], [7]]

`(3)'
     If I or J is negative, the index is relative to the end of the
     string: `len(S) + I' or `len(S) + J' is substituted.  But note
     that `-0' is still `0'.

`(4)'
     The slice of S from I to J is defined as the sequence of items
     with index K such that `I <= K < J'.  If I or J is greater than
     `len(S)', use `len(S)'.  If I is omitted, use `0'.  If J is
     omitted, use `len(S)'.  If I is greater than or equal to J, the
     slice is empty.

`(5)'
     The slice of S from I to J with step K is defined as the sequence
     of items with index `X = I + N*K' such that `0' `<=' N `<'
     `abs(i-j)'.  If I or J is greater than `len(S)', use `len(S)'.  If
     I or J are omitted then they become "end" values (which end
     depends on the sign of K).  Note, K cannot be zero.

* Menu:

* String Methods::
* String Formatting Operations::
* XRange Type::
* Mutable Sequence Types::

---------- Footnotes ----------

(1) They must have since the parser can't tell the type of the operands.


File: python-lib.info,  Node: String Methods,  Next: String Formatting Operations,  Prev: Sequence Types,  Up: Sequence Types

String Methods
..............

These are the string methods which both 8-bit strings and Unicode
objects support:

`capitalize()'
     Return a copy of the string with only its first character
     capitalized.

`center(width)'
     Return centered in a string of length WIDTH. Padding is done using
     spaces.

`count(sub[, start[, end]])'
     Return the number of occurrences of substring SUB in string
     S`[START:END]'.  Optional arguments START and END are interpreted
     as in slice notation.

`decode([encoding[, errors]])'
     Decodes the string using the codec registered for ENCODING.
     ENCODING defaults to the default string encoding.  ERRORS may be
     given to set a different error handling scheme.  The default is
     `'strict'', meaning that encoding errors raise `ValueError'.
     Other possible values are `'ignore'' and `replace''.  _Added in
     Python version 2.2_

`encode([encoding[,errors]])'
     Return an encoded version of the string.  Default encoding is the
     current default string encoding.  ERRORS may be given to set a
     different error handling scheme.  The default for ERRORS is
     `'strict'', meaning that encoding errors raise a `ValueError'.
     Other possible values are `'ignore'' and `'replace''.  _Added in
     Python version 2.0_

`endswith(suffix[, start[, end]])'
     Return `True' if the string ends with the specified SUFFIX,
     otherwise return `False'.  With optional START, test beginning at
     that position.  With optional END, stop comparing at that position.

`expandtabs([tabsize])'
     Return a copy of the string where all tab characters are expanded
     using spaces.  If TABSIZE is not given, a tab size of `8'
     characters is assumed.

`find(sub[, start[, end]])'
     Return the lowest index in the string where substring SUB is
     found, such that SUB is contained in the range [START, END).
     Optional arguments START and END are interpreted as in slice
     notation.  Return `-1' if SUB is not found.

`index(sub[, start[, end]])'
     Like `find()', but raise `ValueError' when the substring is not
     found.

`isalnum()'
     Return true if all characters in the string are alphanumeric and
     there is at least one character, false otherwise.

`isalpha()'
     Return true if all characters in the string are alphabetic and
     there is at least one character, false otherwise.

`isdigit()'
     Return true if there are only digit characters, false otherwise.

`islower()'
     Return true if all cased characters in the string are lowercase and
     there is at least one cased character, false otherwise.

`isspace()'
     Return true if there are only whitespace characters in the string
     and the string is not empty, false otherwise.

`istitle()'
     Return true if the string is a titlecased string: uppercase
     characters may only follow uncased characters and lowercase
     characters only cased ones.  Return false otherwise.

`isupper()'
     Return true if all cased characters in the string are uppercase and
     there is at least one cased character, false otherwise.

`join(seq)'
     Return a string which is the concatenation of the strings in the
     sequence SEQ.  The separator between elements is the string
     providing this method.

`ljust(width)'
     Return the string left justified in a string of length WIDTH.
     Padding is done using spaces.  The original string is returned if
     WIDTH is less than `len(S)'.

`lower()'
     Return a copy of the string converted to lowercase.

`lstrip([chars])'
     Return a copy of the string with leading characters removed.  If
     CHARS is omitted or `None', whitespace characters are removed.  If
     given and not `None', CHARS must be a string; the characters in
     the string will be stripped from the beginning of the string this
     method is called on.  _Changed in Python version 2.2.2_

`replace(old, new[, maxsplit])'
     Return a copy of the string with all occurrences of substring OLD
     replaced by NEW.  If the optional argument MAXSPLIT is given, only
     the first MAXSPLIT occurrences are replaced.

`rfind(sub [,start [,end]])'
     Return the highest index in the string where substring SUB is
     found, such that SUB is contained within s[start,end].  Optional
     arguments START and END are interpreted as in slice notation.
     Return `-1' on failure.

`rindex(sub[, start[, end]])'
     Like `rfind()' but raises `ValueError' when the substring SUB is
     not found.

`rjust(width)'
     Return the string right justified in a string of length WIDTH.
     Padding is done using spaces.  The original string is returned if
     WIDTH is less than `len(S)'.

`rstrip([chars])'
     Return a copy of the string with trailing characters removed.  If
     CHARS is omitted or `None', whitespace characters are removed.  If
     given and not `None', CHARS must be a string; the characters in
     the string will be stripped from the end of the string this method
     is called on.  _Changed in Python version 2.2.2_

`split([sep [,maxsplit]])'
     Return a list of the words in the string, using SEP as the
     delimiter string.  If MAXSPLIT is given, at most MAXSPLIT splits
     are done.  If SEP is not specified or `None', any whitespace
     string is a separator.

`splitlines([keepends])'
     Return a list of the lines in the string, breaking at line
     boundaries.  Line breaks are not included in the resulting list
     unless KEEPENDS is given and true.

`startswith(prefix[, start[, end]])'
     Return `True' if string starts with the PREFIX, otherwise return
     `False'.  With optional START, test string beginning at that
     position.  With optional END, stop comparing string at that
     position.

`strip([chars])'
     Return a copy of the string with leading and trailing characters
     removed.  If CHARS is omitted or `None', whitespace characters are
     removed.  If given and not `None', CHARS must be a string; the
     characters in the string will be stripped from the both ends of
     the string this method is called on.  _Changed in Python version
     2.2.2_

`swapcase()'
     Return a copy of the string with uppercase characters converted to
     lowercase and vice versa.

`title()'
     Return a titlecased version of the string: words start with
     uppercase characters, all remaining cased characters are lowercase.

`translate(table[, deletechars])'
     Return a copy of the string where all characters occurring in the
     optional argument DELETECHARS are removed, and the remaining
     characters have been mapped through the given translation table,
     which must be a string of length 256.

     For Unicode objects, the `translate()' method does not accept the
     optional DELETECHARS argument.  Instead, it returns a copy of the
     S where all characters have been mapped through the given
     translation table which must be a mapping of Unicode ordinals to
     Unicode ordinals, Unicode strings or `None'.  Unmapped characters
     are left untouched. Characters mapped to `None' are deleted.
     Note, a more flexible approach is to create a custom character
     mapping codec using the `codecs' module (see `encodings.cp1251'
     for an example).

`upper()'
     Return a copy of the string converted to uppercase.

`zfill(width)'
     Return the numeric string left filled with zeros in a string of
     length WIDTH. The original string is returned if WIDTH is less
     than `len(S)'.  _Added in Python version 2.2.2_


File: python-lib.info,  Node: String Formatting Operations,  Next: XRange Type,  Prev: String Methods,  Up: Sequence Types

String Formatting Operations
............................

String and Unicode objects have one unique built-in operation: the `%'
operator (modulo).  This is also known as the string _formatting_ or
_interpolation_ operator.  Given `FORMAT % VALUES' (where FORMAT is a
string or Unicode object), `%' conversion specifications in FORMAT are
replaced with zero or more elements of VALUES.  The effect is similar
to the using `sprintf()' in the C language.  If FORMAT is a Unicode
object, or if any of the objects being converted using the `%s'
conversion are Unicode objects, the result will also be a Unicode
object.

If FORMAT requires a single argument, VALUES may be a single non-tuple
object. (1)  Otherwise, VALUES must be a tuple with exactly the number
of items specified by the format string, or a single mapping object
(for example, a dictionary).

A conversion specifier contains two or more characters and has the
following components, which must occur in this order:

  1. The `%' character, which marks the start of the specifier.

  2. Mapping key (optional), consisting of a parenthesised sequence of
     characters (for example, `(somename)').

  3. Conversion flags (optional), which affect the result of some
     conversion types.

  4. Minimum field width (optional).  If specified as an `*'
     (asterisk), the actual width is read from the next element of the
     tuple in VALUES, and the object to convert comes after the minimum
     field width and optional precision.

  5. Precision (optional), given as a `.' (dot) followed by the
     precision.  If specified as `*' (an asterisk), the actual width is
     read from the next element of the tuple in VALUES, and the value
     to convert comes after the precision.

  6. Length modifier (optional).

  7. Conversion type.

When the right argument is a dictionary (or other mapping type), then
the formats in the string _must_ include a parenthesised mapping key
into that dictionary inserted immediately after the `%' character. The
mapping key selects the value to be formatted from the mapping.  For
example:

     >>> print '%(language)s has %(#)03d quote types.' % \
               {'language': "Python", "#": 2}
     Python has 002 quote types.

In this case no `*' specifiers may occur in a format (since they
require a sequential parameter list).

The conversion flag characters are:

Flag                                 Meaning
------                               -----
#                                    The value conversion will use the
                                     "alternate form" (where defined
                                     below).
0                                    The conversion will be zero padded
                                     for numeric values.
-                                    The converted value is left
                                     adjusted (overrides the `0'
                                     conversion if both are given).
{~}                                  (a space) A blank should be left
                                     before a positive number (or empty
                                     string) produced by a signed
                                     conversion.
+                                    A sign character (`+' or `-') will
                                     precede the conversion (overrides a
                                     "space" flag).

The length modifier may be `h', `l', and `L' may be present, but are
ignored as they are not necessary for Python.

The conversion types are:

Conversion               Meaning                  Notes
------                   -----                    -----
d                        Signed integer decimal.  
i                        Signed integer decimal.  
o                        Unsigned octal.          (1)
u                        Unsigned decimal.        
x                        Unsigned hexidecimal     (2)
                         (lowercase).             
X                        Unsigned hexidecimal     (2)
                         (uppercase).             
e                        Floating point           
                         exponential format       
                         (lowercase).             
E                        Floating point           
                         exponential format       
                         (uppercase).             
f                        Floating point decimal   
                         format.                  
F                        Floating point decimal   
                         format.                  
g                        Same as `e' if exponent  
                         is greater than -4 or    
                         less than precision,     
                         `f' otherwise.           
G                        Same as `E' if exponent  
                         is greater than -4 or    
                         less than precision,     
                         `F' otherwise.           
c                        Single character         
                         (accepts integer or      
                         single character         
                         string).                 
r                        String (converts any     (3)
                         python object using      
                         `repr()').               
s                        String (converts any     (4)
                         python object using      
                         `str()').                
%                        No argument is           
                         converted, results in a  
                         `%' character in the     
                         result.                  

Notes:
`(1)'
     The alternate form causes a leading zero (`0') to be inserted
     between left-hand padding and the formatting of the number if the
     leading character of the result is not already a zero.

`(2)'
     The alternate form causes a leading `'0x'' or `'0X'' (depending on
     whether the `x' or `X' format was used) to be inserted between
     left-hand padding and the formatting of the number if the leading
     character of the result is not already a zero.

`(3)'
     The `%r' conversion was added in Python 2.0.

`(4)'
     If the object or format provided is a `unicode' string, the
     resulting string will also be `unicode'.

Since Python strings have an explicit length, `%s' conversions do not
assume that `'\0'' is the end of the string.

For safety reasons, floating point precisions are clipped to 50; `%f'
conversions for numbers whose absolute value is over 1e25 are replaced
by `%g' conversions.(2)  All other errors raise exceptions.

Additional string operations are defined in standard modules `string'
and `re'.

---------- Footnotes ----------

(1) To format only a tuple you should therefore provide a singleton
tuple whose only element is the tuple to be formatted.

(2)  These numbers are fairly arbitrary.  They are intended to avoid
printing endless strings of meaningless digits without hampering
correct use and without having to know the exact precision of floating
point values on a particular machine.


File: python-lib.info,  Node: XRange Type,  Next: Mutable Sequence Types,  Prev: String Formatting Operations,  Up: Sequence Types

XRange Type
...........

The xrange  type is an immutable sequence which is commonly used for
looping.  The advantage of the xrange type is that an xrange object
will always take the same amount of memory, no matter the size of the
range it represents.  There are no consistent performance advantages.

XRange objects have very little behavior: they only support indexing,
iteration, and the `len()' function.


File: python-lib.info,  Node: Mutable Sequence Types,  Prev: XRange Type,  Up: Sequence Types

Mutable Sequence Types
......................

List objects support additional operations that allow in-place
modification of the object.  Other mutable sequence types (when added
to the language) should also support these operations.  Strings and
tuples are immutable sequence types: such objects cannot be modified
once created.  The following operations are defined on mutable sequence
types (where X is an arbitrary object):

Operation                Result                   Notes
------                   -----                    -----
S[I] = X                 item I of S is replaced  
                         by X                     
S[I:J] = T               slice of S from I to J   
                         is replaced by T         
del S[I:J]               same as `S[I:J] = []'    
S[I:J:K] = T             the elements of          (1)
                         `S[I:J:K]' are replaced  
                         by those of T            
del S[I:J:K]             removes the elements of  
                         `S[I:J:K]' from the      
                         list                     
S.append(X)              same as                  (2)
                         `S[len(S):len(S)] =      
                         [X]'                     
S.extend(X)              same as                  (3)
                         `S[len(S):len(S)] = X'   
S.count(X)               return number of I's     
                         for which `S[I] == X'    
S.index(X[, I[, J]])     return smallest K such   (4)
                         that `S[K] == X' and `I  
                         <= K < J'                
S.insert(I, X)           same as `S[I:I] = [X]'   (5)
S.pop([I])               same as `X = S[I]; del   (6)
                         S[I]; return X'          
S.remove(X)              same as `del             (4)
                         S[S.index(X)]'           
S.reverse()              reverses the items of S  (7)
                         in place                 
S.sort([CMPFUNC=NONE])   sort the items of S in   (7), (8), (9), (10)
                         place                    

{types}

Notes:
`(1)'
     T must have the same length as the slice it is replacing.

`(2)'
     The C implementation of Python has historically accepted multiple
     parameters and implicitly joined them into a tuple; this no longer
     works in Python 2.0.  Use of this misfeature has been deprecated
     since Python 1.4.

`(3)'
     Raises an exception when X is not a list object.  The `extend()'
     method is experimental and not supported by mutable sequence types
     other than lists.

`(4)'
     Raises `ValueError' when X is not found in S. When a negative
     index is passed as the second or third parameter to the `index()'
     method, the list length is added, as for slice indices.  If it is
     still negative, it is truncated to zero, as for slice indices.
     _Changed in Python version 2.3_

`(5)'
     When a negative index is passed as the first parameter to the
     `insert()' method, the list length is added, as for slice indices.
     If it is still negative, it is truncated to zero, as for slice
     indices.  _Changed in Python version 2.3_

`(6)'
     The `pop()' method is only supported by the list and array types.
     The optional argument I defaults to `-1', so that by default the
     last item is removed and returned.

`(7)'
     The `sort()' and `reverse()' methods modify the list in place for
     economy of space when sorting or reversing a large list.  To
     remind you that they operate by side effect, they don't return the
     sorted or reversed list.

`(8)'
     The `sort()' method takes an optional argument specifying a
     comparison function of two arguments (list items) which should
     return a negative, zero or positive number depending on whether
     the first argument is considered smaller than, equal to, or larger
     than the second argument.  Note that this slows the sorting process
     down considerably; for example to sort a list in reverse order it
     is much faster to call `sort()' followed by `reverse()' than to
     use `sort()' with a comparison function that reverses the ordering
     of the elements.  Passing `None' as the comparison function is
     semantically equivalent to calling `sort()' with no comparison
     function.  _Changed in Python version 2.3_

     As an example of using the CMPFUNC argument to the `sort()'
     method, consider sorting a list of sequences by the second element
     of that list:

          def mycmp(a, b):
              return cmp(a[1], b[1])
          
          mylist.sort(mycmp)

     A more time-efficient approach for reasonably-sized data
     structures can often be used:

          tmplist = [(x[1], x) for x in mylist]
          tmplist.sort()
          mylist = [x for (key, x) in tmplist]

`(9)'
     Whether the `sort()' method is stable is not defined by the
     language (a sort is stable if it guarantees not to change the
     relative order of elements that compare equal).  In the C
     implementation of Python, sorts were stable only by accident
     through Python 2.2.  The C implementation of Python 2.3 introduced
     a stable `sort()' method, but code that intends to be portable
     across implementations and versions must not rely on stability.

`(10)'
     While a list is being sorted, the effect of attempting to mutate,
     or even inspect, the list is undefined.  The C implementation of
     Python 2.3 makes the list appear empty for the duration, and raises
     `ValueError' if it can detect that the list has been mutated
     during a sort.


File: python-lib.info,  Node: Mapping Types,  Next: File Objects,  Prev: Sequence Types,  Up: Built-in Types

Mapping Types
-------------

A "mapping" object maps  immutable values to arbitrary objects.
Mappings are mutable objects.  There is currently only one standard
mapping type, the "dictionary".  A dictionary's keys are almost
arbitrary values.  Only values containing lists, dictionaries or other
mutable types (that are compared by value rather than by object
identity) may not be used as keys.  Numeric types used for keys obey
the normal rules for numeric comparison: if two numbers compare equal
(such as `1' and `1.0') then they can be used interchangeably to index
the same dictionary entry.

Dictionaries are created by placing a comma-separated list of `KEY:
VALUE' pairs within braces, for example: `{'jack': 4098, 'sjoerd':
4127}' or `{4098: 'jack', 4127: 'sjoerd'}'.

The following operations are defined on mappings (where A and B are
mappings, K is a key, and V and X are arbitrary objects):

Operation                Result                   Notes
------                   -----                    -----
len(A)                   the number of items in   
                         A                        
A[K]                     the item of A with key   (1)
                         K                        
A[K] = V                 set `A[K]' to V          
del A[K]                 remove `A[K]' from A     (1)
A.clear()                remove all items from    
                         `a'                      
A.copy()                 a (shallow) copy of `a'  
A.has_key(K)             `True' if A has a key    
                         K, else `False'          
K `in' A                 Equivalent to            (2)
                         A.has_key(K)             
K not in A               Equivalent to `not'      (2)
                         A.has_key(K)             
A.items()                a copy of A's list of    (3)
                         (KEY, VALUE) pairs       
A.keys()                 a copy of A's list of    (3)
                         keys                     
A.update(B)              `for K in B.keys():      
                         A[K] = B[K]'             
A.fromkeys(SEQ[,         Creates a new            (7)
VALUE])                  dictionary with keys     
                         from SEQ and values set  
                         to VALUE                 
A.values()               a copy of A's list of    (3)
                         values                   
A.get(K[, X])            `A[K]' if `K in A',      (4)
                         else X                   
A.setdefault(K[, X])     `A[K]' if `K in A',      (5)
                         else X (also setting     
                         it)                      
A.pop(K[, X])            `A[K]' if `K in A',      (8)
                         else X (and remove k)    
A.popitem()              remove and return an     (6)
                         arbitrary (KEY, VALUE)   
                         pair                     
A.iteritems()            return an iterator over  (2), (3)
                         (KEY, VALUE) pairs       
A.iterkeys()             return an iterator over  (2), (3)
                         the mapping's keys       
A.itervalues()           return an iterator over  (2), (3)
                         the mapping's values     

Notes:
`(1)'
     Raises a `KeyError' exception if K is not in the map.

`(2)'
     _Added in Python version 2.2_

`(3)'
     Keys and values are listed in random order.  If `items()',
     `keys()', `values()', `iteritems()', `iterkeys()', and
     `itervalues()' are called with no intervening modifications to the
     dictionary, the lists will directly correspond.  This allows the
     creation of `(VALUE, KEY)' pairs using `zip()': `pairs =
     zip(A.values(), A.keys())'.  The same relationship holds for the
     `iterkeys()' and `itervalues()' methods: `pairs =
     zip(A.itervalues(), A.iterkeys())' provides the same value for
     `pairs'.  Another way to create the same list is `pairs = [(v, k)
     for (k, v) in A.iteritems()]'.

`(4)'
     Never raises an exception if K is not in the map, instead it
     returns X.  X is optional; when X is not provided and K is not in
     the map, `None' is returned.

`(5)'
     `setdefault()' is like `get()', except that if K is missing, X is
     both returned and inserted into the dictionary as the value of K.

`(6)'
     `popitem()' is useful to destructively iterate over a dictionary,
     as often used in set algorithms.

`(7)'
     `fromkeys()' is a class method that returns a new dictionary.
     VALUE defaults to `None'.  _Added in Python version 2.3_

`(8)'
     `pop()' raises a `KeyError' when no default value is given and the
     key is not found.  _Added in Python version 2.3_

