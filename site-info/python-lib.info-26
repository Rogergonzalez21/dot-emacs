This is python-lib.info, produced by makeinfo version 4.3 from
python-lib.texi.

October 3, 2003


File: python-lib.info,  Node: PyZipFile Objects,  Next: ZipInfo Objects,  Prev: ZipFile Objects,  Up: zipfile

PyZipFile Objects
-----------------

The `PyZipFile' constructor takes the same parameters as the `ZipFile'
constructor.  Instances have one method in addition to those of
`ZipFile' objects.

`writepy(pathname[, basename])'
     Search for files `*.py' and add the corresponding file to the
     archive.  The corresponding file is a `*.pyo' file if available,
     else a `*.pyc' file, compiling if necessary.  If the pathname is a
     file, the filename must end with `.py', and just the
     (corresponding `*.py[co]') file is added at the top level (no path
     information).  If it is a directory, and the directory is not a
     package directory, then all the files `*.py[co]' are added at the
     top level.  If the directory is a package directory, then all
     `*.py[oc]' are added under the package name as a file path, and if
     any subdirectories are package directories, all of these are added
     recursively.  BASENAME is intended for internal use only.  The
     `writepy()' method makes archives with file names like this:

              string.pyc                                # Top level name
              test/__init__.pyc                         # Package directory
              test/testall.pyc                          # Module test.testall
              test/bogus/__init__.pyc                   # Subpackage directory
              test/bogus/myfile.pyc                     # Submodule test.bogus.myfile


File: python-lib.info,  Node: ZipInfo Objects,  Prev: PyZipFile Objects,  Up: zipfile

ZipInfo Objects
---------------

Instances of the `ZipInfo' class are returned by the `getinfo()' and
`infolist()' methods of `ZipFile' objects.  Each object stores
information about a single member of the ZIP archive.

Instances have the following attributes:

`filename'
     Name of the file in the archive.

`date_time'
     The time and date of the last modification to the archive member.
     This is a tuple of six values:

     Index                              Value
     ------                             -----
     0                                  Year
     1                                  Month (one-based)
     2                                  Day of month (one-based)
     3                                  Hours (zero-based)
     4                                  Minutes (zero-based)
     5                                  Seconds (zero-based)

`compress_type'
     Type of compression for the archive member.

`comment'
     Comment for the individual archive member.

`extra'
     Expansion field data.  The  contains some comments on the internal
     structure of the data contained in this string.

`create_system'
     System which created ZIP archive.

`create_version'
     PKZIP version which created ZIP archive.

`extract_version'
     PKZIP version needed to extract archive.

`reserved'
     Must be zero.

`flag_bits'
     ZIP flag bits.

`volume'
     Volume number of file header.

`internal_attr'
     Internal attributes.

`external_attr'
     External file attributes.

`header_offset'
     Byte offset to the file header.

`file_offset'
     Byte offset to the start of the file data.

`CRC'
     CRC-32 of the uncompressed file.

`compress_size'
     Size of the compressed data.

`file_size'
     Size of the uncompressed file.


File: python-lib.info,  Node: tarfile,  Next: readline,  Prev: zipfile,  Up: Optional Operating System Services

Read and write tar archive files
================================

Read and write tar-format archive files.  _Added in Python version 2.3_

The `tarfile' module makes it possible to read and create tar archives.
Some facts and figures:

   * reads and writes `gzip' and `bzip2' compressed archives.

   * creates POSIX 1003.1-1990 compliant or GNU tar compatible archives.

   * reads GNU tar extensions _longname_, _longlink_ and _sparse_.

   * stores pathnames of unlimited length using GNU tar extensions.

   * handles directories, regular files, hardlinks, symbolic links,
     fifos, character devices and block devices and is able to acquire
     and restore file information like timestamp, access permissions
     and owner.

   * can handle tape devices.

`open([name[, mode [, fileobj[, bufsize]]]])'
     Return a `TarFile' object for the pathname NAME.  For detailed
     information on `TarFile' objects, see  (section *Note TarFile
     Objects::).

     MODE has to be a string of the form `'filemode[:compression]'', it
     defaults to `'r''. Here is a full list of mode combinations:

     mode                               action
     ------                             -----
     'r'                                Open for reading with transparent
                                        compression (recommended).
     'r:'                               Open for reading exclusively
                                        without compression.
     'r:gz'                             Open for reading with gzip
                                        compression.
     'r:bz2'                            Open for reading with bzip2
                                        compression.
     'a' or 'a:'                        Open for appending with no
                                        compression.
     'w' or 'w:'                        Open for uncompressed writing.
     'w:gz'                             Open for gzip compressed writing.
     'w:bz2'                            Open for bzip2 compressed writing.

     Note that `'a:gz'' or `'a:bz2'' is not possible.  If MODE is not
     suitable to open a certain (compressed) file for reading,
     `ReadError' is raised. Use MODE `'r'' to avoid this.  If a
     compression method is not supported, `CompressionError' is raised.

     If FILEOBJ is specified, it is used as an alternative to a file
     object opened for NAME.

     For special purposes, there is a second format for MODE:
     `'filemode|[compression]''.  `open' will return a `TarFile' object
     that processes its data as a stream of blocks. No random seeking
     will be done on the file. If given, FILEOBJ may be any object that
     has a `read()' resp. `write()' method.  BUFSIZE specifies the
     blocksize and defaults to `20 * 512' bytes. Use this variant in
     combination with e.g. `sys.stdin', a socket file object or a tape
     device.  However, such a `TarFile' object is limited in that it
     does not allow to be accessed randomly, see  (section *Note
     readline::).  The currently possible modes:

     mode                               action
     ------                             -----
     'r|'                               Open a _stream_ of uncompressed
                                        tar blocks for reading.
     'r|gz'                             Open a gzip compressed _stream_
                                        for reading.
     'r|bz2'                            Open a bzip2 compressed _stream_
                                        for reading.
     'w|'                               Open an uncompressed _stream_ for
                                        writing.
     'w|gz'                             Open an gzip compressed _stream_
                                        for writing.
     'w|bz2'                            Open an bzip2 compressed _stream_
                                        for writing.

`TarFile'
     Class for reading and writing tar archives. Do not use this class
     directly, better use `open()' instead.  See  (section *Note
     TarFile Objects::).

`is_tarfile(name)'
     Return `True' if NAME is a tar archive file, that the `tarfile'
     module can read.

`TarFileCompat(filename[, mode[, compression]])'
     Class for limited access to tar archives with a `zipfile'-like
     interface. Please consult the documentation of `zipfile' for more
     details.  `compression' must be one of the following constants:

    `TAR_PLAIN'
          Constant for an uncompressed tar archive.

    `TAR_GZIPPED'
          Constant for a `gzip' compressed tar archive.

`TarError'
     Base class for all `tarfile' exceptions.

`ReadError'
     Is raised when a tar archive is opened, that either cannot be
     handled by the `tarfile' module or is somehow invalid.

`CompressionError'
     Is raised when a compression method is not supported or when the
     data cannot be decoded properly.

`StreamError'
     Is raised for the limitations that are typical for stream-like
     `TarFile' objects.

`ExtractError'
     Is raised for _non-fatal_ errors when using `extract()', but only
     if `TarFile.errorlevel'` == 2'.

See also:
     *Note zipfile:: Documentation of the `zipfile' standard module.

     `GNU tar manual, Standard Section'{Documentation for tar archive
     files, including GNU tar extensions.}

* Menu:

* TarFile Objects::
* TarInfo Objects::
* Examples 6::


File: python-lib.info,  Node: TarFile Objects,  Next: TarInfo Objects,  Prev: tarfile,  Up: tarfile

TarFile Objects
---------------

The `TarFile' object provides an interface to a tar archive. A tar
archive is a sequence of blocks. An archive member (a stored file) is
made up of a header block followed by data blocks. It is possible, to
store a file in a tar archive several times. Each archive member is
represented by a `TarInfo' object, see  (section *Note TarInfo
Objects::) for details.

`TarFile([name [, mode[, fileobj]]])'
     Open an _(uncompressed)_ tar archive NAME.  MODE is either `'r''
     to read from an existing archive, `'a'' to append data to an
     existing file or `'w'' to create a new file overwriting an
     existing one. MODE defaults to `'r''.

     If FILEOBJ is given, it is used for reading or writing data.  If
     it can be determined, MODE is overridden by FILEOBJ's mode.
     _Notice:_ FILEOBJ is not closed, when `TarFile' is closed.

`open(...)'
     Alternative constructor. The `open()' function on module level is
     actually a shortcut to this classmethod. See section for details.

`getmember(name)'
     Return a `TarInfo' object for member NAME. If NAME can not be
     found in the archive, `KeyError' is raised.  _Notice:_ If a member
     occurs more than once in the archive, its last occurence is
     assumed to be the most up-to-date version.

`getmembers()'
     Return the members of the archive as a list of `TarInfo' objects.
     The list has the same order as the members in the archive.

`getnames()'
     Return the members as a list of their names. It has the same order
     as the list returned by `getmembers()'.

`list(verbose=True)'
     Print a table of contents to `sys.stdout'. If VERBOSE is `False',
     only the names of the members are printed. If it is `True', an
     `"ls -l"'-like output is produced.

`next()'
     Return the next member of the archive as a `TarInfo' object, when
     `TarFile' is opened for reading. Return `None' if there is no more
     available.

`extract(member[, path])'
     Extract a member from the archive to the current working directory,
     using its full name. Its file information is extracted as
     accurately as possible.  MEMBER may be a filename or a `TarInfo'
     object.  You can specify a different directory using PATH.

`extractfile(member)'
     Extract a member from the archive as a file object.  MEMBER may be
     a filename or a `TarInfo' object.  If MEMBER is a regular file, a
     file-like object is returned.  If MEMBER is a link, a file-like
     object is constructed from the link's target.  If MEMBER is none
     of the above, `None' is returned.  _Notice:_ The file-like object
     is read-only and provides the following methods: `read()',
     `readline()', `readlines()', `seek()', `tell()'.

`add(name[, arcname[, recursive=True]])'
     Add the file NAME to the archive. NAME may be any type of file
     (directory, fifo, symbolic link, etc.).  If given, ARCNAME
     specifies an alternative name for the file in the archive.
     Directories are added recursively by default.  This can be avoided
     by setting RECURSIVE to `False'.

`addfile(tarinfo[, fileobj])'
     Add the `TarInfo' object TARINFO to the archive.  If FILEOBJ is
     given, `tarinfo.size' bytes are read from it and added to the
     archive.  You can create `TarInfo' objects using `gettarinfo()'.
     _Notice:_ On Windows platforms, FILEOBJ should always be opened
     with mode `'rb'' to avoid irritation about the file size.

`gettarinfo([name[, arcname [, fileobj]]])'
     Create a `TarInfo' object for either the file NAME or the file
     object FILEOBJ (using `os.fstat()' on its file descriptor).  You
     can modify some of the `TarInfo''s attributes before you add it
     using `addfile()'.  If given, ARCNAME specifies an alternative
     name for the file in the archive.

`close()'
     Close the `TarFile'. In write-mode, two finishing zero blocks are
     appended to the archive.

`posix=True'
     If `True', create a POSIX 1003.1-1990 compliant archive. GNU
     extensions are not used, because they are not part of the POSIX
     standard.  This limits the length of filenames to at most 256 and
     linknames to 100 characters. A `ValueError' is raised, if a
     pathname exceeds this limit.  If `False', create a GNU tar
     compatible archive. It will not be POSIX compliant, but can store
     pathnames of unlimited length.

`dereference=False'
     If `False', add symbolic and hard links to archive. If `True', add
     the content of the target files to the archive. This has no effect
     on systems that do not support links.

`ignore_zeros=False'
     If `False', treat an empty block as the end of the archive. If
     `True', skip empty (and invalid) blocks and try to get as many
     members as possible. This is only useful for concatenated or
     damaged archives.

`debug=0'
     To be set from `0'(no debug messages) up to `3'(all debug
     messages). The messages are written to `sys.stdout'.

`errorlevel=0'
     If `0', all errors are ignored when using `extract()'.
     Nevertheless, they appear as error messages in the debug output,
     when debugging is enabled.  If `1', all _fatal_ errors are raised
     as `OSError' or `IOError' exceptions.  If `2', all _non-fatal_
     errors are raised as `TarError' exceptions as well.


File: python-lib.info,  Node: TarInfo Objects,  Next: Examples 6,  Prev: TarFile Objects,  Up: tarfile

TarInfo Objects
---------------

A `TarInfo' object represents one member in a `TarFile'. Aside from
storing all required attributes of a file (like file type, size, time,
permissions, owner etc.), it provides some useful methods to determine
its type. It does _not_ contain the file's data itself.

`TarInfo' objects are returned by `TarFile''s methods `getmember()',
`getmembers()' and `gettarinfo()'.

`TarInfo([name])'
     Create a `TarInfo' object.

`frombuf()'
     Create and return a `TarInfo' object from a string buffer.

`tobuf()'
     Create a string buffer from a `TarInfo' object.

A `TarInfo' object has the following public data attributes:

`name'
     Name of the archive member.

`size'
     Size in bytes.

`mtime'
     Time of last modification.

`mode'
     Permission bits.

`type'
     File type.  TYPE is usually one of these constants: `REGTYPE,
     AREGTYPE, LNKTYPE, SYMTYPE, DIRTYPE, FIFOTYPE, CONTTYPE, CHRTYPE,
     BLKTYPE, GNUTYPE_SPARSE'.  To determine the type of a `TarInfo'
     object more conveniently, use the `is_*()' methods below.

`linkname'
     Name of the target file name, which is only present in `TarInfo'
     objects of type LNKTYPE and SYMTYPE.

`uid, gid'
     User and group ID of who originally stored this member.

`uname, gname'
     User and group name.

A `TarInfo' object also provides some convenient query methods:

`isfile()'
     Return `True' if the `Tarinfo' object is a regular file.

`isreg()'
     Same as `isfile()'.

`isdir()'
     Return `True' if it is a directory.

`issym()'
     Return `True' if it is a symbolic link.

`islnk()'
     Return `True' if it is a hard link.

`ischr()'
     Return `True' if it is a character device.

`isblk()'
     Return `True' if it is a block device.

`isfifo()'
     Return `True' if it is a FIFO.

`isdev()'
     Return `True' if it is one of character device, block device or
     FIFO.


File: python-lib.info,  Node: Examples 6,  Prev: TarInfo Objects,  Up: tarfile

Examples
--------

How to create an uncompressed tar archive from a list of filenames:
     import tarfile
     tar = tarfile.open("sample.tar", "w")
     for name in ["foo", "bar", "quux"]:
         tar.add(name)
     tar.close()

How to read a gzip compressed tar archive and display some member
information:
     import tarfile
     tar = tarfile.open("sample.tar.gz", "r:gz")
     for tarinfo in tar:
         print tarinfo.name, "is", tarinfo.size, "bytes in size and is",
         if tarinfo.isreg():
             print "a regular file."
         elif tarinfo.isdir():
             print "a directory."
         else:
             print "something else."
     tar.close()

How to create a tar archive with faked information:
     import tarfile
     tar = tarfile.open("sample.tar.gz", "w:gz")
     for name in namelist:
         tarinfo = tar.gettarinfo(name, "fakeproj-1.0/" + name)
         tarinfo.uid = 123
         tarinfo.gid = 456
         tarinfo.uname = "johndoe"
         tarinfo.gname = "fake"
         tar.addfile(tarinfo, file(name))
     tar.close()

The _only_ way to extract an uncompressed tar stream from `sys.stdin':
     import sys
     import tarfile
     tar = tarfile.open(mode="r|", fileobj=sys.stdin)
     for tarinfo in tar:
         tar.extract(tarinfo)
     tar.close()


File: python-lib.info,  Node: readline,  Next: rlcompleter,  Prev: tarfile,  Up: Optional Operating System Services

GNU readline interface
======================

GNU readline support for Python.

The `readline' module defines a number of functions used either
directly or from the `rlcompleter' module to facilitate completion and
history file read and write from the Python interpreter.

The `readline' module defines the following functions:

`parse_and_bind(string)'
     Parse and execute single line of a readline init file.

`get_line_buffer()'
     Return the current contents of the line buffer.

`insert_text(string)'
     Insert text into the command line.

`read_init_file([filename])'
     Parse a readline initialization file.  The default filename is the
     last filename used.

`read_history_file([filename])'
     Load a readline history file.  The default filename is
     `~{}/.history'.

`write_history_file([filename])'
     Save a readline history file.  The default filename is
     `~{}/.history'.

`get_history_length()'
     Return the desired length of the history file.  Negative values
     imply unlimited history file size.

`set_history_length(length)'
     Set the number of lines to save in the history file.
     `write_history_file()' uses this value to truncate the history
     file when saving.  Negative values imply unlimited history file
     size.

`set_startup_hook([function])'
     Set or remove the startup_hook function.  If FUNCTION is specified,
     it will be used as the new startup_hook function; if omitted or
     `None', any hook function already installed is removed.  The
     startup_hook function is called with no arguments just before
     readline prints the first prompt.

`set_pre_input_hook([function])'
     Set or remove the pre_input_hook function.  If FUNCTION is
     specified, it will be used as the new pre_input_hook function; if
     omitted or `None', any hook function already installed is removed.
     The pre_input_hook function is called with no arguments after the
     first prompt has been printed and just before readline starts
     reading input characters.

`set_completer([function])'
     Set or remove the completer function.  If FUNCTION is specified,
     it will be used as the new completer function; if omitted or
     `None', any completer function already installed is removed.  The
     completer function is called as `FUNCTION(TEXT, STATE)', for STATE
     in `0', `1', `2', ..., until it returns a non-string value.  It
     should return the next possible completion starting with TEXT.

`get_completer()'
     Get the completer function, or `None' if no completer function has
     been set.  _Added in Python version 2.3_

`get_begidx()'
     Get the beginning index of the readline tab-completion scope.

`get_endidx()'
     Get the ending index of the readline tab-completion scope.

`set_completer_delims(string)'
     Set the readline word delimiters for tab-completion.

`get_completer_delims()'
     Get the readline word delimiters for tab-completion.

`add_history(line)'
     Append a line to the history buffer, as if it was the last line
     typed.

See also:
     *Note rlcompleter:: Completion of Python identifiers at the
     interactive prompt.

* Menu:

* Example 8::


File: python-lib.info,  Node: Example 8,  Prev: readline,  Up: readline

Example
-------

The following example demonstrates how to use the `readline' module's
history reading and writing functions to automatically load and save a
history file named `.pyhist' from the user's home directory.  The code
below would normally be executed automatically during interactive
sessions from the user's `PYTHONSTARTUP' file.

     import os
     histfile = os.path.join(os.environ["HOME"], ".pyhist")
     try:
         readline.read_history_file(histfile)
     except IOError:
         pass
     import atexit
     atexit.register(readline.write_history_file, histfile)
     del os, histfile


File: python-lib.info,  Node: rlcompleter,  Prev: readline,  Up: Optional Operating System Services

Completion function for GNU readline
====================================

Python identifier completion for the GNU readline library.

The `rlcompleter' module defines a completion function for the
`readline' module by completing valid Python identifiers and keywords.

This module is UNIX-specific due to its dependence on the `readline'
module.

The `rlcompleter' module defines the `Completer' class.

Example:

     >>> import rlcompleter
     >>> import readline
     >>> readline.parse_and_bind("tab: complete")
     >>> readline. <TAB PRESSED>
     readline.__doc__          readline.get_line_buffer  readline.read_init_file
     readline.__file__         readline.insert_text      readline.set_completer
     readline.__name__         readline.parse_and_bind
     >>> readline.

The `rlcompleter' module is designed for use with Python's interactive
mode.  A user can add the following lines to his or her initialization
file (identified by the `PYTHONSTARTUP' environment variable) to get
automatic <Tab> completion:

     try:
         import readline
     except ImportError:
         print "Module readline not available."
     else:
         import rlcompleter
         readline.parse_and_bind("tab: complete")

* Menu:

* Completer Objects::


File: python-lib.info,  Node: Completer Objects,  Prev: rlcompleter,  Up: rlcompleter

Completer Objects
-----------------

Completer objects have the following method:

`complete(text, state)'
     Return the STATEth completion for TEXT.

     If called for TEXT that doesn't include a period character (`.'),
     it will complete from names currently defined in `__main__',
     `__builtin__' and keywords (as defined by the `keyword' module).

     If called for a dotted name, it will try to evaluate anything
     without obvious side-effects (functions will not be evaluated, but
     it can generate calls to `__getattr__()') up to the last part, and
     find matches for the rest via the `dir()' function.


File: python-lib.info,  Node: Unix Specific Services,  Next: Python Debugger,  Prev: Optional Operating System Services,  Up: Top

Unix Specific Services
**********************

The modules described in this chapter provide interfaces to features
that are unique to the UNIX operating system, or in some cases to some
or many variants of it.  Here's an overview:

* Menu:

* posix::
* pwd::
* grp::
* crypt::
* dl::
* dbm::
* gdbm::
* termios::
* TERMIOS::
* tty::
* pty::
* fcntl::
* pipes::
* posixfile::
* resource::
* nis::
* syslog::
* commands::


File: python-lib.info,  Node: posix,  Next: pwd,  Prev: Unix Specific Services,  Up: Unix Specific Services

The most common POSIX system calls
==================================

The most common POSIX system calls (normally used via module `os').

This module provides access to operating system functionality that is
standardized by the C Standard and the POSIX standard (a thinly
disguised UNIX interface).

*Do not import this module directly.*  Instead, import the module `os',
which provides a _portable_ version of this interface.  On UNIX, the
`os' module provides a superset of the `posix' interface.  On non-UNIX
operating systems the `posix' module is not available, but a subset is
always available through the `os' interface.  Once `os' is imported,
there is _no_ performance penalty in using it instead of `posix'.  In
addition, `os' provides some additional functionality, such as
automatically calling `putenv()' when an entry in `os.environ' is
changed.

The descriptions below are very terse; refer to the corresponding UNIX
manual (or POSIX documentation) entry for more information.  Arguments
called PATH refer to a pathname given as a string.

Errors are reported as exceptions; the usual exceptions are given for
type errors, while errors reported by the system calls raise `error' (a
synonym for the standard exception `OSError'), described below.

* Menu:

* Large File Support::
* Module Contents 2::


File: python-lib.info,  Node: Large File Support,  Next: Module Contents 2,  Prev: posix,  Up: posix

Large File Support
------------------

Several operating systems (including AIX, HPUX, Irix and Solaris)
provide support for files that are larger than 2 Gb from a C
programming model where `int' and `long' are 32-bit values. This is
typically accomplished by defining the relevant size and offset types
as 64-bit values. Such files are sometimes referred to as "large files".

Large file support is enabled in Python when the size of an `off_t' is
larger than a `long' and the `long long' type is available and is at
least as large as an `off_t'. Python longs are then used to represent
file sizes, offsets and other values that can exceed the range of a
Python int. It may be necessary to configure and compile Python with
certain compiler flags to enable this mode. For example, it is enabled
by default with recent versions of Irix, but with Solaris 2.6 and 2.7
you need to do something like:

     CFLAGS="`getconf LFS_CFLAGS`" OPT="-g -O2 $CFLAGS" \
             ./configure

On large-file-capable Linux systems, this might work:

     CFLAGS='-D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64' OPT="-g -O2 $CFLAGS" \
             ./configure


File: python-lib.info,  Node: Module Contents 2,  Prev: Large File Support,  Up: posix

Module Contents
---------------

Module `posix' defines the following data item:

`environ'
     A dictionary representing the string environment at the time the
     interpreter was started. For example, `environ['HOME']' is the
     pathname of your home directory, equivalent to `getenv("HOME")' in
     C.

     Modifying this dictionary does not affect the string environment
     passed on by `execv()', `popen()' or `system()'; if you need to
     change the environment, pass `environ' to `execve()' or add
     variable assignments and export statements to the command string
     for `system()' or `popen()'.

     _Note:_ The `os' module provides an alternate implementation of
     `environ' which updates the environment on modification.  Note
     also that updating `os.environ' will render this dictionary
     obsolete.  Use of the `os' module version of this is recommended
     over direct access to the `posix' module.

Additional contents of this module should only be accessed via the `os'
module; refer to the documentation for that module for further
information.


File: python-lib.info,  Node: pwd,  Next: grp,  Prev: posix,  Up: Unix Specific Services

The password database
=====================

The password database (`getpwnam()' and friends).

This module provides access to the UNIX user account and password
database.  It is available on all UNIX versions.

Password database entries are reported as a tuple-like object, whose
attributes correspond to the members of the `passwd' structure
(Attribute field below, see `<pwd.h>'):

Index                    Attribute                Meaning
------                   -----                    -----
0                        `pw_name'                Login name
1                        `pw_passwd'              Optional encrypted
                                                  password
2                        `pw_uid'                 Numerical user ID
3                        `pw_gid'                 Numerical group ID
4                        `pw_gecos'               User name or comment
                                                  field
5                        `pw_dir'                 User home directory
6                        `pw_shell'               User command interpreter

The uid and gid items are integers, all others are strings.  `KeyError'
is raised if the entry asked for cannot be found.

_Note:_ In traditional UNIX the field `pw_passwd' usually contains a
password encrypted with a DES derived algorithm (see module `crypt' ).
However most modern unices  use a so-called _shadow password_ system.
On those unices the field `pw_passwd' only contains a asterisk (`'*'')
or the  letter `x' where the encrypted password is stored in a file
`/etc/shadow' which is not world readable.

It defines the following items:

`getpwuid(uid)'
     Return the password database entry for the given numeric user ID.

`getpwnam(name)'
     Return the password database entry for the given user name.

`getpwall()'
     Return a list of all available password database entries, in
     arbitrary order.

See also:
     *Note grp:: An interface to the group database, similar to this.


File: python-lib.info,  Node: grp,  Next: crypt,  Prev: pwd,  Up: Unix Specific Services

The group database
==================

The group database (`getgrnam()' and friends).

This module provides access to the UNIX group database.  It is
available on all UNIX versions.

Group database entries are reported as a tuple-like object, whose
attributes correspond to the members of the `group' structure
(Attribute field below, see `<pwd.h>'):

Index                    Attribute                Meaning
------                   -----                    -----
0                        gr_name                  the name of the group
1                        gr_passwd                the (encrypted) group
                                                  password; often empty
2                        gr_gid                   the numerical group ID
3                        gr_mem                   all the group member's
                                                  user  names

The gid is an integer, name and password are strings, and the member
list is a list of strings.  (Note that most users are not explicitly
listed as members of the group they are in according to the password
database.  Check both databases to get complete membership information.)

It defines the following items:

`getgrgid(gid)'
     Return the group database entry for the given numeric group ID.
     `KeyError' is raised if the entry asked for cannot be found.

`getgrnam(name)'
     Return the group database entry for the given group name.
     `KeyError' is raised if the entry asked for cannot be found.

`getgrall()'
     Return a list of all available group entries, in arbitrary order.

See also:
     *Note pwd:: An interface to the user database, similar to this.


File: python-lib.info,  Node: crypt,  Next: dl,  Prev: grp,  Up: Unix Specific Services

Function to check UNIX passwords
================================

The `crypt()' function used to check UNIX passwords.

This module implements an interface to the `crypt(3)'  routine, which
is a one-way hash function based upon a modified DES  algorithm; see
the UNIX man page for further details.  Possible uses include allowing
Python scripts to accept typed passwords from the user, or attempting
to crack UNIX passwords with a dictionary.

`crypt(word, salt)'
     WORD will usually be a user's password as typed at a prompt or in
     a graphical interface.  SALT is usually a random two-character
     string which will be used to perturb the DES algorithm in one of
     4096 ways.  The characters in SALT must be in the set
     "[./a-zA-Z0-9]".  Returns the hashed password as a string, which
     will be composed of characters from the same alphabet as the salt
     (the first two characters represent the salt itself).

A simple example illustrating typical use:

     import crypt, getpass, pwd
     
     def login():
         username = raw_input('Python login:')
         cryptedpasswd = pwd.getpwnam(username)[1]
         if cryptedpasswd:
             if cryptedpasswd == 'x' or cryptedpasswd == '*':
                 raise "Sorry, currently no support for shadow passwords"
             cleartext = getpass.getpass()
             return crypt.crypt(cleartext, cryptedpasswd[:2]) == cryptedpasswd
         else:
             return 1


File: python-lib.info,  Node: dl,  Next: dbm,  Prev: crypt,  Up: Unix Specific Services

Call C functions in shared objects
==================================

Call C functions in shared objects.

The `dl' module defines an interface to the `dlopen()' function, which
is the most common interface on UNIX platforms for handling dynamically
linked libraries. It allows the program to call arbitrary functions in
such a library.

_Note:_ This module will not work unless `sizeof(int) == sizeof(long)
== sizeof(char *)' If this is not the case, `SystemError' will be
raised on import.

The `dl' module defines the following function:

`open(name[, mode` = RTLD_LAZY'])'
     Open a shared object file, and return a handle. Mode signifies
     late binding (`RTLD_LAZY') or immediate binding (`RTLD_NOW').
     Default is `RTLD_LAZY'. Note that some systems do not support
     `RTLD_NOW'.

     Return value is a `dlobject'.

The `dl' module defines the following constants:

`RTLD_LAZY'
     Useful as an argument to `open()'.

`RTLD_NOW'
     Useful as an argument to `open()'.  Note that on systems which do
     not support immediate binding, this constant will not appear in
     the module. For maximum portability, use `hasattr()' to determine
     if the system supports immediate binding.

The `dl' module defines the following exception:

`error'
     Exception raised when an error has occurred inside the dynamic
     loading and linking routines.

Example:

     >>> import dl, time
     >>> a=dl.open('/lib/libc.so.6')
     >>> a.call('time'), time.time()
     (929723914, 929723914.498)

This example was tried on a Debian GNU/Linux system, and is a good
example of the fact that using this module is usually a bad alternative.

* Menu:

* Dl Objects::


File: python-lib.info,  Node: Dl Objects,  Prev: dl,  Up: dl

Dl Objects
----------

Dl objects, as returned by `open()' above, have the following methods:

`close()'
     Free all resources, except the memory.

`sym(name)'
     Return the pointer for the function named NAME, as a number, if it
     exists in the referenced shared object, otherwise `None'. This is
     useful in code like:

          >>> if a.sym('time'):
          ...     a.call('time')
          ... else:
          ...     time.time()

     (Note that this function will return a non-zero number, as zero is
     the `NULL' pointer)

`call(name[, arg1[, arg2...]])'
     Call the function named NAME in the referenced shared object.  The
     arguments must be either Python integers, which will be passed as
     is, Python strings, to which a pointer will be passed, or `None',
     which will be passed as `NULL'.  Note that strings should only be
     passed to functions as `const char*', as Python will not like its
     string mutated.

     There must be at most 10 arguments, and arguments not given will be
     treated as `None'. The function's return value must be a C `long',
     which is a Python integer.


File: python-lib.info,  Node: dbm,  Next: gdbm,  Prev: dl,  Up: Unix Specific Services

Simple "database" interface
===========================

The standard "database" interface, based on ndbm.

The `dbm' module provides an interface to the UNIX (`n')`dbm' library.
Dbm objects behave like mappings (dictionaries), except that keys and
values are always strings.  Printing a dbm object doesn't print the
keys and values, and the `items()' and `values()' methods are not
supported.

This module can be used with the "classic" ndbm interface, the BSD DB
compatibility interface, or the GNU GDBM compatibility interface.  On
UNIX, the `configure' script will attempt to locate the appropriate
header file to simplify building this module.

The module defines the following:

`error'
     Raised on dbm-specific errors, such as I/O errors.  `KeyError' is
     raised for general mapping errors like specifying an incorrect key.

`library'
     Name of the `ndbm' implementation library used.

`open(filename[, flag[, mode]])'
     Open a dbm database and return a dbm object.  The FILENAME
     argument is the name of the database file (without the `.dir' or
     `.pag' extensions; note that the BSD DB implementation of the
     interface will append the extension `.db' and only create one
     file).

     The optional FLAG argument must be one of these values:

     Value                              Meaning
     ------                             -----
     'r'                                Open existing database for
                                        reading only (default)
     'w'                                Open existing database for
                                        reading and writing
     'c'                                Open database for reading and
                                        writing, creating it if it
                                        doesn't exist
     'n'                                Always create a new, empty
                                        database, open for reading and
                                        writing

     The optional MODE argument is the UNIX mode of the file, used only
     when the database has to be created.  It defaults to octal `0666'.

See also:
     *Note anydbm:: Generic interface to `dbm'-style databases.  *Note
     gdbm:: Similar interface to the GNU GDBM library.  *Note whichdb::
     Utility module used to determine the type of an existing database.


File: python-lib.info,  Node: gdbm,  Next: termios,  Prev: dbm,  Up: Unix Specific Services

GNU's reinterpretation of dbm
=============================

GNU's reinterpretation of dbm.

This module is quite similar to the `dbm' module, but uses `gdbm'
instead to provide some additional functionality.  Please note that the
file formats created by `gdbm' and `dbm' are incompatible.

The `gdbm' module provides an interface to the GNU DBM library.  `gdbm'
objects behave like mappings (dictionaries), except that keys and
values are always strings.  Printing a `gdbm' object doesn't print the
keys and values, and the `items()' and `values()' methods are not
supported.

The module defines the following constant and functions:

`error'
     Raised on `gdbm'-specific errors, such as I/O errors.  `KeyError'
     is raised for general mapping errors like specifying an incorrect
     key.

`open(filename, [flag, [mode]])'
     Open a `gdbm' database and return a `gdbm' object.  The FILENAME
     argument is the name of the database file.

     The optional FLAG argument can be `'r'' (to open an existing
     database for reading only -- default), `'w'' (to open an existing
     database for reading and writing), `'c'' (which creates the
     database if it doesn't exist), or `'n'' (which always creates a
     new empty database).

     The following additional characters may be appended to the flag to
     control how the database is opened:

        * `'f'' -- Open the database in fast mode.  Writes to the
          database will not be syncronized.

        * `'s'' -- Synchronized mode. This will cause changes to the
          database will be immediately written to the file.

        * `'u'' -- Do not lock database.

     Not all flags are valid for all versions of `gdbm'.  The module
     constant `open_flags' is a string of supported flag characters.
     The exception `error' is raised if an invalid flag is specified.

     The optional MODE argument is the UNIX mode of the file, used only
     when the database has to be created.  It defaults to octal `0666'.

In addition to the dictionary-like methods, `gdbm' objects have the
following methods:

`firstkey()'
     It's possible to loop over every key in the database using this
     method and the `nextkey()' method.  The traversal is ordered by
     `gdbm''s internal hash values, and won't be sorted by the key
     values.  This method returns the starting key.

`nextkey(key)'
     Returns the key that follows KEY in the traversal.  The following
     code prints every key in the database `db', without having to
     create a list in memory that contains them all:

          k = db.firstkey()
          while k != None:
              print k
              k = db.nextkey(k)

`reorganize()'
     If you have carried out a lot of deletions and would like to shrink
     the space used by the `gdbm' file, this routine will reorganize
     the database.  `gdbm' will not shorten the length of a database
     file except by using this reorganization; otherwise, deleted file
     space will be kept and reused as new (key, value) pairs are added.

`sync()'
     When the database has been opened in fast mode, this method forces
     any unwritten data to be written to the disk.

See also:
     *Note anydbm:: Generic interface to `dbm'-style databases.  *Note
     whichdb:: Utility module used to determine the type of an existing
     database.


File: python-lib.info,  Node: termios,  Next: TERMIOS,  Prev: gdbm,  Up: Unix Specific Services

POSIX style tty control
=======================

POSIX style tty control.

This module provides an interface to the POSIX calls for tty I/O
control.  For a complete description of these calls, see the POSIX or
UNIX manual pages.  It is only available for those UNIX versions that
support POSIX _termios_ style tty I/O control (and then only if
configured at installation time).

All functions in this module take a file descriptor FD as their first
argument.  This can be an integer file descriptor, such as returned by
`sys.stdin.fileno()', or a file object, such as `sys.stdin' itself.

This module also defines all the constants needed to work with the
functions provided here; these have the same name as their counterparts
in C.  Please refer to your system documentation for more information
on using these terminal control interfaces.

The module defines the following functions:

`tcgetattr(fd)'
     Return a list containing the tty attributes for file descriptor
     FD, as follows: `['IFLAG, OFLAG, CFLAG, LFLAG, ISPEED, OSPEED,
     CC`]' where CC is a list of the tty special characters (each a
     string of length 1, except the items with indices `VMIN' and
     `VTIME', which are integers when these fields are defined).  The
     interpretation of the flags and the speeds as well as the indexing
     in the CC array must be done using the symbolic constants defined
     in the `termios' module.

`tcsetattr(fd, when, attributes)'
     Set the tty attributes for file descriptor FD from the ATTRIBUTES,
     which is a list like the one returned by `tcgetattr()'.  The WHEN
     argument determines when the attributes are changed: `TCSANOW' to
     change immediately, `TCSADRAIN' to change after transmitting all
     queued output, or `TCSAFLUSH' to change after transmitting all
     queued output and discarding all queued input.

`tcsendbreak(fd, duration)'
     Send a break on file descriptor FD.  A zero DURATION sends a break
     for 0.25-0.5 seconds; a nonzero DURATION has a system dependent
     meaning.

`tcdrain(fd)'
     Wait until all output written to file descriptor FD has been
     transmitted.

`tcflush(fd, queue)'
     Discard queued data on file descriptor FD.  The QUEUE selector
     specifies which queue: `TCIFLUSH' for the input queue, `TCOFLUSH'
     for the output queue, or `TCIOFLUSH' for both queues.

`tcflow(fd, action)'
     Suspend or resume input or output on file descriptor FD.  The
     ACTION argument can be `TCOOFF' to suspend output, `TCOON' to
     restart output, `TCIOFF' to suspend input, or `TCION' to restart
     input.

See also:
     *Note tty:: Convenience functions for common terminal control
     operations.

* Menu:

* termios Example::


File: python-lib.info,  Node: termios Example,  Prev: termios,  Up: termios

Example
-------

Here's a function that prompts for a password with echoing turned off.
Note the technique using a separate `tcgetattr()' call and a `try' ...
`finally' statement to ensure that the old tty attributes are restored
exactly no matter what happens:

     def getpass(prompt = "Password: "):
         import termios, sys
         fd = sys.stdin.fileno()
         old = termios.tcgetattr(fd)
         new = termios.tcgetattr(fd)
         new[3] = new[3] & ~termios.ECHO          # lflags
         try:
             termios.tcsetattr(fd, termios.TCSADRAIN, new)
             passwd = raw_input(prompt)
         finally:
             termios.tcsetattr(fd, termios.TCSADRAIN, old)
         return passwd


File: python-lib.info,  Node: TERMIOS,  Next: tty,  Prev: termios,  Up: Unix Specific Services

Constants used with the `termios' module
========================================

Symbolic constants required to use the `termios' module.

_This is deprecated in Python 2.1.  Import needed constants from
`termios' instead._

This module defines the symbolic constants required to use the `termios'
module (see the previous section).  See the POSIX or UNIX manual pages
for a list of those constants.


File: python-lib.info,  Node: tty,  Next: pty,  Prev: TERMIOS,  Up: Unix Specific Services

Terminal control functions
==========================

Utility functions that perform common terminal control operations.

The `tty' module defines functions for putting the tty into cbreak and
raw modes.

Because it requires the `termios' module, it will work only on UNIX.

The `tty' module defines the following functions:

`setraw(fd[, when])'
     Change the mode of the file descriptor FD to raw. If WHEN is
     omitted, it defaults to `TERMIOS.TCAFLUSH', and is passed to
     `termios.tcsetattr()'.

`setcbreak(fd[, when])'
     Change the mode of file descriptor FD to cbreak. If WHEN is
     omitted, it defaults to `TERMIOS.TCAFLUSH', and is passed to
     `termios.tcsetattr()'.

See also:
     *Note termios:: Low-level terminal control interface.  *Note
     TERMIOS:: Constants useful for terminal control operations.


File: python-lib.info,  Node: pty,  Next: fcntl,  Prev: tty,  Up: Unix Specific Services

Pseudo-terminal utilities
=========================

Pseudo-Terminal Handling for SGI and Linux.

The `pty' module defines operations for handling the pseudo-terminal
concept: starting another process and being able to write to and read
from its controlling terminal programmatically.

Because pseudo-terminal handling is highly platform dependant, there is
code to do it only for SGI and Linux. (The Linux code is supposed to
work on other platforms, but hasn't been tested yet.)

The `pty' module defines the following functions:

`fork()'
     Fork. Connect the child's controlling terminal to a
     pseudo-terminal.  Return value is `(PID, FD)'. Note that the child
     gets PID 0, and the FD is _invalid_. The parent's return value is
     the PID of the child, and FD is a file descriptor connected to the
     child's controlling terminal (and also to the child's standard
     input and output).

`openpty()'
     Open a new pseudo-terminal pair, using `os.openpty()' if possible,
     or emulation code for SGI and generic UNIX systems.  Return a pair
     of file descriptors `(MASTER, SLAVE)', for the master and the
     slave end, respectively.

`spawn(argv[, master_read[, stdin_read]])'
     Spawn a process, and connect its controlling terminal with the
     current process's standard io. This is often used to baffle
     programs which insist on reading from the controlling terminal.

     The functions MASTER_READ and STDIN_READ should be functions which
     read from a file-descriptor. The defaults try to read 1024 bytes
     each time they are called.

