This is python-lib.info, produced by makeinfo version 4.3 from
python-lib.texi.

October 3, 2003


File: python-lib.info,  Node: Socket Objects,  Next: SSL Objects,  Prev: socket,  Up: socket

Socket Objects
--------------

Socket objects have the following methods.  Except for `makefile()'
these correspond to UNIX system calls applicable to sockets.

`accept()'
     Accept a connection.  The socket must be bound to an address and
     listening for connections.  The return value is a pair `(CONN,
     ADDRESS)' where CONN is a _new_ socket object usable to send and
     receive data on the connection, and ADDRESS is the address bound
     to the socket on the other end of the connection.

`bind(address)'
     Bind the socket to ADDRESS.  The socket must not already be bound.
     (The format of ADDRESS depends on the address family -- see
     above.)  _Note:_ This method has historically accepted a pair of
     parameters for `AF_INET' addresses instead of only a tuple.  This
     was never intentional and is no longer be available in Python 2.0.

`close()'
     Close the socket.  All future operations on the socket object will
     fail.  The remote end will receive no more data (after queued data
     is flushed).  Sockets are automatically closed when they are
     garbage-collected.

`connect(address)'
     Connect to a remote socket at ADDRESS.  (The format of ADDRESS
     depends on the address family -- see above.)  _Note:_ This method
     has historically accepted a pair of parameters for `AF_INET'
     addresses instead of only a tuple.  This was never intentional and
     is no longer available in Python 2.0 and later.

`connect_ex(address)'
     Like `connect(ADDRESS)', but return an error indicator instead of
     raising an exception for errors returned by the C-level
     `connect()' call (other problems, such as "host not found," can
     still raise exceptions).  The error indicator is `0' if the
     operation succeeded, otherwise the value of the `errno' variable.
     This is useful to support, for example, asynchronous connects.
     _Note:_ This method has historically accepted a pair of parameters
     for `AF_INET' addresses instead of only a tuple. This was never
     intentional and is no longer be available in Python 2.0 and later.

`fileno()'
     Return the socket's file descriptor (a small integer).  This is
     useful with `select.select()'.

`getpeername()'
     Return the remote address to which the socket is connected.  This
     is useful to find out the port number of a remote IPv4/v6 socket,
     for instance.  (The format of the address returned depends on the
     address family -- see above.)  On some systems this function is
     not supported.

`getsockname()'
     Return the socket's own address.  This is useful to find out the
     port number of an IPv4/v6 socket, for instance.  (The format of
     the address returned depends on the address family -- see above.)

`getsockopt(level, optname[, buflen])'
     Return the value of the given socket option (see the UNIX man page
     `getsockopt(2)').  The needed symbolic constants (`SO_*' etc.) are
     defined in this module.  If BUFLEN is absent, an integer option is
     assumed and its integer value is returned by the function.  If
     BUFLEN is present, it specifies the maximum length of the buffer
     used to receive the option in, and this buffer is returned as a
     string.  It is up to the caller to decode the contents of the
     buffer (see the optional built-in module `struct' for a way to
     decode C structures encoded as strings).

`listen(backlog)'
     Listen for connections made to the socket.  The BACKLOG argument
     specifies the maximum number of queued connections and should be at
     least 1; the maximum value is system-dependent (usually 5).

`makefile([mode[, bufsize]])'
     Return a "file object" associated with the socket.  (File objects
     are described in *Note File Objects::, "File Objects.")  The file
     object references a `dup()'ped version of the socket file
     descriptor, so the file object and socket object may be closed or
     garbage-collected independently.  The socket should be in blocking
     mode.  The optional MODE and BUFSIZE arguments are interpreted the
     same way as by the built-in `file()' function; see "Built-in
     Functions" (section *Note Built-in Functions::) for more
     information.

`recv(bufsize[, flags])'
     Receive data from the socket.  The return value is a string
     representing the data received.  The maximum amount of data to be
     received at once is specified by BUFSIZE.  See the UNIX manual page
     `recv(2)' for the meaning of the optional argument FLAGS; it
     defaults to zero.

`recvfrom(bufsize[, flags])'
     Receive data from the socket.  The return value is a pair
     `(STRING, ADDRESS)' where STRING is a string representing the data
     received and ADDRESS is the address of the socket sending the
     data.  The optional FLAGS argument has the same meaning as for
     `recv()' above.  (The format of ADDRESS depends on the address
     family -- see above.)

`send(string[, flags])'
     Send data to the socket.  The socket must be connected to a remote
     socket.  The optional FLAGS argument has the same meaning as for
     `recv()' above.  Returns the number of bytes sent.  Applications
     are responsible for checking that all data has been sent; if only
     some of the data was transmitted, the application needs to attempt
     delivery of the remaining data.

`sendall(string[, flags])'
     Send data to the socket.  The socket must be connected to a remote
     socket.  The optional FLAGS argument has the same meaning as for
     `recv()' above.  Unlike `send()', this method continues to send
     data from STRING until either all data has been sent or an error
     occurs.  `None' is returned on success.  On error, an exception is
     raised, and there is no way to determine how much data, if any,
     was successfully sent.

`sendto(string[, flags], address)'
     Send data to the socket.  The socket should not be connected to a
     remote socket, since the destination socket is specified by
     ADDRESS.  The optional FLAGS argument has the same meaning as for
     `recv()' above.  Return the number of bytes sent.  (The format of
     ADDRESS depends on the address family -- see above.)

`setblocking(flag)'
     Set blocking or non-blocking mode of the socket: if FLAG is 0, the
     socket is set to non-blocking, else to blocking mode.  Initially
     all sockets are in blocking mode.  In non-blocking mode, if a
     `recv()' call doesn't find any data, or if a `send()' call can't
     immediately dispose of the data, a `error' exception is raised; in
     blocking mode, the calls block until they can proceed.
     `s.setblocking(0)' is equivalent to `s.settimeout(0)';
     `s.setblocking(1)' is equivalent to `s.settimeout(None)'.

`settimeout(value)'
     Set a timeout on blocking socket operations.  The VALUE argument
     can be a nonnegative float expressing seconds, or `None'.  If a
     float is given, subsequent socket operations will raise an
     `timeout' exception if the timeout period VALUE has elapsed before
     the operation has completed.  Setting a timeout of `None' disables
     timeouts on socket operations.  `s.settimeout(0.0)' is equivalent
     to `s.setblocking(0)'; `s.settimeout(None)' is equivalent to
     `s.setblocking(1)'.  _Added in Python version 2.3_

`gettimeout()'
     Returns the timeout in floating seconds associated with socket
     operations, or `None' if no timeout is set.  This reflects the
     last call to `setblocking()' or `settimeout()'.  _Added in Python
     version 2.3_

Some notes on socket blocking and timeouts: A socket object can be in
one of three modes: blocking, non-blocking, or timeout.  Sockets are
always created in blocking mode.  In blocking mode, operations block
until complete.  In non-blocking mode, operations fail (with an error
that is unfortunately system-dependent) if they cannot be completed
immediately.  In timeout mode, operations fail if they cannot be
completed within the timeout specified for the socket.  The
`setblocking()' method is simply a shorthand for certain `settimeout()'
calls.

Timeout mode internally sets the socket in non-blocking mode.  The
blocking and timeout modes are shared between file descriptors and
socket objects that refer to the same network endpoint.  A consequence
of this is that file objects returned by the `makefile()' method should
only be used when the socket is in blocking mode; in timeout or
non-blocking mode file operations that cannot be completed immediately
will fail.

`setsockopt(level, optname, value)'
     Set the value of the given socket option (see the UNIX manual page
     `setsockopt(2)').  The needed symbolic constants are defined in
     the `socket' module (`SO_*' etc.).  The value can be an integer or
     a string representing a buffer.  In the latter case it is up to
     the caller to ensure that the string contains the proper bits (see
     the optional built-in module `struct'  for a way to encode C
     structures as strings).

`shutdown(how)'
     Shut down one or both halves of the connection.  If HOW is `0',
     further receives are disallowed.  If HOW is `1', further sends are
     disallowed.  If HOW is `2', further sends and receives are
     disallowed.

Note that there are no methods `read()' or `write()'; use `recv()' and
`send()' without FLAGS argument instead.


File: python-lib.info,  Node: SSL Objects,  Next: Example 7,  Prev: Socket Objects,  Up: socket

SSL Objects
-----------

SSL objects have the following methods.

`write(s)'
     Writes the string S to the on the object's SSL connection.  The
     return value is the number of bytes written.

`read([n])'
     If N is provided, read N bytes from the SSL connection, otherwise
     read until EOF. The return value is a string of the bytes read.


File: python-lib.info,  Node: Example 7,  Prev: SSL Objects,  Up: socket

Example
-------

Here are four minimal example programs using the TCP/IP protocol: a
server that echoes all data that it receives back (servicing only one
client), and a client using it.  Note that a server must perform the
sequence `socket()', `bind()', `listen()', `accept()' (possibly
repeating the `accept()' to service more than one client), while a
client only needs the sequence `socket()', `connect()'.  Also note that
the server does not `send()'/`recv()' on the socket it is listening on
but on the new socket returned by `accept()'.

The first two examples support IPv4 only.

     # Echo server program
     import socket
     
     HOST = ''                 # Symbolic name meaning the local host
     PORT = 50007              # Arbitrary non-privileged port
     s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
     s.bind((HOST, PORT))
     s.listen(1)
     conn, addr = s.accept()
     print 'Connected by', addr
     while 1:
         data = conn.recv(1024)
         if not data: break
         conn.send(data)
     conn.close()

     # Echo client program
     import socket
     
     HOST = 'daring.cwi.nl'    # The remote host
     PORT = 50007              # The same port as used by the server
     s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
     s.connect((HOST, PORT))
     s.send('Hello, world')
     data = s.recv(1024)
     s.close()
     print 'Received', `data`

The next two examples are identical to the above two, but support both
IPv4 and IPv6.  The server side will listen to the first address family
available (it should listen to both instead).  On most of IPv6-ready
systems, IPv6 will take precedence and the server may not accept IPv4
traffic.  The client side will try to connect to the all addresses
returned as a result of the name resolution, and sends traffic to the
first one connected successfully.

     # Echo server program
     import socket
     import sys
     
     HOST = ''                 # Symbolic name meaning the local host
     PORT = 50007              # Arbitrary non-privileged port
     s = None
     for res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC, socket.SOCK_STREAM, 0, socket.AI_PASSIVE):
         af, socktype, proto, canonname, sa = res
         try:
     	s = socket.socket(af, socktype, proto)
         except socket.error, msg:
     	s = None
     	continue
         try:
     	s.bind(sa)
     	s.listen(1)
         except socket.error, msg:
     	s.close()
     	s = None
     	continue
         break
     if s is None:
         print 'could not open socket'
         sys.exit(1)
     conn, addr = s.accept()
     print 'Connected by', addr
     while 1:
         data = conn.recv(1024)
         if not data: break
         conn.send(data)
     conn.close()

     # Echo client program
     import socket
     import sys
     
     HOST = 'daring.cwi.nl'    # The remote host
     PORT = 50007              # The same port as used by the server
     s = None
     for res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC, socket.SOCK_STREAM):
         af, socktype, proto, canonname, sa = res
         try:
     	s = socket.socket(af, socktype, proto)
         except socket.error, msg:
     	s = None
     	continue
         try:
     	s.connect(sa)
         except socket.error, msg:
     	s.close()
     	s = None
     	continue
         break
     if s is None:
         print 'could not open socket'
         sys.exit(1)
     s.send('Hello, world')
     data = s.recv(1024)
     s.close()
     print 'Received', `data`


File: python-lib.info,  Node: select,  Next: thread,  Prev: socket,  Up: Optional Operating System Services

Waiting for I/O completion
==========================

Wait for I/O completion on multiple streams.

This module provides access to the `select()' and `poll()' functions
available in most operating systems.  Note that on Windows, it only
works for sockets; on other operating systems, it also works for other
file types (in particular, on UNIX, it works on pipes).  It cannot be
used on regular files to determine whether a file has grown since it
was last read.

The module defines the following:

`error'
     The exception raised when an error occurs.  The accompanying value
     is a pair containing the numeric error code from `errno' and the
     corresponding string, as would be printed by the C function
     `perror()'.

`poll()'
     (Not supported by all operating systems.)  Returns a polling
     object, which supports registering and unregistering file
     descriptors, and then polling them for I/O events; see
     section~*Note threading:: below for the methods supported by
     polling objects.

`select(iwtd, owtd, ewtd[, timeout])'
     This is a straightforward interface to the UNIX `select()' system
     call.  The first three arguments are lists of `waitable objects':
     either integers representing file descriptors or objects with a
     parameterless method named `fileno()' returning such an integer.
     The three lists of waitable objects are for input, output and
     `exceptional conditions', respectively.  Empty lists are allowed,
     but acceptance of three empty lists is platform-dependent.  (It is
     known to work on UNIX but not on Windows.)  The optional TIMEOUT
     argument specifies a time-out as a floating point number in
     seconds.  When the TIMEOUT argument is omitted the function blocks
     until at least one file descriptor is ready.  A time-out value of
     zero specifies a poll and never blocks.

     The return value is a triple of lists of objects that are ready:
     subsets of the first three arguments.  When the time-out is reached
     without a file descriptor becoming ready, three empty lists are
     returned.

     Among the acceptable object types in the lists are Python file
     objects (e.g. `sys.stdin', or objects returned by `open()' or
     `os.popen()'), socket objects returned by `socket.socket()'.  You
     may also define a "wrapper" class yourself, as long as it has an
     appropriate `fileno()' method (that really returns a file
     descriptor, not just a random integer).  _Note:_ File objects on
     Windows are not acceptable, but sockets are.    On Windows, the
     underlying `select()' function is provided by the WinSock library,
     and does not handle file desciptors that don't originate from
     WinSock.

* Menu:

* Polling Objects::


File: python-lib.info,  Node: Polling Objects,  Prev: select,  Up: select

Polling Objects
---------------

The `poll()' system call, supported on most UNIX systems, provides
better scalability for network servers that service many, many clients
at the same time.  `poll()' scales better because the system call only
requires listing the file descriptors of interest, while `select()'
builds a bitmap, turns on bits for the fds of interest, and then
afterward the whole bitmap has to be linearly scanned again.
`select()' is O(highest file descriptor), while `poll()' is O(number of
file descriptors).

`register(fd[, eventmask])'
     Register a file descriptor with the polling object.  Future calls
     to the `poll()' method will then check whether the file descriptor
     has any pending I/O events.  FD can be either an integer, or an
     object with a `fileno()' method that returns an integer.  File
     objects implement `fileno()', so they can also be used as the
     argument.

     EVENTMASK is an optional bitmask describing the type of events you
     want to check for, and can be a combination of the constants
     `POLLIN', `POLLPRI', and `POLLOUT', described in the table below.
     If not specified, the default value used will check for all 3
     types of events.

     Constant                           Meaning
     ------                             -----
     POLLIN                             There is data to read
     POLLPRI                            There is urgent data to read
     POLLOUT                            Ready for output: writing will
                                        not block
     POLLERR                            Error condition of some sort
     POLLHUP                            Hung up
     POLLNVAL                           Invalid request: descriptor not
                                        open

     Registering a file descriptor that's already registered is not an
     error, and has the same effect as registering the descriptor
     exactly once.

`unregister(fd)'
     Remove a file descriptor being tracked by a polling object.  Just
     like the `register()' method, FD can be an integer or an object
     with a `fileno()' method that returns an integer.

     Attempting to remove a file descriptor that was never registered
     causes a `KeyError' exception to be raised.

`poll([timeout])'
     Polls the set of registered file descriptors, and returns a
     possibly-empty list containing `(FD, EVENT)' 2-tuples for the
     descriptors that have events or errors to report.  FD is the file
     descriptor, and EVENT is a bitmask with bits set for the reported
     events for that descriptor -- `POLLIN' for waiting input,
     `POLLOUT' to indicate that the descriptor can be written to, and
     so forth.  An empty list indicates that the call timed out and no
     file descriptors had any events to report.  If TIMEOUT is given,
     it specifies the length of time in milliseconds which the system
     will wait for events before returning.  If TIMEOUT is omitted,
     negative, or `None', the call will block until there is an event
     for this poll object.


File: python-lib.info,  Node: thread,  Next: threading,  Prev: select,  Up: Optional Operating System Services

Multiple threads of control
===========================

Create multiple threads of control within one interpreter.

This module provides low-level primitives for working with multiple
threads (a.k.a. "light-weight processes" or "tasks") -- multiple
threads of control sharing their global data space.  For
synchronization, simple locks (a.k.a. "mutexes" or "binary semaphores")
are provided.

The module is optional.  It is supported on Windows, Linux, SGI IRIX,
Solaris 2.x, as well as on systems that have a POSIX thread (a.k.a.
"pthread") implementation.  For systems lacking the `thread' module,
the `dummy_thread' module is available.  It duplicates this module's
interface and can be used as a drop-in replacement.

It defines the following constant and functions:

`error'
     Raised on thread-specific errors.

`LockType'
     This is the type of lock objects.

`start_new_thread(function, args[, kwargs])'
     Start a new thread and return its identifier.  The thread executes
     the function FUNCTION with the argument list ARGS (which must be a
     tuple).  The optional KWARGS argument specifies a dictionary of
     keyword arguments.  When the function returns, the thread silently
     exits.  When the function terminates with an unhandled exception,
     a stack trace is printed and then the thread exits (but other
     threads continue to run).

`interrupt_main()'
     Raise a KeyboardInterrupt in the main thread.  A subthread can use
     this function to interrupt the main thread.  _Added in Python
     version 2.3_

`exit()'
     Raise the `SystemExit' exception.  When not caught, this will
     cause the thread to exit silently.

`allocate_lock()'
     Return a new lock object.  Methods of locks are described below.
     The lock is initially unlocked.

`get_ident()'
     Return the `thread identifier' of the current thread.  This is a
     nonzero integer.  Its value has no direct meaning; it is intended
     as a magic cookie to be used e.g. to index a dictionary of
     thread-specific data.  Thread identifiers may be recycled when a
     thread exits and another thread is created.

Lock objects have the following methods:

`acquire([waitflag])'
     Without the optional argument, this method acquires the lock
     unconditionally, if necessary waiting until it is released by
     another thread (only one thread at a time can acquire a lock --
     that's their reason for existence), and returns `None'.  If the
     integer WAITFLAG argument is present, the action depends on its
     value: if it is zero, the lock is only acquired if it can be
     acquired immediately without waiting, while if it is nonzero, the
     lock is acquired unconditionally as before.  If an argument is
     present, the return value is `True' if the lock is acquired
     successfully, `False' if not.

`release()'
     Releases the lock.  The lock must have been acquired earlier, but
     not necessarily by the same thread.

`locked()'
     Return the status of the lock: `True' if it has been acquired by
     some thread, `False' if not.

*Caveats:*

   * Threads interact strangely with interrupts: the
     `KeyboardInterrupt' exception will be received by an arbitrary
     thread.  (When the `signal' module is available, interrupts always
     go to the main thread.)

   * Calling `sys.exit()' or raising the `SystemExit' exception is
     equivalent to calling `exit()'.

   * Not all built-in functions that may block waiting for I/O allow
     other threads to run.  (The most popular ones (`time.sleep()',
     `FILE.read()', `select.select()') work as expected.)

   * It is not possible to interrupt the `acquire()' method on a lock
     -- the `KeyboardInterrupt' exception will happen after the lock
     has been acquired.

   * When the main thread exits, it is system defined whether the other
     threads survive.  On SGI IRIX using the native thread
     implementation, they survive.  On most other systems, they are
     killed without executing `try' ... `finally' clauses or executing
     object destructors.

   * When the main thread exits, it does not do any of its usual cleanup
     (except that `try' ... `finally' clauses are honored), and the
     standard I/O files are not flushed.



File: python-lib.info,  Node: threading,  Next: dummy_thread,  Prev: thread,  Up: Optional Operating System Services

Higher-level threading interface
================================

Higher-level threading interface.

This module constructs higher-level threading interfaces on top of the
lower level `thread' module.

The `dummy_threading' module is provided for situations where
`threading' cannot be used because `thread' is missing.

This module defines the following functions and objects:

`activeCount()'
     Return the number of currently active `Thread' objects.  The
     returned count is equal to the length of the list returned by
     `enumerate()'.  A function that returns the number of currently
     active threads.

`Condition()'
     A factory function that returns a new condition variable object.
     A condition variable allows one or more threads to wait until they
     are notified by another thread.

`currentThread()'
     Return the current `Thread' object, corresponding to the caller's
     thread of control.  If the caller's thread of control was not
     created through the `threading' module, a dummy thread object with
     limited functionality is returned.

`enumerate()'
     Return a list of all currently active `Thread' objects.  The list
     includes daemonic threads, dummy thread objects created by
     `currentThread()', and the main thread.  It excludes terminated
     threads and threads that have not yet been started.

`Event()'
     A factory function that returns a new event object.  An event
     manages a flag that can be set to true with the `set()' method and
     reset to false with the `clear()' method.  The `wait()' method
     blocks until the flag is true.

`Lock()'
     A factory function that returns a new primitive lock object.  Once
     a thread has acquired it, subsequent attempts to acquire it block,
     until it is released; any thread may release it.

`RLock()'
     A factory function that returns a new reentrant lock object.  A
     reentrant lock must be released by the thread that acquired it.
     Once a thread has acquired a reentrant lock, the same thread may
     acquire it again without blocking; the thread must release it once
     for each time it has acquired it.

`Semaphore([value])'
     A factory function that returns a new semaphore object.  A
     semaphore manages a counter representing the number of `release()'
     calls minus the number of `acquire()' calls, plus an initial value.
     The `acquire()' method blocks if necessary until it can return
     without making the counter negative.  If not given, VALUE defaults
     to 1.

`BoundedSemaphore([value])'
     A factory function that returns a new bounded semaphore object.  A
     bounded semaphore checks to make sure its current value doesn't
     exceed its initial value.  If it does, `ValueError' is raised. In
     most situations semaphores are used to guard resources with
     limited capacity.  If the semaphore is released too many times
     it's a sign of a bug.  If not given, VALUE defaults to 1.

`Thread'
     {} A class that represents a thread of control.  This class can be
     safely subclassed in a limited fashion.

`Timer'
     {} A thread that executes a function after a specified interval
     has passed.

`settrace(func)'
     Set a trace function  for all threads started from the `threading'
     module.  The FUNC will be passed to `sys.settrace()' for each
     thread, before its `run()' method is called.  _Added in Python
     version 2.3_

`setprofile(func)'
     Set a profile function  for all threads started from the
     `threading' module.  The FUNC will be passed to `sys.setprofile()'
     for each thread, before its `run()' method is called.  _Added in
     Python version 2.3_

Detailed interfaces for the objects are documented below.

The design of this module is loosely based on Java's threading model.
However, where Java makes locks and condition variables basic behavior
of every object, they are separate objects in Python.  Python's `Thread'
class supports a subset of the behavior of Java's Thread class;
currently, there are no priorities, no thread groups, and threads
cannot be destroyed, stopped, suspended, resumed, or interrupted.  The
static methods of Java's Thread class, when implemented, are mapped to
module-level functions.

All of the methods described below are executed atomically.

* Menu:

* Lock Objects::
* RLock Objects::
* Condition Objects::
* Semaphore Objects::
* Event Objects::
* Thread Objects::
* Timer Objects::


File: python-lib.info,  Node: Lock Objects,  Next: RLock Objects,  Prev: threading,  Up: threading

Lock Objects
------------

A primitive lock is a synchronization primitive that is not owned by a
particular thread when locked.  In Python, it is currently the lowest
level synchronization primitive available, implemented directly by the
`thread' extension module.

A primitive lock is in one of two states, "locked" or "unlocked".  It
is created in the unlocked state.  It has two basic methods,
`acquire()' and `release()'.  When the state is unlocked, `acquire()'
changes the state to locked and returns immediately.  When the state is
locked, `acquire()' blocks until a call to `release()' in another
thread changes it to unlocked, then the `acquire()' call resets it to
locked and returns.  The `release()' method should only be called in the
locked state; it changes the state to unlocked and returns immediately.
When more than one thread is blocked in `acquire()' waiting for the
state to turn to unlocked, only one thread proceeds when a `release()'
call resets the state to unlocked; which one of the waiting threads
proceeds is not defined, and may vary across implementations.

All methods are executed atomically.

`acquire([blocking` = 1'])'
     Acquire a lock, blocking or non-blocking.

     When invoked without arguments, block until the lock is unlocked,
     then set it to locked, and return.  There is no return value in
     this case.

     When invoked with the BLOCKING argument set to true, do the same
     thing as when called without arguments, and return true.

     When invoked with the BLOCKING argument set to false, do not
     block.  If a call without an argument would block, return false
     immediately; otherwise, do the same thing as when called without
     arguments, and return true.

`release()'
     Release a lock.

     When the lock is locked, reset it to unlocked, and return.  If any
     other threads are blocked waiting for the lock to become unlocked,
     allow exactly one of them to proceed.

     Do not call this method when the lock is unlocked.

     There is no return value.


File: python-lib.info,  Node: RLock Objects,  Next: Condition Objects,  Prev: Lock Objects,  Up: threading

RLock Objects
-------------

A reentrant lock is a synchronization primitive that may be acquired
multiple times by the same thread.  Internally, it uses the concepts of
"owning thread" and "recursion level" in addition to the
locked/unlocked state used by primitive locks.  In the locked state,
some thread owns the lock; in the unlocked state, no thread owns it.

To lock the lock, a thread calls its `acquire()' method; this returns
once the thread owns the lock.  To unlock the lock, a thread calls its
`release()' method.  `acquire()'/`release()' call pairs may be nested;
only the final `release()' (the `release()' of the outermost pair)
resets the lock to unlocked and allows another thread blocked in
`acquire()' to proceed.

`acquire([blocking` = 1'])'
     Acquire a lock, blocking or non-blocking.

     When invoked without arguments: if this thread already owns the
     lock, increment the recursion level by one, and return
     immediately.  Otherwise, if another thread owns the lock, block
     until the lock is unlocked.  Once the lock is unlocked (not owned
     by any thread), then grab ownership, set the recursion level to
     one, and return.  If more than one thread is blocked waiting until
     the lock is unlocked, only one at a time will be able to grab
     ownership of the lock.  There is no return value in this case.

     When invoked with the BLOCKING argument set to true, do the same
     thing as when called without arguments, and return true.

     When invoked with the BLOCKING argument set to false, do not
     block.  If a call without an argument would block, return false
     immediately; otherwise, do the same thing as when called without
     arguments, and return true.

`release()'
     Release a lock, decrementing the recursion level.  If after the
     decrement it is zero, reset the lock to unlocked (not owned by any
     thread), and if any other threads are blocked waiting for the lock
     to become unlocked, allow exactly one of them to proceed.  If
     after the decrement the recursion level is still nonzero, the lock
     remains locked and owned by the calling thread.

     Only call this method when the calling thread owns the lock.  Do
     not call this method when the lock is unlocked.

     There is no return value.


File: python-lib.info,  Node: Condition Objects,  Next: Semaphore Objects,  Prev: RLock Objects,  Up: threading

Condition Objects
-----------------

A condition variable is always associated with some kind of lock; this
can be passed in or one will be created by default.  (Passing one in is
useful when several condition variables must share the same lock.)

A condition variable has `acquire()' and `release()' methods that call
the corresponding methods of the associated lock.  It also has a
`wait()' method, and `notify()' and `notifyAll()' methods.  These three
must only be called when the calling thread has acquired the lock.

The `wait()' method releases the lock, and then blocks until it is
awakened by a `notify()' or `notifyAll()' call for the same condition
variable in another thread.  Once awakened, it re-acquires the lock and
returns.  It is also possible to specify a timeout.

The `notify()' method wakes up one of the threads waiting for the
condition variable, if any are waiting.  The `notifyAll()' method wakes
up all threads waiting for the condition variable.

Note: the `notify()' and `notifyAll()' methods don't release the lock;
this means that the thread or threads awakened will not return from
their `wait()' call immediately, but only when the thread that called
`notify()' or `notifyAll()' finally relinquishes ownership of the lock.

Tip: the typical programming style using condition variables uses the
lock to synchronize access to some shared state; threads that are
interested in a particular change of state call `wait()' repeatedly
until they see the desired state, while threads that modify the state
call `notify()' or `notifyAll()' when they change the state in such a
way that it could possibly be a desired state for one of the waiters.
For example, the following code is a generic producer-consumer
situation with unlimited buffer capacity:

     # Consume one item
     cv.acquire()
     while not an_item_is_available():
         cv.wait()
     get_an_available_item()
     cv.release()
     
     # Produce one item
     cv.acquire()
     make_an_item_available()
     cv.notify()
     cv.release()

To choose between `notify()' and `notifyAll()', consider whether one
state change can be interesting for only one or several waiting
threads.  E.g. in a typical producer-consumer situation, adding one
item to the buffer only needs to wake up one consumer thread.

`Condition([lock])'
     If the LOCK argument is given and not `None', it must be a `Lock'
     or `RLock' object, and it is used as the underlying lock.
     Otherwise, a new `RLock' object is created and used as the
     underlying lock.

`acquire(*args)'
     Acquire the underlying lock.  This method calls the corresponding
     method on the underlying lock; the return value is whatever that
     method returns.

`release()'
     Release the underlying lock.  This method calls the corresponding
     method on the underlying lock; there is no return value.

`wait([timeout])'
     Wait until notified or until a timeout occurs.  This must only be
     called when the calling thread has acquired the lock.

     This method releases the underlying lock, and then blocks until it
     is awakened by a `notify()' or `notifyAll()' call for the same
     condition variable in another thread, or until the optional
     timeout occurs.  Once awakened or timed out, it re-acquires the
     lock and returns.

     When the TIMEOUT argument is present and not `None', it should be
     a floating point number specifying a timeout for the operation in
     seconds (or fractions thereof).

     When the underlying lock is an `RLock', it is not released using
     its `release()' method, since this may not actually unlock the
     lock when it was acquired multiple times recursively.  Instead, an
     internal interface of the `RLock' class is used, which really
     unlocks it even when it has been recursively acquired several
     times.  Another internal interface is then used to restore the
     recursion level when the lock is reacquired.

`notify()'
     Wake up a thread waiting on this condition, if any.  This must
     only be called when the calling thread has acquired the lock.

     This method wakes up one of the threads waiting for the condition
     variable, if any are waiting; it is a no-op if no threads are
     waiting.

     The current implementation wakes up exactly one thread, if any are
     waiting.  However, it's not safe to rely on this behavior.  A
     future, optimized implementation may occasionally wake up more
     than one thread.

     Note: the awakened thread does not actually return from its
     `wait()' call until it can reacquire the lock.  Since `notify()'
     does not release the lock, its caller should.

`notifyAll()'
     Wake up all threads waiting on this condition.  This method acts
     like `notify()', but wakes up all waiting threads instead of one.


File: python-lib.info,  Node: Semaphore Objects,  Next: Event Objects,  Prev: Condition Objects,  Up: threading

Semaphore Objects
-----------------

This is one of the oldest synchronization primitives in the history of
computer science, invented by the early Dutch computer scientist Edsger
W. Dijkstra (he used `P()' and `V()' instead of `acquire()' and
`release()').

A semaphore manages an internal counter which is decremented by each
`acquire()' call and incremented by each `release()' call.  The counter
can never go below zero; when `acquire()' finds that it is zero, it
blocks, waiting until some other thread calls `release()'.

`Semaphore([value])'
     The optional argument gives the initial value for the internal
     counter; it defaults to `1'.

`acquire([blocking])'
     Acquire a semaphore.

     When invoked without arguments: if the internal counter is larger
     than zero on entry, decrement it by one and return immediately.
     If it is zero on entry, block, waiting until some other thread has
     called `release()' to make it larger than zero.  This is done with
     proper interlocking so that if multiple `acquire()' calls are
     blocked, `release()' will wake exactly one of them up.  The
     implementation may pick one at random, so the order in which
     blocked threads are awakened should not be relied on.  There is no
     return value in this case.

     When invoked with BLOCKING set to true, do the same thing as when
     called without arguments, and return true.

     When invoked with BLOCKING set to false, do not block.  If a call
     without an argument would block, return false immediately;
     otherwise, do the same thing as when called without arguments, and
     return true.

`release()'
     Release a semaphore, incrementing the internal counter by one.
     When it was zero on entry and another thread is waiting for it to
     become larger than zero again, wake up that thread.

* Menu:

* Semaphore Example::


File: python-lib.info,  Node: Semaphore Example,  Prev: Semaphore Objects,  Up: Semaphore Objects

`Semaphore' Example
...................

Semaphores are often used to guard resources with limited capacity, for
example, a database server.  In any situation where the size of the
resource size is fixed, you should use a bounded semaphore.  Before
spawning any worker threads, your main thread would initialize the
semaphore:

     maxconnections = 5
     ...
     pool_sema = BoundedSemaphore(value=maxconnections)

Once spawned, worker threads call the semaphore's acquire and release
methods when they need to connect to the server:

     pool_sema.acquire()
     conn = connectdb()
     ... use connection ...
     conn.close()
     pool_sema.release()

The use of a bounded semaphore reduces the chance that a programming
error which causes the semaphore to be released more than it's acquired
will go undetected.


File: python-lib.info,  Node: Event Objects,  Next: Thread Objects,  Prev: Semaphore Objects,  Up: threading

Event Objects
-------------

This is one of the simplest mechanisms for communication between
threads: one thread signals an event and other threads wait for it.

An event object manages an internal flag that can be set to true with
the `set()' method and reset to false with the `clear()' method.  The
`wait()' method blocks until the flag is true.

`Event()'
     The internal flag is initially false.

`isSet()'
     Return true if and only if the internal flag is true.

`set()'
     Set the internal flag to true.  All threads waiting for it to
     become true are awakened.  Threads that call `wait()' once the
     flag is true will not block at all.

`clear()'
     Reset the internal flag to false.  Subsequently, threads calling
     `wait()' will block until `set()' is called to set the internal
     flag to true again.

`wait([timeout])'
     Block until the internal flag is true.  If the internal flag is
     true on entry, return immediately.  Otherwise, block until another
     thread calls `set()' to set the flag to true, or until the
     optional timeout occurs.

     When the timeout argument is present and not `None', it should be a
     floating point number specifying a timeout for the operation in
     seconds (or fractions thereof).


File: python-lib.info,  Node: Thread Objects,  Next: Timer Objects,  Prev: Event Objects,  Up: threading

Thread Objects
--------------

This class represents an activity that is run in a separate thread of
control.  There are two ways to specify the activity: by passing a
callable object to the constructor, or by overriding the `run()' method
in a subclass.  No other methods (except for the constructor) should be
overridden in a subclass.  In other words, _only_  override the
`__init__()' and `run()' methods of this class.

Once a thread object is created, its activity must be started by
calling the thread's `start()' method.  This invokes the `run()' method
in a separate thread of control.

Once the thread's activity is started, the thread is considered 'alive'
and 'active' (these concepts are almost, but not quite exactly, the
same; their definition is intentionally somewhat vague).  It stops
being alive and active when its `run()' method terminates - either
normally, or by raising an unhandled exception.  The `isAlive()' method
tests whether the thread is alive.

Other threads can call a thread's `join()' method.  This blocks the
calling thread until the thread whose `join()' method is called is
terminated.

A thread has a name.  The name can be passed to the constructor, set
with the `setName()' method, and retrieved with the `getName()' method.

A thread can be flagged as a "daemon thread".  The significance of this
flag is that the entire Python program exits when only daemon threads
are left.  The initial value is inherited from the creating thread.
The flag can be set with the `setDaemon()' method and retrieved with
the `isDaemon()' method.

There is a "main thread" object; this corresponds to the initial thread
of control in the Python program.  It is not a daemon thread.

There is the possibility that "dummy thread objects" are created.
These are thread objects corresponding to "alien threads".  These are
threads of control started outside the threading module, such as
directly from C code.  Dummy thread objects have limited functionality;
they are always considered alive, active, and daemonic, and cannot be
`join()'ed.  They are never deleted, since it is impossible to detect
the termination of alien threads.

`Thread(group=None, target=None, name=None, args=(), kwargs={})'
     This constructor should always be called with keyword arguments.
     Arguments are:

     GROUP should be `None'; reserved for future extension when a
     `ThreadGroup' class is implemented.

     TARGET is the callable object to be invoked by the `run()' method.
     Defaults to `None', meaning nothing is called.

     NAME is the thread name.  By default, a unique name is constructed
     of the form "Thread-N" where N is a small decimal number.

     ARGS is the argument tuple for the target invocation.  Defaults to
     `()'.

     KWARGS is a dictionary of keyword arguments for the target
     invocation.  Defaults to `{}'.

     If the subclass overrides the constructor, it must make sure to
     invoke the base class constructor (`Thread.__init__()') before
     doing anything else to the thread.

`start()'
     Start the thread's activity.

     This must be called at most once per thread object.  It arranges
     for the object's `run()' method to be invoked in a separate thread
     of control.

`run()'
     Method representing the thread's activity.

     You may override this method in a subclass.  The standard `run()'
     method invokes the callable object passed to the object's
     constructor as the TARGET argument, if any, with sequential and
     keyword arguments taken from the ARGS and KWARGS arguments,
     respectively.

`join([timeout])'
     Wait until the thread terminates.  This blocks the calling thread
     until the thread whose `join()' method is called terminates -
     either normally or through an unhandled exception - or until the
     optional timeout occurs.

     When the TIMEOUT argument is present and not `None', it should be
     a floating point number specifying a timeout for the operation in
     seconds (or fractions thereof).

     A thread can be `join()'ed many times.

     A thread cannot join itself because this would cause a deadlock.

     It is an error to attempt to `join()' a thread before it has been
     started.

`getName()'
     Return the thread's name.

`setName(name)'
     Set the thread's name.

     The name is a string used for identification purposes only.  It
     has no semantics.  Multiple threads may be given the same name.
     The initial name is set by the constructor.

`isAlive()'
     Return whether the thread is alive.

     Roughly, a thread is alive from the moment the `start()' method
     returns until its `run()' method terminates.

`isDaemon()'
     Return the thread's daemon flag.

`setDaemon(daemonic)'
     Set the thread's daemon flag to the Boolean value DAEMONIC.  This
     must be called before `start()' is called.

     The initial value is inherited from the creating thread.

     The entire Python program exits when no active non-daemon threads
     are left.


File: python-lib.info,  Node: Timer Objects,  Prev: Thread Objects,  Up: threading

Timer Objects
-------------

This class represents an action that should be run only after a certain
amount of time has passed -- a timer.  `Timer' is a subclass of
`Thread' and as such also functions as an example of creating custom
threads.

Timers are started, as with threads, by calling their `start()' method.
The timer can be stopped (before its action has begun) by calling the
`cancel()' method.  The interval the timer will wait before executing
its action may not be exactly the same as the interval specified by the
user.

For example:
     def hello():
         print "hello, world"
     
     t = Timer(30.0, hello)
     t.start() # after 30 seconds, "hello, world" will be printed

`Timer(interval, function, args=[], kwargs={})'
     Create a timer that will run FUNCTION with arguments ARGS and
     keyword arguments KWARGS, after INTERVAL seconds have passed.

`cancel()'
     Stop the timer, and cancel the execution of the timer's action.
     This will only work if the timer is still in its waiting stage.


File: python-lib.info,  Node: dummy_thread,  Next: dummy_threading,  Prev: threading,  Up: Optional Operating System Services

Drop-in replacement for the `thread' module
===========================================

Drop-in replacement for the `thread' module.

This module provides a duplicate interface to the `thread' module.  It
is meant to be imported when the `thread' module is not provided on a
platform.

Suggested usage is:

     try:
         import thread as _thread
     except ImportError:
         import dummy_thread as _thread

Be careful to not use this module where deadlock might occur from a
thread being created that blocks waiting for another thread to be
created.  This often occurs with blocking I/O.

