This is python-lib.info, produced by makeinfo version 4.3 from
python-lib.texi.

October 3, 2003


File: python-lib.info,  Node: For extension writers and programs that embed Python,  Next: Access to message catalogs,  Prev: Background,  Up: locale

For extension writers and programs that embed Python
----------------------------------------------------

Extension modules should never call `setlocale()', except to find out
what the current locale is.  But since the return value can only be
used portably to restore it, that is not very useful (except perhaps to
find out whether or not the locale is `C').

When Python is embedded in an application, if the application sets the
locale to something specific before initializing Python, that is
generally okay, and Python will use whatever locale is set, _except_
that the `LC_NUMERIC' locale should always be `C'.

The `setlocale()' function in the `locale' module gives the Python
programmer the impression that you can manipulate the `LC_NUMERIC'
locale setting, but this not the case at the C level: C code will
always find that the `LC_NUMERIC' locale setting is `C'.  This is
because too much would break when the decimal point character is set to
something else than a period (e.g. the Python parser would break).
Caveat: threads that run without holding Python's global interpreter
lock may occasionally find that the numeric locale setting differs;
this is because the only portable way to implement this feature is to
set the numeric locale settings to what the user requests, extract the
relevant characteristics, and then restore the `C' numeric locale.

When Python code uses the `locale' module to change the locale, this
also affects the embedding application.  If the embedding application
doesn't want this to happen, it should remove the `_locale' extension
module (which does all the work) from the table of built-in modules in
the `config.c' file, and make sure that the `_locale' module is not
accessible as a shared library.


File: python-lib.info,  Node: Access to message catalogs,  Prev: For extension writers and programs that embed Python,  Up: locale

Access to message catalogs
--------------------------

The locale module exposes the C library's gettext interface on systems
that provide this interface.  It consists of the functions `gettext()',
`dgettext()', `dcgettext()', `textdomain()', and `bindtextdomain()'.
These are similar to the same functions in the `gettext' module, but use
the C library's binary format for message catalogs, and the C library's
search algorithms for locating message catalogs.

Python applications should normally find no need to invoke these
functions, and should use `gettext' instead.  A known exception to this
rule are applications that link use additional C libraries which
internally invoke `gettext()' or `cdgettext()'.  For these
applications, it may be necessary to bind the text domain, so that the
libraries can properly locate their message catalogs.


File: python-lib.info,  Node: gettext,  Next: logging,  Prev: locale,  Up: Generic Operating System Services

Multilingual internationalization services
==========================================

Multilingual internationalization services.

The `gettext' module provides internationalization (I18N) and
localization (L10N) services for your Python modules and applications.
It supports both the GNU `gettext' message catalog API and a higher
level, class-based API that may be more appropriate for Python files.
The interface described below allows you to write your module and
application messages in one natural language, and provide a catalog of
translated messages for running under different natural languages.

Some hints on localizing your Python modules and applications are also
given.

* Menu:

* GNU gettext API::
* Class-based API::
* Internationalizing your programs and modules::
* Acknowledgements::


File: python-lib.info,  Node: GNU gettext API,  Next: Class-based API,  Prev: gettext,  Up: gettext

GNU `gettext' API
-----------------

The `gettext' module defines the following API, which is very similar
to the GNU `gettext' API.  If you use this API you will affect the
translation of your entire application globally.  Often this is what
you want if your application is monolingual, with the choice of
language dependent on the locale of your user.  If you are localizing a
Python module, or if your application needs to switch languages on the
fly, you probably want to use the class-based API instead.

`bindtextdomain(domain[, localedir])'
     Bind the DOMAIN to the locale directory LOCALEDIR.  More
     concretely, `gettext' will look for binary `.mo' files for the
     given domain using the path (on UNIX):
     `LOCALEDIR/LANGUAGE/LC_MESSAGES/DOMAIN.mo', where LANGUAGES is
     searched for in the environment variables `LANGUAGE', `LC_ALL',
     `LC_MESSAGES', and `LANG' respectively.

     If LOCALEDIR is omitted or `None', then the current binding for
     DOMAIN is returned.(1)

`textdomain([domain])'
     Change or query the current global domain.  If DOMAIN is `None',
     then the current global domain is returned, otherwise the global
     domain is set to DOMAIN, which is returned.

`gettext(message)'
     Return the localized translation of MESSAGE, based on the current
     global domain, language, and locale directory.  This function is
     usually aliased as `_' in the local namespace (see examples below).

`dgettext(domain, message)'
     Like `gettext()', but look the message up in the specified DOMAIN.

`ngettext(singular, plural, n)'
     Like `gettext()', but consider plural forms. If a translation is
     found, apply the plural formula to N, and return the resulting
     message (some languages have more than two plural forms).  If no
     translation is found, return SINGULAR if N is 1; return PLURAL
     otherwise.

     The Plural formula is taken from the catalog header. It is a C or
     Python expression that has a free variable n; the expression
     evaluates to the index of the plural in the catalog. See the GNU
     gettext documentation for the precise syntax to be used in .po
     files, and the formulas for a variety of languages.

     _Added in Python version 2.3_

`dngettext(domain, singular, plural, n)'
     Like `ngettext()', but look the message up in the specified DOMAIN.

     _Added in Python version 2.3_

Note that GNU `gettext' also defines a `dcgettext()' method, but this
was deemed not useful and so it is currently unimplemented.

Here's an example of typical usage for this API:

     import gettext
     gettext.bindtextdomain('myapplication', '/path/to/my/language/directory')
     gettext.textdomain('myapplication')
     _ = gettext.gettext
     # ...
     print _('This is a translatable string.')

---------- Footnotes ----------

(1)  The default locale directory is system dependent; for example, on
RedHat Linux it is `/usr/share/locale', but on Solaris it is
`/usr/lib/locale'.  The `gettext' module does not try to support these
system dependent defaults; instead its default is
``sys.prefix'/share/locale'. For this reason, it is always best to call
`bindtextdomain()' with an explicit absolute path at the start of your
application.


File: python-lib.info,  Node: Class-based API,  Next: Internationalizing your programs and modules,  Prev: GNU gettext API,  Up: gettext

Class-based API
---------------

The class-based API of the `gettext' module gives you more flexibility
and greater convenience than the GNU `gettext' API.  It is the
recommended way of localizing your Python applications and modules.
`gettext' defines a "translations" class which implements the parsing
of GNU `.mo' format files, and has methods for returning either
standard 8-bit strings or Unicode strings.  Translations instances can
also install themselves in the built-in namespace as the function `_()'.

`find(domain[, localedir[,  languages[, all]]])'
     This function implements the standard `.mo' file search algorithm.
     It takes a DOMAIN, identical to what `textdomain()' takes.
     Optional LOCALEDIR is as in `bindtextdomain()'  Optional LANGUAGES
     is a list of strings, where each string is a language code.

     If LOCALEDIR is not given, then the default system locale
     directory is used.(1)  If LANGUAGES is not given, then the
     following environment variables are searched: `LANGUAGE',
     `LC_ALL', `LC_MESSAGES', and `LANG'.  The first one returning a
     non-empty value is used for the LANGUAGES variable.  The
     environment variables should contain a colon separated list of
     languages, which will be split on the colon to produce the expected
     list of language code strings.

     `find()' then expands and normalizes the languages, and then
     iterates through them, searching for an existing file built of
     these components:

     `LOCALEDIR/LANGUAGE/LC_MESSAGES/DOMAIN.mo'

     The first such file name that exists is returned by `find()'.  If
     no such file is found, then `None' is returned. If ALL is given,
     it returns a list of all file names, in the order in which they
     appear in the languages list or the environment variables.

`translation(domain[, localedir[, languages[,  class_,[fallback]]]])'
     Return a `Translations' instance based on the DOMAIN, LOCALEDIR,
     and LANGUAGES, which are first passed to `find()' to get a list of
     the associated `.mo' file paths.  Instances with identical `.mo'
     file names are cached.  The actual class instantiated is either
     CLASS_ if provided, otherwise `GNUTranslations'.  The class's
     constructor must take a single file object argument.

     If multiple files are found, later files are used as fallbacks for
     earlier ones. To allow setting the fallback, `copy.copy' is used
     to clone each translation object from the cache; the actual
     instance data is still shared with the cache.

     If no `.mo' file is found, this function raises `IOError' if
     FALLBACK is false (which is the default), and returns a
     `NullTranslations' instance if FALLBACK is true.

`install(domain[, localedir[, unicode]])'
     This installs the function `_' in Python's builtin namespace,
     based on DOMAIN, and LOCALEDIR which are passed to the function
     `translation()'.  The UNICODE flag is passed to the resulting
     translation object's `install' method.

     As seen below, you usually mark the strings in your application
     that are candidates for translation, by wrapping them in a call to
     the `_()' function, like this:

          print _('This string will be translated.')

     For convenience, you want the `_()' function to be installed in
     Python's builtin namespace, so it is easily accessible in all
     modules of your application.

* Menu:

* NullTranslations class::
* GNUTranslations class::
* Solaris message catalog support::
* Catalog constructor::

---------- Footnotes ----------

(1) See the footnote for `bindtextdomain()' above.


File: python-lib.info,  Node: NullTranslations class,  Next: GNUTranslations class,  Prev: Class-based API,  Up: Class-based API

The `NullTranslations' class
............................

Translation classes are what actually implement the translation of
original source file message strings to translated message strings.
The base class used by all translation classes is `NullTranslations';
this provides the basic interface you can use to write your own
specialized translation classes.  Here are the methods of
`NullTranslations':

`__init__([fp])'
     Takes an optional file object FP, which is ignored by the base
     class.  Initializes "protected" instance variables _INFO and
     _CHARSET which are set by derived classes, as well as _FALLBACK,
     which is set through `add_fallback'.  It then calls
     `self._parse(fp)' if FP is not `None'.

`_parse(fp)'
     No-op'd in the base class, this method takes file object FP, and
     reads the data from the file, initializing its message catalog.  If
     you have an unsupported message catalog file format, you should
     override this method to parse your format.

`add_fallback(fallback)'
     Add FALLBACK as the fallback object for the current translation
     object. A translation object should consult the fallback if it
     cannot provide a translation for a given message.

`gettext(message)'
     If a fallback has been set, forward `gettext' to the fallback.
     Otherwise, return the translated message.  Overridden in derived
     classes.

`ugettext(message)'
     If a fallback has been set, forward `ugettext' to the fallback.
     Otherwise, return the translated message as a Unicode string.
     Overridden in derived classes.

`ngettext(singular, plural, n)'
     If a fallback has been set, forward `ngettext' to the fallback.
     Otherwise, return the translated message.  Overridden in derived
     classes.

     _Added in Python version 2.3_

`ungettext(singular, plural, n)'
     If a fallback has been set, forward `ungettext' to the fallback.
     Otherwise, return the translated message as a Unicode string.
     Overridden in derived classes.

     _Added in Python version 2.3_

`info()'
     Return the "protected" `_info' variable.

`charset()'
     Return the "protected" `_charset' variable.

`install([unicode])'
     If the UNICODE flag is false, this method installs
     `self.gettext()' into the built-in namespace, binding it to `_'.
     If UNICODE is true, it binds `self.ugettext()' instead.  By
     default, UNICODE is false.

     Note that this is only one way, albeit the most convenient way, to
     make the `_' function available to your application.  Because it
     affects the entire application globally, and specifically the
     built-in namespace, localized modules should never install `_'.
     Instead, they should use this code to make `_' available to their
     module:

          import gettext
          t = gettext.translation('mymodule', ...)
          _ = t.gettext

     This puts `_' only in the module's global namespace and so only
     affects calls within this module.


File: python-lib.info,  Node: GNUTranslations class,  Next: Solaris message catalog support,  Prev: NullTranslations class,  Up: Class-based API

The `GNUTranslations' class
...........................

The `gettext' module provides one additional class derived from
`NullTranslations': `GNUTranslations'.  This class overrides `_parse()'
to enable reading GNU `gettext' format `.mo' files in both big-endian
and little-endian format.  It also coerces both message ids and message
strings to Unicode.

`GNUTranslations' parses optional meta-data out of the translation
catalog.  It is convention with GNU `gettext' to include meta-data as
the translation for the empty string.  This meta-data is in RFC 822
-style `key: value' pairs, and should contain the `Project-Id-Version'
key.  If the key `Content-Type' is found, then the `charset' property
is used to initialize the "protected" `_charset' instance variable,
defaulting to `None' if not found.  If the charset encoding is
specified, then all message ids and message strings read from the
catalog are converted to Unicode using this encoding.  The `ugettext()'
method always returns a Unicode, while the `gettext()' returns an
encoded 8-bit string.  For the message id arguments of both methods,
either Unicode strings or 8-bit strings containing only US-ASCII
characters are acceptable.  Note that the Unicode version of the
methods (i.e. `ugettext()' and `ungettext()') are the recommended
interface to use for internationalized Python programs.

The entire set of key/value pairs are placed into a dictionary and set
as the "protected" `_info' instance variable.

If the `.mo' file's magic number is invalid, or if other problems occur
while reading the file, instantiating a `GNUTranslations' class can
raise `IOError'.

The following methods are overridden from the base class implementation:

`gettext(message)'
     Look up the MESSAGE id in the catalog and return the corresponding
     message string, as an 8-bit string encoded with the catalog's
     charset encoding, if known.  If there is no entry in the catalog
     for the MESSAGE id, and a fallback has been set, the look up is
     forwarded to the fallback's `gettext()' method.  Otherwise, the
     MESSAGE id is returned.

`ugettext(message)'
     Look up the MESSAGE id in the catalog and return the corresponding
     message string, as a Unicode string.  If there is no entry in the
     catalog for the MESSAGE id, and a fallback has been set, the look
     up is forwarded to the fallback's `ugettext()' method.  Otherwise,
     the MESSAGE id is returned.

`ngettext(singular, plural, n)'
     Do a plural-forms lookup of a message id.  SINGULAR is used as the
     message id for purposes of lookup in the catalog, while N is used
     to determine which plural form to use.  The returned message
     string is an 8-bit string encoded with the catalog's charset
     encoding, if known.

     If the message id is not found in the catalog, and a fallback is
     specified, the request is forwarded to the fallback's `ngettext()'
     method.  Otherwise, when N is 1 SINGULAR is returned, and PLURAL
     is returned in all other cases.

     _Added in Python version 2.3_

`ungettext(singular, plural, n)'
     Do a plural-forms lookup of a message id.  SINGULAR is used as the
     message id for purposes of lookup in the catalog, while N is used
     to determine which plural form to use.  The returned message
     string is a Unicode string.

     If the message id is not found in the catalog, and a fallback is
     specified, the request is forwarded to the fallback's
     `ungettext()' method.  Otherwise, when N is 1 SINGULAR is
     returned, and PLURAL is returned in all other cases.

     Here is an example:

          n = len(os.listdir('.'))
          cat = GNUTranslations(somefile)
          message = cat.ungettext(
              'There is %(num)d file in this directory',
              'There are %(num)d files in this directory',
              n) % {'n': n}

     _Added in Python version 2.3_


File: python-lib.info,  Node: Solaris message catalog support,  Next: Catalog constructor,  Prev: GNUTranslations class,  Up: Class-based API

Solaris message catalog support
...............................

The Solaris operating system defines its own binary `.mo' file format,
but since no documentation can be found on this format, it is not
supported at this time.


File: python-lib.info,  Node: Catalog constructor,  Prev: Solaris message catalog support,  Up: Class-based API

The Catalog constructor
.......................

GNOME  uses a version of the `gettext' module by James Henstridge, but
this version has a slightly different API.  Its documented usage was:

     import gettext
     cat = gettext.Catalog(domain, localedir)
     _ = cat.gettext
     print _('hello world')

For compatibility with this older module, the function `Catalog()' is
an alias for the `translation()' function described above.

One difference between this module and Henstridge's: his catalog
objects supported access through a mapping API, but this appears to be
unused and so is not currently supported.


File: python-lib.info,  Node: Internationalizing your programs and modules,  Next: Acknowledgements,  Prev: Class-based API,  Up: gettext

Internationalizing your programs and modules
--------------------------------------------

Internationalization (I18N) refers to the operation by which a program
is made aware of multiple languages.  Localization (L10N) refers to the
adaptation of your program, once internationalized, to the local
language and cultural habits.  In order to provide multilingual
messages for your Python programs, you need to take the following steps:

  1. prepare your program or module by specially marking translatable
     strings

  2. run a suite of tools over your marked files to generate raw
     messages catalogs

  3. create language specific translations of the message catalogs

  4. use the `gettext' module so that message strings are properly
     translated

In order to prepare your code for I18N, you need to look at all the
strings in your files.  Any string that needs to be translated should
be marked by wrapping it in `_('...')' -- that is, a call to the
function `_()'.  For example:

     filename = 'mylog.txt'
     message = _('writing a log message')
     fp = open(filename, 'w')
     fp.write(message)
     fp.close()

In this example, the string `'writing a log message'' is marked as a
candidate for translation, while the strings `'mylog.txt'' and `'w''
are not.

The Python distribution comes with two tools which help you generate
the message catalogs once you've prepared your source code.  These may
or may not be available from a binary distribution, but they can be
found in a source distribution, in the `Tools/i18n' directory.

The `pygettext'(1) program scans all your Python source code looking
for the strings you previously marked as translatable.  It is similar
to the GNU `gettext' program except that it understands all the
intricacies of Python source code, but knows nothing about C or C++
source code.  You don't need GNU `gettext' unless you're also going to
be translating C code (such as C extension modules).

`pygettext' generates textual Uniforum-style human readable message
catalog `.pot' files, essentially structured human readable files which
contain every marked string in the source code, along with a
placeholder for the translation strings.  `pygettext' is a command line
script that supports a similar command line interface as `xgettext';
for details on its use, run:

     pygettext.py --help

Copies of these `.pot' files are then handed over to the individual
human translators who write language-specific versions for every
supported natural language.  They send you back the filled in
language-specific versions as a `.po' file.  Using the `msgfmt.py'(2)
program (in the `Tools/i18n' directory), you take the `.po' files from
your translators and generate the machine-readable `.mo' binary catalog
files.  The `.mo' files are what the `gettext' module uses for the
actual translation processing during run-time.

How you use the `gettext' module in your code depends on whether you
are internationalizing your entire application or a single module.

* Menu:

* Localizing your module::
* Localizing your application::
* Changing languages on the fly::
* Deferred translations::

---------- Footnotes ----------

(1) Franc,ois Pinard has written a program called `xpot' which does a
similar job.  It is available as part of his `po-utils' package at
<http://www.iro.umontreal.ca/contrib/po-utils/HTML/>.

(2) `msgfmt.py' is binary compatible with GNU `msgfmt' except that it
provides a simpler, all-Python implementation.  With this and
`pygettext.py', you generally won't need to install the GNU `gettext'
package to internationalize your Python applications.


File: python-lib.info,  Node: Localizing your module,  Next: Localizing your application,  Prev: Internationalizing your programs and modules,  Up: Internationalizing your programs and modules

Localizing your module
......................

If you are localizing your module, you must take care not to make
global changes, e.g. to the built-in namespace.  You should not use the
GNU `gettext' API but instead the class-based API.

Let's say your module is called "spam" and the module's various natural
language translation `.mo' files reside in `/usr/share/locale' in GNU
`gettext' format.  Here's what you would put at the top of your module:

     import gettext
     t = gettext.translation('spam', '/usr/share/locale')
     _ = t.gettext

If your translators were providing you with Unicode strings in their
`.po' files, you'd instead do:

     import gettext
     t = gettext.translation('spam', '/usr/share/locale')
     _ = t.ugettext


File: python-lib.info,  Node: Localizing your application,  Next: Changing languages on the fly,  Prev: Localizing your module,  Up: Internationalizing your programs and modules

Localizing your application
...........................

If you are localizing your application, you can install the `_()'
function globally into the built-in namespace, usually in the main
driver file of your application.  This will let all your
application-specific files just use `_('...')' without having to
explicitly install it in each file.

In the simple case then, you need only add the following bit of code to
the main driver file of your application:

     import gettext
     gettext.install('myapplication')

If you need to set the locale directory or the UNICODE flag, you can
pass these into the `install()' function:

     import gettext
     gettext.install('myapplication', '/usr/share/locale', unicode=1)


File: python-lib.info,  Node: Changing languages on the fly,  Next: Deferred translations,  Prev: Localizing your application,  Up: Internationalizing your programs and modules

Changing languages on the fly
.............................

If your program needs to support many languages at the same time, you
may want to create multiple translation instances and then switch
between them explicitly, like so:

     import gettext
     
     lang1 = gettext.translation(languages=['en'])
     lang2 = gettext.translation(languages=['fr'])
     lang3 = gettext.translation(languages=['de'])
     
     # start by using language1
     lang1.install()
     
     # ... time goes by, user selects language 2
     lang2.install()
     
     # ... more time goes by, user selects language 3
     lang3.install()


File: python-lib.info,  Node: Deferred translations,  Prev: Changing languages on the fly,  Up: Internationalizing your programs and modules

Deferred translations
.....................

In most coding situations, strings are translated where they are coded.
Occasionally however, you need to mark strings for translation, but
defer actual translation until later.  A classic example is:

     animals = ['mollusk',
                'albatross',
     	   'rat',
     	   'penguin',
     	   'python',
     	   ]
     # ...
     for a in animals:
         print a

Here, you want to mark the strings in the `animals' list as being
translatable, but you don't actually want to translate them until they
are printed.

Here is one way you can handle this situation:

     def _(message): return message
     
     animals = [_('mollusk'),
                _('albatross'),
     	   _('rat'),
     	   _('penguin'),
     	   _('python'),
     	   ]
     
     del _
     
     # ...
     for a in animals:
         print _(a)

This works because the dummy definition of `_()' simply returns the
string unchanged.  And this dummy definition will temporarily override
any definition of `_()' in the built-in namespace (until the `del'
command).  Take care, though if you have a previous definition of `_' in
the local namespace.

Note that the second use of `_()' will not identify "a" as being
translatable to the `pygettext' program, since it is not a string.

Another way to handle this is with the following example:

     def N_(message): return message
     
     animals = [N_('mollusk'),
                N_('albatross'),
     	   N_('rat'),
     	   N_('penguin'),
     	   N_('python'),
     	   ]
     
     # ...
     for a in animals:
         print _(a)

In this case, you are marking translatable strings with the function
`N_()',(1) which won't conflict with any definition of `_()'.  However,
you will need to teach your message extraction program to look for
translatable strings marked with `N_()'.  `pygettext' and `xpot' both
support this through the use of command line switches.

---------- Footnotes ----------

(1) The choice of `N_()' here is totally arbitrary; it could have just
as easily been `MarkThisStringForTranslation()'.


File: python-lib.info,  Node: Acknowledgements,  Prev: Internationalizing your programs and modules,  Up: gettext

Acknowledgements
----------------

The following people contributed code, feedback, design suggestions,
previous implementations, and valuable experience to the creation of
this module:

   * Peter Funk

   * James Henstridge

   * Juan David Ib'a~nez Palomar

   * Marc-Andr'e Lemburg

   * Martin von L"owis

   * Franc,ois Pinard

   * Barry Warsaw


File: python-lib.info,  Node: logging,  Prev: gettext,  Up: Generic Operating System Services

Logging facility for Python
===========================

Logging module for Python based on PEP 282 .

_Added in Python version 2.3_ This module defines functions and classes
which implement a flexible error logging system for applications.

Logging is performed by calling methods on instances of the `Logger'
class (hereafter called "loggers"). Each instance has a name, and they
are conceptually arranged in a name space hierarchy using dots
(periods) as separators. For example, a logger named "scan" is the
parent of loggers "scan.text", "scan.html" and "scan.pdf".  Logger
names can be anything you want, and indicate the area of an application
in which a logged message originates.

Logged messages also have levels of importance associated with them.
The default levels provided are `DEBUG', `INFO', `WARNING', `ERROR' and
`CRITICAL'. As a convenience, you indicate the importance of a logged
message by calling an appropriate method of `Logger'. The methods are
`debug()', `info()', `warning()', `error()' and `critical()', which
mirror the default levels. You are not constrained to use these levels:
you can specify your own and use a more general `Logger' method,
`log()', which takes an explicit level argument.

Levels can also be associated with loggers, being set either by the
developer or through loading a saved logging configuration. When a
logging method is called on a logger, the logger compares its own level
with the level associated with the method call. If the logger's level
is higher than the method call's, no logging message is actually
generated. This is the basic mechanism controlling the verbosity of
logging output.

Logging messages are encoded as instances of the `LogRecord' class.
When a logger decides to actually log an event, an `LogRecord' instance
is created from the logging message.

Logging messages are subjected to a dispatch mechanism through the use
of "handlers", which are instances of subclasses of the `Handler'
class. Handlers are responsible for ensuring that a logged message (in
the form of a `LogRecord') ends up in a particular location (or set of
locations) which is useful for the target audience for that message
(such as end users, support desk staff, system administrators,
developers). Handlers are passed `LogRecord' instances intended for
particular destinations. Each logger can have zero, one or more handlers
associated with it (via the `addHandler' method of `Logger').  In
addition to any handlers directly associated with a logger, _all
handlers associated with all ancestors of the logger_ are called to
dispatch the message.

Just as for loggers, handlers can have levels associated with them.  A
handler's level acts as a filter in the same way as a logger's level
does.  If a handler decides to actually dispatch an event, the `emit()'
method is used to send the message to its destination. Most
user-defined subclasses of `Handler' will need to override this
`emit()'.

In addition to the base `Handler' class, many useful subclasses are
provided:

  1. `StreamHandler' instances send error messages to streams
     (file-like objects).

  2. `FileHandler' instances send error messages to disk files.

  3. `RotatingFileHandler' instances send error messages to disk files,
     with support for maximum log file sizes and log file rotation.

  4. `SocketHandler' instances send error messages to TCP/IP sockets.

  5. `DatagramHandler' instances send error messages to UDP sockets.

  6. `SMTPHandler' instances send error messages to a designated email
     address.

  7. `SysLogHandler' instances send error messages to a UNIX syslog
     daemon, possibly on a remote machine.

  8. `NTEventLogHandler' instances send error messages to a Windows
     NT/2000/XP event log.

  9. `MemoryHandler' instances send error messages to a buffer in
     memory, which is flushed whenever specific criteria are met.

 10. `HTTPHandler' instances send error messages to an HTTP server
     using either `GET' or `POST' semantics.


The `StreamHandler' and `FileHandler' classes are defined in the core
logging package. The other handlers are defined in a sub- module,
`logging.handlers'. (There is also another sub-module,
`logging.config', for configuration functionality.)

Logged messages are formatted for presentation through instances of the
`Formatter' class. They are initialized with a format string suitable
for use with the % operator and a dictionary.

For formatting multiple messages in a batch, instances of
`BufferingFormatter' can be used. In addition to the format string
(which is applied to each message in the batch), there is provision for
header and trailer format strings.

When filtering based on logger level and/or handler level is not enough,
instances of `Filter' can be added to both `Logger' and `Handler'
instances (through their `addFilter()' method).  Before deciding to
process a message further, both loggers and handlers consult all their
filters for permission. If any filter returns a false value, the
message is not processed further.

The basic `Filter' functionality allows filtering by specific logger
name. If this feature is used, messages sent to the named logger and its
children are allowed through the filter, and all others dropped.

In addition to the classes described above, there are a number of
module- level functions.

`getLogger([name])'
     Return a logger with the specified name or, if no name is
     specified, return a logger which is the root logger of the
     hierarchy.

     All calls to this function with a given name return the same
     logger instance.  This means that logger instances never need to
     be passed between different parts of an application.

`debug(msg[, *args[, **kwargs]])'
     Logs a message with level `DEBUG' on the root logger.  The MSG is
     the message format string, and the ARGS are the arguments which
     are merged into MSG. The only keyword argument in KWARGS which is
     inspected is EXC_INFO which, if it does not evaluate as false,
     causes exception information (via a call to `sys.exc_info()') to
     be added to the logging message.

`info(msg[, *args[, **kwargs]])'
     Logs a message with level `INFO' on the root logger.  The
     arguments are interpreted as for `debug()'.

`warning(msg[, *args[, **kwargs]])'
     Logs a message with level `WARNING' on the root logger.  The
     arguments are interpreted as for `debug()'.

`error(msg[, *args[, **kwargs]])'
     Logs a message with level `ERROR' on the root logger.  The
     arguments are interpreted as for `debug()'.

`critical(msg[, *args[, **kwargs]])'
     Logs a message with level `CRITICAL' on the root logger.  The
     arguments are interpreted as for `debug()'.

`exception(msg[, *args])'
     Logs a message with level `ERROR' on the root logger.  The
     arguments are interpreted as for `debug()'. Exception info is
     added to the logging message. This function should only be called
     from an exception handler.

`disable(lvl)'
     Provides an overriding level LVL for all loggers which takes
     precedence over the logger's own level. When the need arises to
     temporarily throttle logging output down across the whole
     application, this function can be useful.

`addLevelName(lvl, levelName)'
     Associates level LVL with text LEVELNAME in an internal
     dictionary, which is used to map numeric levels to a textual
     representation, for example when a `Formatter' formats a message.
     This function can also be used to define your own levels. The only
     constraints are that all levels used must be registered using this
     function, levels should be positive integers and they should
     increase in increasing order of severity.

`getLevelName(lvl)'
     Returns the textual representation of logging level LVL. If the
     level is one of the predefined levels `CRITICAL', `ERROR',
     `WARNING', `INFO' or `DEBUG' then you get the corresponding
     string. If you have associated levels with names using
     `addLevelName()' then the name you have associated with LVL is
     returned. Otherwise, the string "Level %s" % lvl is returned.

`makeLogRecord(attrdict)'
     Creates and returns a new `LogRecord' instance whose attributes are
     defined by ATTRDICT. This function is useful for taking a pickled
     `LogRecord' attribute dictionary, sent over a socket, and
     reconstituting it as a `LogRecord' instance at the receiving end.

`basicConfig()'
     Does basic configuration for the logging system by creating a
     `StreamHandler' with a default `Formatter' and adding it to the
     root logger. The functions `debug()', `info()', `warning()',
     `error()' and `critical()' will call `basicConfig()' automatically
     if no handlers are defined for the root logger.

`shutdown()'
     Informs the logging system to perform an orderly shutdown by
     flushing and closing all handlers.

`setLoggerClass(klass)'
     Tells the logging system to use the class KLASS when instantiating
     a logger. The class should define `__init__()' such that only a
     name argument is required, and the `__init__()' should call
     `Logger.__init__()'. This function is typically called before any
     loggers are instantiated by applications which need to use custom
     logger behavior.

See also:
    *PEP282 A Logging System*
          The proposal which described this feature for inclusion in
          the Python standard library.

* Menu:

* Logger Objects::
* Handler Objects::
* Formatter Objects::
* Filter Objects::
* LogRecord Objects::
* Thread Safety::
* Configuration::
* Using the logging package::


File: python-lib.info,  Node: Logger Objects,  Next: Handler Objects,  Prev: logging,  Up: logging

Logger Objects
--------------

Loggers have the following attributes and methods. Note that Loggers are
never instantiated directly, but always through the module-level
function `logging.getLogger(name)'.

`propagate'
     If this evaluates to false, logging messages are not passed by this
     logger or by child loggers to higher level (ancestor) loggers. The
     constructor sets this attribute to 1.

`setLevel(lvl)'
     Sets the threshold for this logger to LVL. Logging messages which
     are less severe than LVL will be ignored. When a logger is
     created, the level is set to `NOTSET' (which causes all messages
     to be processed in the root logger, or delegation to the parent in
     non-root loggers).

`isEnabledFor(lvl)'
     Indicates if a message of severity LVL would be processed by this
     logger.  This method checks first the module-level level set by
     `logging.disable(lvl)' and then the logger's effective level as
     determined by `getEffectiveLevel()'.

`getEffectiveLevel()'
     Indicates the effective level for this logger. If a value other
     than `NOTSET' has been set using `setLevel()', it is returned.
     Otherwise, the hierarchy is traversed towards the root until a
     value other than `NOTSET' is found, and that value is returned.

`debug(msg[, *args[, **kwargs]])'
     Logs a message with level `DEBUG' on this logger.  The MSG is the
     message format string, and the ARGS are the arguments which are
     merged into MSG. The only keyword argument in KWARGS which is
     inspected is EXC_INFO which, if it does not evaluate as false,
     causes exception information (via a call to `sys.exc_info()') to
     be added to the logging message.

`info(msg[, *args[, **kwargs]])'
     Logs a message with level `INFO' on this logger.  The arguments
     are interpreted as for `debug()'.

`warning(msg[, *args[, **kwargs]])'
     Logs a message with level `WARNING' on this logger.  The arguments
     are interpreted as for `debug()'.

`error(msg[, *args[, **kwargs]])'
     Logs a message with level `ERROR' on this logger.  The arguments
     are interpreted as for `debug()'.

`critical(msg[, *args[, **kwargs]])'
     Logs a message with level `CRITICAL' on this logger.  The
     arguments are interpreted as for `debug()'.

`log(lvl, msg[, *args[, **kwargs]])'
     Logs a message with level LVL on this logger.  The other arguments
     are interpreted as for `debug()'.

`exception(msg[, *args])'
     Logs a message with level `ERROR' on this logger.  The arguments
     are interpreted as for `debug()'. Exception info is added to the
     logging message. This method should only be called from an
     exception handler.

`addFilter(filt)'
     Adds the specified filter FILT to this logger.

`removeFilter(filt)'
     Removes the specified filter FILT from this logger.

`filter(record)'
     Applies this logger's filters to the record and returns a true
     value if the record is to be processed.

`addHandler(hdlr)'
     Adds the specified handler HDLR to this logger.

`removeHandler(hdlr)'
     Removes the specified handler HDLR from this logger.

`findCaller()'
     Finds the caller's source filename and line number. Returns the
     filename and line number as a 2-element tuple.

`handle(record)'
     Handles a record by passing it to all handlers associated with
     this logger and its ancestors (until a false value of PROPAGATE is
     found).  This method is used for unpickled records received from a
     socket, as well as those created locally. Logger-level filtering
     is applied using `filter()'.

`makeRecord(name, lvl, fn, lno, msg, args, exc_info)'
     This is a factory method which can be overridden in subclasses to
     create specialized `LogRecord' instances.


File: python-lib.info,  Node: Handler Objects,  Next: Formatter Objects,  Prev: Logger Objects,  Up: logging

Handler Objects
---------------

Handlers have the following attributes and methods. Note that `Handler'
is never instantiated directly; this class acts as a base for more
useful subclasses. However, the `__init__()' method in subclasses needs
to call `Handler.__init__()'.

`__init__(level=`NOTSET')'
     Initializes the `Handler' instance by setting its level, setting
     the list of filters to the empty list and creating a lock (using
     `createLock()') for serializing access to an I/O mechanism.

`createLock()'
     Initializes a thread lock which can be used to serialize access to
     underlying I/O functionality which may not be threadsafe.

`acquire()'
     Acquires the thread lock created with `createLock()'.

`release()'
     Releases the thread lock acquired with `acquire()'.

`setLevel(lvl)'
     Sets the threshold for this handler to LVL. Logging messages which
     are less severe than LVL will be ignored. When a handler is
     created, the level is set to `NOTSET' (which causes all messages
     to be processed).

`setFormatter(form)'
     Sets the `Formatter' for this handler to FORM.

`addFilter(filt)'
     Adds the specified filter FILT to this handler.

`removeFilter(filt)'
     Removes the specified filter FILT from this handler.

`filter(record)'
     Applies this handler's filters to the record and returns a true
     value if the record is to be processed.

`flush()'
     Ensure all logging output has been flushed. This version does
     nothing and is intended to be implemented by subclasses.

`close()'
     Tidy up any resources used by the handler. This version does
     nothing and is intended to be implemented by subclasses.

`handle(record)'
     Conditionally emits the specified logging record, depending on
     filters which may have been added to the handler. Wraps the actual
     emission of the record with acquisition/release of the I/O thread
     lock.

`handleError()'
     This method should be called from handlers when an exception is
     encountered during an emit() call. By default it does nothing,
     which means that exceptions get silently ignored. This is what is
     mostly wanted for a logging system - most users will not care
     about errors in the logging system, they are more interested in
     application errors. You could, however, replace this with a custom
     handler if you wish.

`format(record)'
     Do formatting for a record - if a formatter is set, use it.
     Otherwise, use the default formatter for the module.

`emit(record)'
     Do whatever it takes to actually log the specified logging record.
     This version is intended to be implemented by subclasses and so
     raises a `NotImplementedError'.

* Menu:

* StreamHandler::
* FileHandler::
* RotatingFileHandler::
* SocketHandler::
* DatagramHandler::
* SysLogHandler::
* NTEventLogHandler::
* SMTPHandler::
* MemoryHandler::
* HTTPHandler::


File: python-lib.info,  Node: StreamHandler,  Next: FileHandler,  Prev: Handler Objects,  Up: Handler Objects

StreamHandler
.............

The `StreamHandler' class sends logging output to streams such as
SYS.STDOUT, SYS.STDERR or any file-like object (or, more precisely, any
object which supports `write()' and `flush()' methods).

`StreamHandler([strm])'
     Returns a new instance of the `StreamHandler' class. If STRM is
     specified, the instance will use it for logging output; otherwise,
     SYS.STDERR will be used.

`emit(record)'
     If a formatter is specified, it is used to format the record.  The
     record is then written to the stream with a trailing newline.  If
     exception information is present, it is formatted using
     `traceback.print_exception()' and appended to the stream.

`flush()'
     Flushes the stream by calling its `flush()' method. Note that the
     `close()' method is inherited from `Handler' and so does nothing,
     so an explicit `flush()' call may be needed at times.


File: python-lib.info,  Node: FileHandler,  Next: RotatingFileHandler,  Prev: StreamHandler,  Up: Handler Objects

FileHandler
...........

The `FileHandler' class sends logging output to a disk file.  It
inherits the output functionality from `StreamHandler'.

`FileHandler(filename[, mode])'
     Returns a new instance of the `FileHandler' class. The specified
     file is opened and used as the stream for logging. If MODE is not
     specified, `'a'' is used. By default, the file grows indefinitely.

`close()'
     Closes the file.

`emit(record)'
     Outputs the record to the file.


File: python-lib.info,  Node: RotatingFileHandler,  Next: SocketHandler,  Prev: FileHandler,  Up: Handler Objects

RotatingFileHandler
...................

The `RotatingFileHandler' class supports rotation of disk log files.

`RotatingFileHandler(filename[, mode[, maxBytes[, backupCount]]])'
     Returns a new instance of the `RotatingFileHandler' class. The
     specified file is opened and used as the stream for logging. If
     MODE is not specified, `'a'' is used. By default, the file grows
     indefinitely.

     You can use the MAXBYTES and BACKUPCOUNT values to allow the file
     to "rollover" at a predetermined size. When the size is about to
     be exceeded, the file is closed and a new file is silently opened
     for output. Rollover occurs whenever the current log file is
     nearly MAXBYTES in length; if MAXBYTES is zero, rollover never
     occurs.  If BACKUPCOUNT is non-zero, the system will save old log
     files by appending the extensions ".1", ".2" etc., to the
     filename. For example, with a BACKUPCOUNT of 5 and a base file
     name of `app.log', you would get `app.log', `app.log.1',
     `app.log.2', up to `app.log.5'. The file being written to is
     always `app.log'.  When this file is filled, it is closed and
     renamed to `app.log.1', and if files `app.log.1', `app.log.2',
     etc.  exist, then they are renamed to `app.log.2', `app.log.3'
     etc.  respectively.

`doRollover()'
     Does a rollover, as described above.

`emit(record)'
     Outputs the record to the file, catering for rollover as described
     in `setRollover()'.


File: python-lib.info,  Node: SocketHandler,  Next: DatagramHandler,  Prev: RotatingFileHandler,  Up: Handler Objects

SocketHandler
.............

The `SocketHandler' class sends logging output to a network socket. The
base class uses a TCP socket.

`SocketHandler(host, port)'
     Returns a new instance of the `SocketHandler' class intended to
     communicate with a remote machine whose address is given by HOST
     and PORT.

`close()'
     Closes the socket.

`handleError()'

`emit()'
     Pickles the record's attribute dictionary and writes it to the
     socket in binary format. If there is an error with the socket,
     silently drops the packet. If the connection was previously lost,
     re-establishes the connection.  To unpickle the record at the
     receiving end into a LogRecord, use the `makeLogRecord' function.

`handleError()'
     Handles an error which has occurred during `emit()'. The most
     likely cause is a lost connection. Closes the socket so that we
     can retry on the next event.

`makeSocket()'
     This is a factory method which allows subclasses to define the
     precise type of socket they want. The default implementation
     creates a TCP socket (`socket.SOCK_STREAM').

`makePickle(record)'
     Pickles the record's attribute dictionary in binary format with a
     length prefix, and returns it ready for transmission across the
     socket.

`send(packet)'
     Send a pickled string PACKET to the socket. This function allows
     for partial sends which can happen when the network is busy.

