This is python-api.info, produced by makeinfo version 4.3 from
python-api.texi.

October 3, 2003


File: python-api.info,  Node: Complex Numbers as Python Objects,  Prev: Complex Numbers as C Structures,  Up: Complex Number Objects

Complex Numbers as Python Objects
.................................

`PyComplexObject'
     This subtype of `PyObject' represents a Python complex number
     object.

`PyTypeObject PyComplex_Type'
     This instance of `PyTypeObject' represents the Python complex
     number type.

`int PyComplex_Check(PyObject *p)'
     Returns true if its argument is a `PyComplexObject' or a subtype
     of `PyComplexObject'.  _Changed in Python version 2.2_

`int PyComplex_CheckExact(PyObject *p)'
     Returns true if its argument is a `PyComplexObject', but not a
     subtype of `PyComplexObject'.  _Added in Python version 2.2_

`PyObject* PyComplex_FromCComplex(Py_complex v)'
     Create a new Python complex number object from a C `Py_complex'
     value.

`PyObject* PyComplex_FromDoubles(double real, double imag)'
     Returns a new `PyComplexObject' object from REAL and IMAG.

`double PyComplex_RealAsDouble(PyObject *op)'
     Returns the real part of OP as a C `double'.

`double PyComplex_ImagAsDouble(PyObject *op)'
     Returns the imaginary part of OP as a C `double'.

`Py_complex PyComplex_AsCComplex(PyObject *op)'
     Returns the `Py_complex' value of the complex number OP.


File: python-api.info,  Node: Sequence Objects,  Next: Mapping Objects,  Prev: Numeric Objects,  Up: Concrete Objects Layer

Sequence Objects
================

Generic operations on sequence objects were discussed in the previous
chapter; this section deals with the specific kinds of sequence objects
that are intrinsic to the Python language.

* Menu:

* String Objects::
* Unicode Objects::
* Buffer Objects::
* Tuple Objects::
* List Objects::


File: python-api.info,  Node: String Objects,  Next: Unicode Objects,  Prev: Sequence Objects,  Up: Sequence Objects

String Objects
--------------

These functions raise `TypeError' when expecting a string parameter and
are called with a non-string parameter.

`PyStringObject'
     This subtype of `PyObject' represents a Python string object.

`PyTypeObject PyString_Type'
     This instance of `PyTypeObject' represents the Python string type;
     it is the same object as `types.TypeType' in the Python layer.  .

`int PyString_Check(PyObject *o)'
     Returns true if the object O is a string object or an instance of
     a subtype of the string type.  _Changed in Python version 2.2_

`int PyString_CheckExact(PyObject *o)'
     Returns true if the object O is a string object, but not an
     instance of a subtype of the string type.  _Added in Python
     version 2.2_

`PyObject* PyString_FromString(const char *v)'
     Returns a new string object with the value V on success, and
     `NULL' on failure.  The parameter V must not be `NULL'; it will
     not be checked.

`PyObject* PyString_FromStringAndSize(const char *v, int len)'
     Returns a new string object with the value V and length LEN on
     success, and `NULL' on failure.  If V is `NULL', the contents of
     the string are uninitialized.

`PyObject* PyString_FromFormat(const char *format, ...)'
     Takes a C `printf()'-style FORMAT string and a variable number of
     arguments, calculates the size of the resulting Python string and
     returns a string with the values formatted into it.  The variable
     arguments must be C types and must correspond exactly to the
     format characters in the FORMAT string.  The following format
     characters are allowed:

     Format Characters      Type                   Comment
     ------                 -----                  -----
     %%                     _n/a_                  The literal %
                                                   character.
     %c                     int                    A single character,
                                                   represented as an C
                                                   int.
     %d                     int                    Exactly equivalent to
                                                   `printf("%d")'.
     %ld                    long                   Exactly equivalent to
                                                   `printf("%ld")'.
     %i                     int                    Exactly equivalent to
                                                   `printf("%i")'.
     %x                     int                    Exactly equivalent to
                                                   `printf("%x")'.
     %s                     char*                  A null-terminated C
                                                   character array.
     %p                     void*                  The hex
                                                   representation of a C
                                                   pointer. Mostly
                                                   equivalent to
                                                   `printf("%p")' except
                                                   that it is guaranteed
                                                   to start with the
                                                   literal `0x'
                                                   regardless of what
                                                   the platform's
                                                   `printf' yields.

`PyObject* PyString_FromFormatV(const char *format, va_list vargs)'
     Identical to `PyString_FromFormat()' except that it takes exactly
     two arguments.

`int PyString_Size(PyObject *string)'
     Returns the length of the string in string object STRING.

`int PyString_GET_SIZE(PyObject *string)'
     Macro form of `PyString_Size()' but without error checking.

`char* PyString_AsString(PyObject *string)'
     Returns a NUL-terminated representation of the contents of STRING.
     The pointer refers to the internal buffer of STRING, not a copy.
     The data must not be modified in any way, unless the string was
     just created using `PyString_FromStringAndSize(NULL, SIZE)'.  It
     must not be deallocated.  If STRING is a Unicode object, this
     function computes the default encoding of STRING and operates on
     that.  If STRING is not a string object at all,
     `PyString_AsString()' returns `NULL' and raises `TypeError'.

`char* PyString_AS_STRING(PyObject *string)'
     Macro form of `PyString_AsString()' but without error checking.
     Only string objects are supported; no Unicode objects should be
     passed.

`int PyString_AsStringAndSize(PyObject *obj, char **buffer, int *length)'
     Returns a NUL-terminated representation of the contents of the
     object OBJ through the output variables BUFFER and LENGTH.

     The function accepts both string and Unicode objects as input. For
     Unicode objects it returns the default encoded version of the
     object.  If LENGTH is `NULL', the resulting buffer may not contain
     NUL characters; if it does, the function returns `-1' and a
     `TypeError' is raised.

     The buffer refers to an internal string buffer of OBJ, not a copy.
     The data must not be modified in any way, unless the string was
     just created using `PyString_FromStringAndSize(NULL, SIZE)'.  It
     must not be deallocated.  If STRING is a Unicode object, this
     function computes the default encoding of STRING and operates on
     that.  If STRING is not a string object at all,
     `PyString_AsString()' returns `NULL' and raises `TypeError'.

`void PyString_Concat(PyObject **string, PyObject *newpart)'
     Creates a new string object in *STRING containing the contents of
     NEWPART appended to STRING; the caller will own the new reference.
     The reference to the old value of STRING will be stolen.  If the
     new string cannot be created, the old reference to STRING will
     still be discarded and the value of *STRING will be set to `NULL';
     the appropriate exception will be set.

`void PyString_ConcatAndDel(PyObject **string, PyObject *newpart)'
     Creates a new string object in *STRING containing the contents of
     NEWPART appended to STRING.  This version decrements the reference
     count of NEWPART.

`int _PyString_Resize(PyObject **string, int newsize)'
     A way to resize a string object even though it is "immutable".
     Only use this to build up a brand new string object; don't use this
     if the string may already be known in other parts of the code.  It
     is an error to call this function if the refcount on the input
     string object is not one.  Pass the address of an existing string
     object as an lvalue (it may be written into), and the new size
     desired.  On success, *STRING holds the resized string object and
     `0' is returned; the address in *STRING may differ from its input
     value.  If the reallocation fails, the original string object at
     *STRING is deallocated, *STRING is set to `NULL', a memory
     exception is set, and `-1' is returned.

`PyObject* PyString_Format(PyObject *format, PyObject *args)'
     Returns a new string object from FORMAT and ARGS.  Analogous to
     `FORMAT % ARGS'.  The ARGS argument must be a tuple.

`void PyString_InternInPlace(PyObject **string)'
     Intern the argument *STRING in place.  The argument must be the
     address of a pointer variable pointing to a Python string object.
     If there is an existing interned string that is the same as
     *STRING, it sets *STRING to it (decrementing the reference count
     of the old string object and incrementing the reference count of
     the interned string object), otherwise it leaves *STRING alone and
     interns it (incrementing its reference count).  (Clarification:
     even though there is a lot of talk about reference counts, think
     of this function as reference-count-neutral; you own the object
     after the call if and only if you owned it before the call.)

`PyObject* PyString_InternFromString(const char *v)'
     A combination of `PyString_FromString()' and
     `PyString_InternInPlace()', returning either a new string object
     that has been interned, or a new ("owned") reference to an earlier
     interned string object with the same value.

`PyObject* PyString_Decode(const char *s, int size, const char *encoding, const char *errors)'
     Creates an object by decoding SIZE bytes of the encoded buffer S
     using the codec registered for ENCODING.  ENCODING and ERRORS have
     the same meaning as the parameters of the same name in the
     `unicode()' built-in function.  The codec to be used is looked up
     using the Python codec registry.  Returns `NULL' if an exception
     was raised by the codec.

`PyObject* PyString_AsDecodedObject(PyObject *str, const char *encoding, const char *errors)'
     Decodes a string object by passing it to the codec registered for
     ENCODING and returns the result as Python object. ENCODING and
     ERRORS have the same meaning as the parameters of the same name in
     the string `encode()' method.  The codec to be used is looked up
     using the Python codec registry.  Returns `NULL' if an exception
     was raised by the codec.

`PyObject* PyString_Encode(const char *s, int size, const char *encoding, const char *errors)'
     Encodes the `char' buffer of the given size by passing it to the
     codec registered for ENCODING and returns a Python object.
     ENCODING and ERRORS have the same meaning as the parameters of the
     same name in the string `encode()' method.  The codec to be used
     is looked up using the Python codec registry.  Returns `NULL' if
     an exception was raised by the codec.

`PyObject* PyString_AsEncodedObject(PyObject *str, const char *encoding, const char *errors)'
     Encodes a string object using the codec registered for ENCODING
     and returns the result as Python object.  ENCODING and ERRORS have
     the same meaning as the parameters of the same name in the string
     `encode()' method.  The codec to be used is looked up using the
     Python codec registry.  Returns `NULL' if an exception was raised
     by the codec.


File: python-api.info,  Node: Unicode Objects,  Next: Buffer Objects,  Prev: String Objects,  Up: Sequence Objects

Unicode Objects
---------------

These are the basic Unicode object types used for the Unicode
implementation in Python:

`Py_UNICODE'
     This type represents a 16-bit unsigned storage type which is used
     by Python internally as basis for holding Unicode ordinals.  On
     platforms where `wchar_t' is available and also has 16-bits,
     `Py_UNICODE' is a typedef alias for `wchar_t' to enhance native
     platform compatibility.  On all other platforms, `Py_UNICODE' is a
     typedef alias for `unsigned short'.

`PyUnicodeObject'
     This subtype of `PyObject' represents a Python Unicode object.

`PyTypeObject PyUnicode_Type'
     This instance of `PyTypeObject' represents the Python Unicode type.

The following APIs are really C macros and can be used to do fast
checks and to access internal read-only data of Unicode objects:

`int PyUnicode_Check(PyObject *o)'
     Returns true if the object O is a Unicode object or an instance of
     a Unicode subtype.  _Changed in Python version 2.2_

`int PyUnicode_CheckExact(PyObject *o)'
     Returns true if the object O is a Unicode object, but not an
     instance of a subtype.  _Added in Python version 2.2_

`int PyUnicode_GET_SIZE(PyObject *o)'
     Returns the size of the object.  O has to be a `PyUnicodeObject'
     (not checked).

`int PyUnicode_GET_DATA_SIZE(PyObject *o)'
     Returns the size of the object's internal buffer in bytes.  O has
     to be a `PyUnicodeObject' (not checked).

`Py_UNICODE* PyUnicode_AS_UNICODE(PyObject *o)'
     Returns a pointer to the internal `Py_UNICODE' buffer of the
     object.  O has to be a `PyUnicodeObject' (not checked).

`const char* PyUnicode_AS_DATA(PyObject *o)'
     Returns a pointer to the internal buffer of the object.  O has to
     be a `PyUnicodeObject' (not checked).

Unicode provides many different character properties. The most often
needed ones are available through these macros which are mapped to C
functions depending on the Python configuration.

`int Py_UNICODE_ISSPACE(Py_UNICODE ch)'
     Returns 1/0 depending on whether CH is a whitespace character.

`int Py_UNICODE_ISLOWER(Py_UNICODE ch)'
     Returns 1/0 depending on whether CH is a lowercase character.

`int Py_UNICODE_ISUPPER(Py_UNICODE ch)'
     Returns 1/0 depending on whether CH is an uppercase character.

`int Py_UNICODE_ISTITLE(Py_UNICODE ch)'
     Returns 1/0 depending on whether CH is a titlecase character.

`int Py_UNICODE_ISLINEBREAK(Py_UNICODE ch)'
     Returns 1/0 depending on whether CH is a linebreak character.

`int Py_UNICODE_ISDECIMAL(Py_UNICODE ch)'
     Returns 1/0 depending on whether CH is a decimal character.

`int Py_UNICODE_ISDIGIT(Py_UNICODE ch)'
     Returns 1/0 depending on whether CH is a digit character.

`int Py_UNICODE_ISNUMERIC(Py_UNICODE ch)'
     Returns 1/0 depending on whether CH is a numeric character.

`int Py_UNICODE_ISALPHA(Py_UNICODE ch)'
     Returns 1/0 depending on whether CH is an alphabetic character.

`int Py_UNICODE_ISALNUM(Py_UNICODE ch)'
     Returns 1/0 depending on whether CH is an alphanumeric character.

These APIs can be used for fast direct character conversions:

`Py_UNICODE Py_UNICODE_TOLOWER(Py_UNICODE ch)'
     Returns the character CH converted to lower case.

`Py_UNICODE Py_UNICODE_TOUPPER(Py_UNICODE ch)'
     Returns the character CH converted to upper case.

`Py_UNICODE Py_UNICODE_TOTITLE(Py_UNICODE ch)'
     Returns the character CH converted to title case.

`int Py_UNICODE_TODECIMAL(Py_UNICODE ch)'
     Returns the character CH converted to a decimal positive integer.
     Returns `-1' if this is not possible.  Does not raise exceptions.

`int Py_UNICODE_TODIGIT(Py_UNICODE ch)'
     Returns the character CH converted to a single digit integer.
     Returns `-1' if this is not possible.  Does not raise exceptions.

`double Py_UNICODE_TONUMERIC(Py_UNICODE ch)'
     Returns the character CH converted to a (positive) double.
     Returns `-1.0' if this is not possible.  Does not raise exceptions.

To create Unicode objects and access their basic sequence properties,
use these APIs:

`PyObject* PyUnicode_FromUnicode(const Py_UNICODE *u, int size)'
     Create a Unicode Object from the Py_UNICODE buffer U of the given
     size. U may be `NULL' which causes the contents to be undefined.
     It is the user's responsibility to fill in the needed data.  The
     buffer is copied into the new object. If the buffer is not `NULL',
     the return value might be a shared object. Therefore, modification
     of the resulting Unicode object is only allowed when U is `NULL'.

`Py_UNICODE* PyUnicode_AsUnicode(PyObject *unicode)'
     Return a read-only pointer to the Unicode object's internal
     `Py_UNICODE' buffer, `NULL' if UNICODE is not a Unicode object.

`int PyUnicode_GetSize(PyObject *unicode)'
     Return the length of the Unicode object.

`PyObject* PyUnicode_FromEncodedObject(PyObject *obj, const char *encoding, const char *errors)'
     Coerce an encoded object OBJ to an Unicode object and return a
     reference with incremented refcount.

     Coercion is done in the following way:

       1. Unicode objects are passed back as-is with incremented
          refcount. _Note:_ These cannot be decoded; passing a
          non-`NULL' value for encoding will result in a `TypeError'.

       2. String and other char buffer compatible objects are decoded
          according to the given encoding and using the error handling
          defined by errors.  Both can be `NULL' to have the interface
          use the default values (see the next section for details).

       3. All other objects cause an exception.

     The API returns `NULL' if there was an error.  The caller is
     responsible for decref'ing the returned objects.

`PyObject* PyUnicode_FromObject(PyObject *obj)'
     Shortcut for `PyUnicode_FromEncodedObject(obj, NULL, "strict")'
     which is used throughout the interpreter whenever coercion to
     Unicode is needed.

If the platform supports `wchar_t' and provides a header file wchar.h,
Python can interface directly to this type using the following
functions. Support is optimized if Python's own `Py_UNICODE' type is
identical to the system's `wchar_t'.

`PyObject* PyUnicode_FromWideChar(const wchar_t *w, int size)'
     Create a Unicode object from the `wchar_t' buffer W of the given
     size.  Returns `NULL' on failure.

`int PyUnicode_AsWideChar(PyUnicodeObject *unicode, wchar_t *w, int size)'
     Copies the Unicode object contents into the `wchar_t' buffer W.
     At most SIZE `wchar_t' characters are copied.  Returns the number
     of `wchar_t' characters copied or -1 in case of an error.

* Menu:

* Built-in Codecs::
* Methods and Slot Functions::


File: python-api.info,  Node: Built-in Codecs,  Next: Methods and Slot Functions,  Prev: Unicode Objects,  Up: Unicode Objects

Built-in Codecs
...............

Python provides a set of builtin codecs which are written in C for
speed. All of these codecs are directly usable via the following
functions.

Many of the following APIs take two arguments encoding and errors.
These parameters encoding and errors have the same semantics as the
ones of the builtin unicode() Unicode object constructor.

Setting encoding to `NULL' causes the default encoding to be used which
is ASCII.  The file system calls should use
`Py_FileSystemDefaultEncoding' as the encoding for file names. This
variable should be treated as read-only: On some systems, it will be a
pointer to a static string, on others, it will change at run-time, e.g.
when the application invokes setlocale.

Error handling is set by errors which may also be set to `NULL' meaning
to use the default handling defined for the codec.  Default error
handling for all builtin codecs is "strict" (`ValueError' is raised).

The codecs all use a similar interface.  Only deviation from the
following generic ones are documented for simplicity.

These are the generic codec APIs:

`PyObject* PyUnicode_Decode(const char *s, int size, const char *encoding, const char *errors)'
     Create a Unicode object by decoding SIZE bytes of the encoded
     string S.  ENCODING and ERRORS have the same meaning as the
     parameters of the same name in the `unicode()' builtin function.
     The codec to be used is looked up using the Python codec registry.
     Returns `NULL' if an exception was raised by the codec.

`PyObject* PyUnicode_Encode(const Py_UNICODE *s, int size, const char *encoding, const char *errors)'
     Encodes the `Py_UNICODE' buffer of the given size and returns a
     Python string object.  ENCODING and ERRORS have the same meaning
     as the parameters of the same name in the Unicode `encode()'
     method.  The codec to be used is looked up using the Python codec
     registry.  Returns `NULL' if an exception was raised by the codec.

`PyObject* PyUnicode_AsEncodedString(PyObject *unicode, const char *encoding, const char *errors)'
     Encodes a Unicode object and returns the result as Python string
     object. ENCODING and ERRORS have the same meaning as the
     parameters of the same name in the Unicode `encode()' method.  The
     codec to be used is looked up using the Python codec registry.
     Returns `NULL' if an exception was raised by the codec.

These are the UTF-8 codec APIs:

`PyObject* PyUnicode_DecodeUTF8(const char *s, int size, const char *errors)'
     Creates a Unicode object by decoding SIZE bytes of the UTF-8
     encoded string S. Returns `NULL' if an exception was raised by the
     codec.

`PyObject* PyUnicode_EncodeUTF8(const Py_UNICODE *s, int size, const char *errors)'
     Encodes the `Py_UNICODE' buffer of the given size using UTF-8 and
     returns a Python string object.  Returns `NULL' if an exception
     was raised by the codec.

`PyObject* PyUnicode_AsUTF8String(PyObject *unicode)'
     Encodes a Unicode objects using UTF-8 and returns the result as
     Python string object.  Error handling is "strict".  Returns `NULL'
     if an exception was raised by the codec.

These are the UTF-16 codec APIs:

`PyObject* PyUnicode_DecodeUTF16(const char *s, int size, const char *errors, int *byteorder)'
     Decodes LENGTH bytes from a UTF-16 encoded buffer string and
     returns the corresponding Unicode object.  ERRORS (if non-`NULL')
     defines the error handling. It defaults to "strict".

     If BYTEORDER is non-`NULL', the decoder starts decoding using the
     given byte order:

             *byteorder == -1: little endian
             *byteorder == 0:  native order
             *byteorder == 1:  big endian

     and then switches according to all byte order marks (BOM) it finds
     in the input data.  BOMs are not copied into the resulting Unicode
     string.  After completion, *BYTEORDER is set to the current byte
     order at the end of input data.

     If BYTEORDER is `NULL', the codec starts in native order mode.

     Returns `NULL' if an exception was raised by the codec.

`PyObject* PyUnicode_EncodeUTF16(const Py_UNICODE *s, int size, const char *errors, int byteorder)'
     Returns a Python string object holding the UTF-16 encoded value of
     the Unicode data in S.  If BYTEORDER is not `0', output is written
     according to the following byte order:

             byteorder == -1: little endian
             byteorder == 0:  native byte order (writes a BOM mark)
             byteorder == 1:  big endian

     If byteorder is `0', the output string will always start with the
     Unicode BOM mark (U+FEFF). In the other two modes, no BOM mark is
     prepended.

     Note that `Py_UNICODE' data is being interpreted as UTF-16 reduced
     to UCS-2. This trick makes it possible to add full UTF-16
     capabilities at a later point without comprimising the APIs.

     Returns `NULL' if an exception was raised by the codec.

`PyObject* PyUnicode_AsUTF16String(PyObject *unicode)'
     Returns a Python string using the UTF-16 encoding in native byte
     order. The string always starts with a BOM mark.  Error handling is
     "strict".  Returns `NULL' if an exception was raised by the codec.

These are the "Unicode Esacpe" codec APIs:

`PyObject* PyUnicode_DecodeUnicodeEscape(const char *s, int size, const char *errors)'
     Creates a Unicode object by decoding SIZE bytes of the
     Unicode-Escape encoded string S.  Returns `NULL' if an exception
     was raised by the codec.

`PyObject* PyUnicode_EncodeUnicodeEscape(const Py_UNICODE *s, int size, const char *errors)'
     Encodes the `Py_UNICODE' buffer of the given size using
     Unicode-Escape and returns a Python string object.  Returns `NULL'
     if an exception was raised by the codec.

`PyObject* PyUnicode_AsUnicodeEscapeString(PyObject *unicode)'
     Encodes a Unicode objects using Unicode-Escape and returns the
     result as Python string object.  Error handling is "strict".
     Returns `NULL' if an exception was raised by the codec.

These are the "Raw Unicode Esacpe" codec APIs:

`PyObject* PyUnicode_DecodeRawUnicodeEscape(const char *s, int size, const char *errors)'
     Creates a Unicode object by decoding SIZE bytes of the
     Raw-Unicode-Esacpe encoded string S.  Returns `NULL' if an
     exception was raised by the codec.

`PyObject* PyUnicode_EncodeRawUnicodeEscape(const Py_UNICODE *s, int size, const char *errors)'
     Encodes the `Py_UNICODE' buffer of the given size using
     Raw-Unicode-Escape and returns a Python string object.  Returns
     `NULL' if an exception was raised by the codec.

`PyObject* PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)'
     Encodes a Unicode objects using Raw-Unicode-Escape and returns the
     result as Python string object. Error handling is "strict".
     Returns `NULL' if an exception was raised by the codec.

These are the Latin-1 codec APIs: Latin-1 corresponds to the first 256
Unicode ordinals and only these are accepted by the codecs during
encoding.

`PyObject* PyUnicode_DecodeLatin1(const char *s, int size, const char *errors)'
     Creates a Unicode object by decoding SIZE bytes of the Latin-1
     encoded string S.  Returns `NULL' if an exception was raised by
     the codec.

`PyObject* PyUnicode_EncodeLatin1(const Py_UNICODE *s, int size, const char *errors)'
     Encodes the `Py_UNICODE' buffer of the given size using Latin-1
     and returns a Python string object.  Returns `NULL' if an
     exception was raised by the codec.

`PyObject* PyUnicode_AsLatin1String(PyObject *unicode)'
     Encodes a Unicode objects using Latin-1 and returns the result as
     Python string object.  Error handling is "strict".  Returns `NULL'
     if an exception was raised by the codec.

These are the ASCII codec APIs.  Only 7-bit ASCII data is accepted. All
other codes generate errors.

`PyObject* PyUnicode_DecodeASCII(const char *s, int size, const char *errors)'
     Creates a Unicode object by decoding SIZE bytes of the ASCII
     encoded string S.  Returns `NULL' if an exception was raised by
     the codec.

`PyObject* PyUnicode_EncodeASCII(const Py_UNICODE *s, int size, const char *errors)'
     Encodes the `Py_UNICODE' buffer of the given size using ASCII and
     returns a Python string object.  Returns `NULL' if an exception
     was raised by the codec.

`PyObject* PyUnicode_AsASCIIString(PyObject *unicode)'
     Encodes a Unicode objects using ASCII and returns the result as
     Python string object.  Error handling is "strict".  Returns `NULL'
     if an exception was raised by the codec.

These are the mapping codec APIs:

This codec is special in that it can be used to implement many
different codecs (and this is in fact what was done to obtain most of
the standard codecs included in the `encodings' package). The codec
uses mapping to encode and decode characters.

Decoding mappings must map single string characters to single Unicode
characters, integers (which are then interpreted as Unicode ordinals)
or None (meaning "undefined mapping" and causing an error).

Encoding mappings must map single Unicode characters to single string
characters, integers (which are then interpreted as Latin-1 ordinals)
or None (meaning "undefined mapping" and causing an error).

The mapping objects provided must only support the __getitem__ mapping
interface.

If a character lookup fails with a LookupError, the character is copied
as-is meaning that its ordinal value will be interpreted as Unicode or
Latin-1 ordinal resp. Because of this, mappings only need to contain
those mappings which map characters to different code points.

`PyObject* PyUnicode_DecodeCharmap(const char *s, int size, PyObject *mapping, const char *errors)'
     Creates a Unicode object by decoding SIZE bytes of the encoded
     string S using the given MAPPING object.  Returns `NULL' if an
     exception was raised by the codec.

`PyObject* PyUnicode_EncodeCharmap(const Py_UNICODE *s, int size, PyObject *mapping, const char *errors)'
     Encodes the `Py_UNICODE' buffer of the given size using the given
     MAPPING object and returns a Python string object.  Returns `NULL'
     if an exception was raised by the codec.

`PyObject* PyUnicode_AsCharmapString(PyObject *unicode, PyObject *mapping)'
     Encodes a Unicode objects using the given MAPPING object and
     returns the result as Python string object.  Error handling is
     "strict".  Returns `NULL' if an exception was raised by the codec.

The following codec API is special in that maps Unicode to Unicode.

`PyObject* PyUnicode_TranslateCharmap(const Py_UNICODE *s, int size, PyObject *table, const char *errors)'
     Translates a `Py_UNICODE' buffer of the given length by applying a
     character mapping TABLE to it and returns the resulting Unicode
     object.  Returns `NULL' when an exception was raised by the codec.

     The MAPPING table must map Unicode ordinal integers to Unicode
     ordinal integers or None (causing deletion of the character).

     Mapping tables need only provide the method{__getitem__()}
     interface; dictionaries and sequences work well.  Unmapped
     character ordinals (ones which cause a `LookupError') are left
     untouched and are copied as-is.

These are the MBCS codec APIs. They are currently only available on
Windows and use the Win32 MBCS converters to implement the conversions.
Note that MBCS (or DBCS) is a class of encodings, not just one.  The
target encoding is defined by the user settings on the machine running
the codec.

`PyObject* PyUnicode_DecodeMBCS(const char *s, int size, const char *errors)'
     Creates a Unicode object by decoding SIZE bytes of the MBCS
     encoded string S.  Returns `NULL' if an exception was raised by
     the codec.

`PyObject* PyUnicode_EncodeMBCS(const Py_UNICODE *s, int size, const char *errors)'
     Encodes the `Py_UNICODE' buffer of the given size using MBCS and
     returns a Python string object.  Returns `NULL' if an exception
     was raised by the codec.

`PyObject* PyUnicode_AsMBCSString(PyObject *unicode)'
     Encodes a Unicode objects using MBCS and returns the result as
     Python string object.  Error handling is "strict".  Returns `NULL'
     if an exception was raised by the codec.


File: python-api.info,  Node: Methods and Slot Functions,  Prev: Built-in Codecs,  Up: Unicode Objects

Methods and Slot Functions
..........................

The following APIs are capable of handling Unicode objects and strings
on input (we refer to them as strings in the descriptions) and return
Unicode objects or integers as apporpriate.

They all return `NULL' or `-1' if an exception occurs.

`PyObject* PyUnicode_Concat(PyObject *left, PyObject *right)'
     Concat two strings giving a new Unicode string.

`PyObject* PyUnicode_Split(PyObject *s, PyObject *sep, int maxsplit)'
     Split a string giving a list of Unicode strings.  If sep is `NULL',
     splitting will be done at all whitespace substrings.  Otherwise,
     splits occur at the given separator.  At most MAXSPLIT splits will
     be done.  If negative, no limit is set.  Separators are not
     included in the resulting list.

`PyObject* PyUnicode_Splitlines(PyObject *s, int keepend)'
     Split a Unicode string at line breaks, returning a list of Unicode
     strings.  CRLF is considered to be one line break.  If KEEPEND is
     0, the Line break characters are not included in the resulting
     strings.

`PyObject* PyUnicode_Translate(PyObject *str, PyObject *table, const char *errors)'
     Translate a string by applying a character mapping table to it and
     return the resulting Unicode object.

     The mapping table must map Unicode ordinal integers to Unicode
     ordinal integers or None (causing deletion of the character).

     Mapping tables need only provide the `__getitem__()' interface;
     dictionaries and sequences work well.  Unmapped character ordinals
     (ones which cause a `LookupError') are left untouched and are
     copied as-is.

     ERRORS has the usual meaning for codecs. It may be `NULL' which
     indicates to use the default error handling.

`PyObject* PyUnicode_Join(PyObject *separator, PyObject *seq)'
     Join a sequence of strings using the given separator and return the
     resulting Unicode string.

`PyObject* PyUnicode_Tailmatch(PyObject *str, PyObject *substr, int start, int end, int direction)'
     Return 1 if SUBSTR matches STR[START:END] at the given tail end
     (DIRECTION == -1 means to do a prefix match, DIRECTION == 1 a
     suffix match), 0 otherwise.

`int PyUnicode_Find(PyObject *str, PyObject *substr, int start, int end, int direction)'
     Return the first position of SUBSTR in STR[START:END] using the
     given DIRECTION (DIRECTION == 1 means to do a forward search,
     DIRECTION == -1 a backward search).  The return value is the index
     of the first match; a value of `-1' indicates that no match was
     found, and `-2' indicates that an error occurred and an exception
     has been set.

`int PyUnicode_Count(PyObject *str, PyObject *substr, int start, int end)'
     Return the number of non-overlapping occurrences of SUBSTR in
     `STR[START:END]'.  Returns `-1' if an error occurred.

`PyObject* PyUnicode_Replace(PyObject *str, PyObject *substr, PyObject *replstr, int maxcount)'
     Replace at most MAXCOUNT occurrences of SUBSTR in STR with REPLSTR
     and return the resulting Unicode object.  MAXCOUNT == -1 means
     replace all occurrences.

`int PyUnicode_Compare(PyObject *left, PyObject *right)'
     Compare two strings and return -1, 0, 1 for less than, equal, and
     greater than, respectively.

`PyObject* PyUnicode_Format(PyObject *format, PyObject *args)'
     Returns a new string object from FORMAT and ARGS; this is
     analogous to `FORMAT % ARGS'.  The ARGS argument must be a tuple.

`int PyUnicode_Contains(PyObject *container, PyObject *element)'
     Checks whether ELEMENT is contained in CONTAINER and returns true
     or false accordingly.

     ELEMENT has to coerce to a one element Unicode string. `-1' is
     returned if there was an error.


File: python-api.info,  Node: Buffer Objects,  Next: Tuple Objects,  Prev: Unicode Objects,  Up: Sequence Objects

Buffer Objects
--------------

Python objects implemented in C can export a group of functions called
the "buffer  interface."  These functions can be used by an object to
expose its data in a raw, byte-oriented format. Clients of the object
can use the buffer interface to access the object data directly,
without needing to copy it first.

Two examples of objects that support the buffer interface are strings
and arrays. The string object exposes the character contents in the
buffer interface's byte-oriented form. An array can also expose its
contents, but it should be noted that array elements may be multi-byte
values.

An example user of the buffer interface is the file object's `write()'
method. Any object that can export a series of bytes through the buffer
interface can be written to a file. There are a number of format codes
to `PyArg_ParseTuple()' that operate against an object's buffer
interface, returning data from the target object.

More information on the buffer interface is provided in the section
"Buffer Object Structures" (section~*Note Buffer Object Structures::),
under the description for `PyBufferProcs' .

A "buffer object" is defined in the `bufferobject.h' header (included
by `Python.h'). These objects look very similar to string objects at
the Python programming level: they support slicing, indexing,
concatenation, and some other standard string operations. However,
their data can come from one of two sources: from a block of memory, or
from another object which exports the buffer interface.

Buffer objects are useful as a way to expose the data from another
object's buffer interface to the Python programmer. They can also be
used as a zero-copy slicing mechanism. Using their ability to reference
a block of memory, it is possible to expose any data to the Python
programmer quite easily. The memory could be a large, constant array in
a C extension, it could be a raw block of memory for manipulation
before passing to an operating system library, or it could be used to
pass around structured data in its native, in-memory format.

`PyBufferObject'
     This subtype of `PyObject' represents a buffer object.

`PyTypeObject PyBuffer_Type'
     The instance of `PyTypeObject' which represents the Python buffer
     type; it is the same object as `types.BufferType' in the Python
     layer.  .

`int Py_END_OF_BUFFER'
     This constant may be passed as the SIZE parameter to
     `PyBuffer_FromObject()' or `PyBuffer_FromReadWriteObject()'.  It
     indicates that the new `PyBufferObject' should refer to BASE
     object from the specified OFFSET to the end of its exported
     buffer.  Using this enables the caller to avoid querying the BASE
     object for its length.

`int PyBuffer_Check(PyObject *p)'
     Return true if the argument has type `PyBuffer_Type'.

`PyObject* PyBuffer_FromObject(PyObject *base, int offset, int size)'
     Return a new read-only buffer object.  This raises `TypeError' if
     BASE doesn't support the read-only buffer protocol or doesn't
     provide exactly one buffer segment, or it raises `ValueError' if
     OFFSET is less than zero. The buffer will hold a reference to the
     BASE object, and the buffer's contents will refer to the BASE
     object's buffer interface, starting as position OFFSET and
     extending for SIZE bytes. If SIZE is `Py_END_OF_BUFFER', then the
     new buffer's contents extend to the length of the BASE object's
     exported buffer data.

`PyObject* PyBuffer_FromReadWriteObject(PyObject *base, int offset, int size)'
     Return a new writable buffer object.  Parameters and exceptions are
     similar to those for `PyBuffer_FromObject()'.  If the BASE object
     does not export the writeable buffer protocol, then `TypeError' is
     raised.

`PyObject* PyBuffer_FromMemory(void *ptr, int size)'
     Return a new read-only buffer object that reads from a specified
     location in memory, with a specified size.  The caller is
     responsible for ensuring that the memory buffer, passed in as PTR,
     is not deallocated while the returned buffer object exists.
     Raises `ValueError' if SIZE is less than zero.  Note that
     `Py_END_OF_BUFFER' may _not_ be passed for the SIZE parameter;
     `ValueError' will be raised in that case.

`PyObject* PyBuffer_FromReadWriteMemory(void *ptr, int size)'
     Similar to `PyBuffer_FromMemory()', but the returned buffer is
     writable.

`PyObject* PyBuffer_New(int size)'
     Returns a new writable buffer object that maintains its own memory
     buffer of SIZE bytes.  `ValueError' is returned if SIZE is not
     zero or positive.


File: python-api.info,  Node: Tuple Objects,  Next: List Objects,  Prev: Buffer Objects,  Up: Sequence Objects

Tuple Objects
-------------

`PyTupleObject'
     This subtype of `PyObject' represents a Python tuple object.

`PyTypeObject PyTuple_Type'
     This instance of `PyTypeObject' represents the Python tuple type;
     it is the same object as `types.TupleType' in the Python layer.  .

`int PyTuple_Check(PyObject *p)'
     Return true if P is a tuple object or an instance of a subtype of
     the tuple type.  _Changed in Python version 2.2_

`int PyTuple_CheckExact(PyObject *p)'
     Return true if P is a tuple object, but not an instance of a
     subtype of the tuple type.  _Added in Python version 2.2_

`PyObject* PyTuple_New(int len)'
     Return a new tuple object of size LEN, or `NULL' on failure.

`int PyTuple_Size(PyObject *p)'
     Takes a pointer to a tuple object, and returns the size of that
     tuple.

`int PyTuple_GET_SIZE(PyObject *p)'
     Return the size of the tuple P, which must be non-`NULL' and point
     to a tuple; no error checking is performed.

`PyObject* PyTuple_GetItem(PyObject *p, int pos)'
     Returns the object at position POS in the tuple pointed to by P.
     If POS is out of bounds, returns `NULL' and sets an `IndexError'
     exception.

`PyObject* PyTuple_GET_ITEM(PyObject *p, int pos)'
     Like `PyTuple_GetItem()', but does no checking of its arguments.

`PyObject* PyTuple_GetSlice(PyObject *p, int low, int high)'
     Takes a slice of the tuple pointed to by P from LOW to HIGH and
     returns it as a new tuple.

`int PyTuple_SetItem(PyObject *p, int pos, PyObject *o)'
     Inserts a reference to object O at position POS of the tuple
     pointed to by P. It returns `0' on success.  _Note:_ This function
     "steals" a reference to O.

`void PyTuple_SET_ITEM(PyObject *p, int pos, PyObject *o)'
     Like `PyTuple_SetItem()', but does no error checking, and should
     _only_ be used to fill in brand new tuples.  _Note:_ This function
     "steals" a reference to O.

`int _PyTuple_Resize(PyObject **p, int newsize)'
     Can be used to resize a tuple.  NEWSIZE will be the new length of
     the tuple.  Because tuples are _supposed_ to be immutable, this
     should only be used if there is only one reference to the object.
     Do _not_ use this if the tuple may already be known to some other
     part of the code.  The tuple will always grow or shrink at the
     end.  Think of this as destroying the old tuple and creating a new
     one, only more efficiently.  Returns `0' on success.  Client code
     should never assume that the resulting value of `*P' will be the
     same as before calling this function.  If the object referenced by
     `*P' is replaced, the original `*P' is destroyed.  On failure,
     returns `-1' and sets `*P' to `NULL', and raises `MemoryError' or
     `SystemError'.  _Changed in Python version 2.2_


File: python-api.info,  Node: List Objects,  Prev: Tuple Objects,  Up: Sequence Objects

List Objects
------------

`PyListObject'
     This subtype of `PyObject' represents a Python list object.

`PyTypeObject PyList_Type'
     This instance of `PyTypeObject' represents the Python list type.
     This is the same object as `types.ListType'.

`int PyList_Check(PyObject *p)'
     Returns true if its argument is a `PyListObject'.

`PyObject* PyList_New(int len)'
     Returns a new list of length LEN on success, or `NULL' on failure.

`int PyList_Size(PyObject *list)'
     Returns the length of the list object in LIST; this is equivalent
     to `len(LIST)' on a list object.

`int PyList_GET_SIZE(PyObject *list)'
     Macro form of `PyList_Size()' without error checking.

`PyObject* PyList_GetItem(PyObject *list, int index)'
     Returns the object at position POS in the list pointed to by P.
     If POS is out of bounds, returns `NULL' and sets an `IndexError'
     exception.

`PyObject* PyList_GET_ITEM(PyObject *list, int i)'
     Macro form of `PyList_GetItem()' without error checking.

`int PyList_SetItem(PyObject *list, int index, PyObject *item)'
     Sets the item at index INDEX in list to ITEM.  Returns `0' on
     success or `-1' on failure.  _Note:_ This function "steals" a
     reference to ITEM and discards a reference to an item already in
     the list at the affected position.

`void PyList_SET_ITEM(PyObject *list, int i, PyObject *o)'
     Macro form of `PyList_SetItem()' without error checking.  This is
     normally only used to fill in new lists where there is no previous
     content.  _Note:_ This function "steals" a reference to ITEM, and,
     unlike `PyList_SetItem()', does _not_ discard a reference to any
     item that it being replaced; any reference in LIST at position I
     will be leaked.

`int PyList_Insert(PyObject *list, int index, PyObject *item)'
     Inserts the item ITEM into list LIST in front of index INDEX.
     Returns `0' if successful; returns `-1' and raises an exception if
     unsuccessful.  Analogous to `LIST.insert(INDEX, ITEM)'.

`int PyList_Append(PyObject *list, PyObject *item)'
     Appends the object ITEM at the end of list LIST.  Returns `0' if
     successful; returns `-1' and sets an exception if unsuccessful.
     Analogous to `LIST.append(ITEM)'.

`PyObject* PyList_GetSlice(PyObject *list, int low, int high)'
     Returns a list of the objects in LIST containing the objects
     _between_ LOW and HIGH.  Returns `NULL' and sets an exception if
     unsuccessful.  Analogous to `LIST[LOW:HIGH]'.

`int PyList_SetSlice(PyObject *list, int low, int high, PyObject *itemlist)'
     Sets the slice of LIST between LOW and HIGH to the contents of
     ITEMLIST.  Analogous to `LIST[LOW:HIGH] = ITEMLIST'.  Returns `0'
     on success, `-1' on failure.

`int PyList_Sort(PyObject *list)'
     Sorts the items of LIST in place.  Returns `0' on success, `-1' on
     failure.  This is equivalent to `LIST.sort()'.

`int PyList_Reverse(PyObject *list)'
     Reverses the items of LIST in place.  Returns `0' on success, `-1'
     on failure.  This is the equivalent of `LIST.reverse()'.

`PyObject* PyList_AsTuple(PyObject *list)'
     Returns a new tuple object containing the contents of LIST;
     equivalent to `tuple(LIST)'.


File: python-api.info,  Node: Mapping Objects,  Next: Other Objects,  Prev: Sequence Objects,  Up: Concrete Objects Layer

Mapping Objects
===============

* Menu:

* Dictionary Objects::

