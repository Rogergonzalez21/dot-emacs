This is python-api.info, produced by makeinfo version 4.3 from
python-api.texi.

October 3, 2003


File: python-api.info,  Node: Standard Exceptions,  Next: Deprecation of String Exceptions,  Prev: Exception Handling,  Up: Exception Handling

Standard Exceptions
===================

All standard Python exceptions are available as global variables whose
names are `PyExc_' followed by the Python exception name.  These have
the type `PyObject*'; they are all class objects.  For completeness,
here are all the variables:

C Name                   Python Name              Notes
------                   -----                    -----
PyExc_Exception          `Exception'              (1)
PyExc_StandardError      `StandardError'          (1)
PyExc_ArithmeticError    `ArithmeticError'        (1)
PyExc_LookupError        `LookupError'            (1)
PyExc_AssertionError     `AssertionError'         
PyExc_AttributeError     `AttributeError'         
PyExc_EOFError           `EOFError'               
PyExc_EnvironmentError   `EnvironmentError'       (1)
PyExc_FloatingPointError `FloatingPointError'     
PyExc_IOError            `IOError'                
PyExc_ImportError        `ImportError'            
PyExc_IndexError         `IndexError'             
PyExc_KeyError           `KeyError'               
PyExc_KeyboardInterrupt  `KeyboardInterrupt'      
PyExc_MemoryError        `MemoryError'            
PyExc_NameError          `NameError'              
PyExc_NotImplementedError`NotImplementedError'    
PyExc_OSError            `OSError'                
PyExc_OverflowError      `OverflowError'          
PyExc_ReferenceError     `ReferenceError'         (2)
PyExc_RuntimeError       `RuntimeError'           
PyExc_SyntaxError        `SyntaxError'            
PyExc_SystemError        `SystemError'            
PyExc_SystemExit         `SystemExit'             
PyExc_TypeError          `TypeError'              
PyExc_ValueError         `ValueError'             
PyExc_WindowsError       `WindowsError'           (3)
PyExc_ZeroDivisionError  `ZeroDivisionError'      

Notes:
`(1)'
     This is a base class for other standard exceptions.

`(2)'
     This is the same as `weakref.ReferenceError'.

`(3)'
     Only defined on Windows; protect code that uses this by testing
     that the preprocessor macro `MS_WINDOWS' is defined.


File: python-api.info,  Node: Deprecation of String Exceptions,  Prev: Standard Exceptions,  Up: Exception Handling

Deprecation of String Exceptions
================================

All exceptions built into Python or provided in the standard library
are derived from `Exception'.

String exceptions are still supported in the interpreter to allow
existing code to run unmodified, but this will also change in a future
release.


File: python-api.info,  Node: Utilities,  Next: Abstract Objects Layer,  Prev: Exception Handling,  Up: Top

Utilities
*********

The functions in this chapter perform various utility tasks, ranging
from helping C code be more portable across platforms, using Python
modules from C, and parsing function arguments and constructing Python
values from C values.

* Menu:

* Operating System Utilities::
* Process Control::
* Importing Modules::
* Data marshalling support::
* Parsing arguments and building values::


File: python-api.info,  Node: Operating System Utilities,  Next: Process Control,  Prev: Utilities,  Up: Utilities

Operating System Utilities
==========================

`int Py_FdIsInteractive(FILE *fp, char *filename)'
     Return true (nonzero) if the standard I/O file FP with name
     FILENAME is deemed interactive.  This is the case for files for
     which `isatty(fileno(FP))' is true.  If the global flag
     `Py_InteractiveFlag' is true, this function also returns true if
     the FILENAME pointer is `NULL' or if the name is equal to one of
     the strings `'<stdin>'' or `'???''.

`long PyOS_GetLastModificationTime(char *filename)'
     Return the time of last modification of the file FILENAME.  The
     result is encoded in the same way as the timestamp returned by the
     standard C library function `time()'.

`void PyOS_AfterFork()'
     Function to update some internal state after a process fork; this
     should be called in the new process if the Python interpreter will
     continue to be used.  If a new executable is loaded into the new
     process, this function does not need to be called.

`int PyOS_CheckStack()'
     Return true when the interpreter runs out of stack space.  This is
     a reliable check, but is only available when `USE_STACKCHECK' is
     defined (currently on Windows using the Microsoft Visual C++
     compiler and on the Macintosh).  `USE_CHECKSTACK' will be defined
     automatically; you should never change the definition in your own
     code.

`PyOS_sighandler_t PyOS_getsig(int i)'
     Return the current signal handler for signal I.  This is a thin
     wrapper around either `sigaction()' or `signal()'.  Do not call
     those functions directly!  `PyOS_sighandler_t' is a typedef alias
     for `void (*)(int)'.

`PyOS_sighandler_t PyOS_setsig(int i, PyOS_sighandler_t h)'
     Set the signal handler for signal I to be H; return the old signal
     handler.  This is a thin wrapper around either `sigaction()' or
     `signal()'.  Do not call those functions directly!
     `PyOS_sighandler_t' is a typedef alias for `void (*)(int)'.


File: python-api.info,  Node: Process Control,  Next: Importing Modules,  Prev: Operating System Utilities,  Up: Utilities

Process Control
===============

`void Py_FatalError(const char *message)'
     Print a fatal error message and kill the process.  No cleanup is
     performed.  This function should only be invoked when a condition
     is detected that would make it dangerous to continue using the
     Python interpreter; e.g., when the object administration appears
     to be corrupted.  On UNIX, the standard C library function
     `abort()'  is called which will attempt to produce a `core' file.

`void Py_Exit(int status)'
     Exit the current process.  This calls `Py_Finalize()'  and then
     calls the standard C library function `exit(STATUS)' .

`int Py_AtExit(void (*func) ())'
     Register a cleanup function to be called by `Py_Finalize()' .  The
     cleanup function will be called with no arguments and should
     return no value.  At most 32 cleanup functions can be registered.
     When the registration is successful, `Py_AtExit()' returns `0'; on
     failure, it returns `-1'.  The cleanup function registered last is
     called first.  Each cleanup function will be called at most once.
     Since Python's internal finallization will have completed before
     the cleanup function, no Python APIs should be called by FUNC.


File: python-api.info,  Node: Importing Modules,  Next: Data marshalling support,  Prev: Process Control,  Up: Utilities

Importing Modules
=================

`PyObject* PyImport_ImportModule(char *name)'
     This is a simplified interface to `PyImport_ImportModuleEx()'
     below, leaving the GLOBALS and LOCALS arguments set to `NULL'.
     When the NAME argument contains a dot (when it specifies a
     submodule of a package), the FROMLIST argument is set to the list
     `['*']' so that the return value is the named module rather than
     the top-level package containing it as would otherwise be the
     case.  (Unfortunately, this has an additional side effect when
     NAME in fact specifies a subpackage instead of a submodule: the
     submodules specified in the package's `__all__' variable are
     loaded.)  Return a new reference to the imported module, or `NULL'
     with an exception set on failure (the module may still be created
     in this case -- examine `sys.modules' to find out).

`PyObject* PyImport_ImportModuleEx(char *name, PyObject *globals, PyObject *locals, PyObject *fromlist)'
     Import a module.  This is best described by referring to the
     built-in Python function `__import__()' , as the standard
     `__import__()' function calls this function directly.

     The return value is a new reference to the imported module or
     top-level package, or `NULL' with an exception set on failure (the
     module may still be created in this case).  Like for
     `__import__()', the return value when a submodule of a package was
     requested is normally the top-level package, unless a non-empty
     FROMLIST was given.

`PyObject* PyImport_Import(PyObject *name)'
     This is a higher-level interface that calls the current "import
     hook function".  It invokes the `__import__()' function from the
     `__builtins__' of the current globals.  This means that the import
     is done using whatever import hooks are installed in the current
     environment, e.g. by `rexec' or `ihooks' .

`PyObject* PyImport_ReloadModule(PyObject *m)'
     Reload a module.  This is best described by referring to the
     built-in Python function `reload()' , as the standard `reload()'
     function calls this function directly.  Return a new reference to
     the reloaded module, or `NULL' with an exception set on failure
     (the module still exists in this case).

`PyObject* PyImport_AddModule(char *name)'
     Return the module object corresponding to a module name.  The NAME
     argument may be of the form `package.module').  First check the
     modules dictionary if there's one there, and if not, create a new
     one and insert it in the modules dictionary.  Return `NULL' with
     an exception set on failure.  _Note:_ This function does not load
     or import the module; if the module wasn't already loaded, you
     will get an empty module object. Use `PyImport_ImportModule()' or
     one of its variants to import a module.  Package structures
     implied by a dotted name for NAME are not created if not already
     present.

`PyObject* PyImport_ExecCodeModule(char *name, PyObject *co)'
     Given a module name (possibly of the form `package.module') and a
     code object read from a Python bytecode file or obtained from the
     built-in function `compile()' , load the module.  Return a new
     reference to the module object, or `NULL' with an exception set if
     an error occurred (the module may still be created in this case).
     This function would reload the module if it was already imported.
     If NAME points to a dotted name of the form `package.module', any
     package structures not already created will still not be created.

`long PyImport_GetMagicNumber()'
     Return the magic number for Python bytecode files (a.k.a. `.pyc'
     and `.pyo' files).  The magic number should be present in the
     first four bytes of the bytecode file, in little-endian byte order.

`PyObject* PyImport_GetModuleDict()'
     Return the dictionary used for the module administration (a.k.a.
     `sys.modules').  Note that this is a per-interpreter variable.

`void _PyImport_Init()'
     Initialize the import mechanism.  For internal use only.

`void PyImport_Cleanup()'
     Empty the module table.  For internal use only.

`void _PyImport_Fini()'
     Finalize the import mechanism.  For internal use only.

`PyObject* _PyImport_FindExtension(char *, char *)'
     For internal use only.

`PyObject* _PyImport_FixupExtension(char *, char *)'
     For internal use only.

`int PyImport_ImportFrozenModule(char *name)'
     Load a frozen module named NAME.  Return `1' for success, `0' if
     the module is not found, and `-1' with an exception set if the
     initialization failed.  To access the imported module on a
     successful load, use `PyImport_ImportModule()'.  (Note the
     misnomer -- this function would reload the module if it was
     already imported.)

`struct _frozen'
     This is the structure type definition for frozen module
     descriptors, as generated by the `freeze'  utility (see
     `Tools/freeze/' in the Python source distribution).  Its
     definition, found in `Include/import.h', is:

          struct _frozen {
              char *name;
              unsigned char *code;
              int size;
          };

`struct _frozen* PyImport_FrozenModules'
     This pointer is initialized to point to an array of `struct
     _frozen' records, terminated by one whose members are all `NULL' or
     zero.  When a frozen module is imported, it is searched in this
     table.  Third-party code could play tricks with this to provide a
     dynamically created collection of frozen modules.

`int PyImport_AppendInittab(char *name, void (*initfunc)(void))'
     Add a single module to the existing table of built-in modules.
     This is a convenience wrapper around `PyImport_ExtendInittab()',
     returning `-1' if the table could not be extended.  The new module
     can be imported by the name NAME, and uses the function INITFUNC
     as the initialization function called on the first attempted
     import.  This should be called before `Py_Initialize()'.

`struct _inittab'
     Structure describing a single entry in the list of built-in
     modules.  Each of these structures gives the name and
     initialization function for a module built into the interpreter.
     Programs which embed Python may use an array of these structures
     in conjunction with `PyImport_ExtendInittab()' to provide
     additional built-in modules.  The structure is defined in
     `Include/import.h' as:

          struct _inittab {
              char *name;
              void (*initfunc)(void);
          };

`int PyImport_ExtendInittab(struct _inittab *newtab)'
     Add a collection of modules to the table of built-in modules.  The
     NEWTAB array must end with a sentinel entry which contains `NULL'
     for the `name' field; failure to provide the sentinel value can
     result in a memory fault.  Returns `0' on success or `-1' if
     insufficient memory could be allocated to extend the internal
     table.  In the event of failure, no modules are added to the
     internal table.  This should be called before `Py_Initialize()'.


File: python-api.info,  Node: Data marshalling support,  Next: Parsing arguments and building values,  Prev: Importing Modules,  Up: Utilities

Data marshalling support
========================

These routines allow C code to work with serialized objects using the
same data format as the `marshal' module.  There are functions to write
data into the serialization format, and additional functions that can
be used to read the data back.  Files used to store marshalled data
must be opened in binary mode.

Numeric values are stored with the least significant byte first.

`void PyMarshal_WriteLongToFile(long value, FILE *file)'
     Marshal a `long' integer, VALUE, to FILE.  This will only write
     the least-significant 32 bits of VALUE; regardless of the size of
     the native `long' type.

`void PyMarshal_WriteObjectToFile(PyObject *value, FILE *file)'
     Marshal a Python object, VALUE, to FILE.

`PyObject* PyMarshal_WriteObjectToString(PyObject *value)'
     Return a string object containing the marshalled representation of
     VALUE.

The following functions allow marshalled values to be read back in.

XXX What about error detection?  It appears that reading past the end
of the file will always result in a negative numeric value (where
that's relevant), but it's not clear that negative values won't be
handled properly when there's no error.  What's the right way to tell?
Should only non-negative values be written using these routines?

`long PyMarshal_ReadLongFromFile(FILE *file)'
     Return a C `long' from the data stream in a `FILE*' opened for
     reading.  Only a 32-bit value can be read in using this function,
     regardless of the native size of `long'.

`int PyMarshal_ReadShortFromFile(FILE *file)'
     Return a C `short' from the data stream in a `FILE*' opened for
     reading.  Only a 16-bit value can be read in using this function,
     regardless of the native size of `short'.

`PyObject* PyMarshal_ReadObjectFromFile(FILE *file)'
     Return a Python object from the data stream in a `FILE*' opened
     for reading.  On error, sets the appropriate exception (`EOFError'
     or `TypeError') and returns `NULL'.

`PyObject* PyMarshal_ReadLastObjectFromFile(FILE *file)'
     Return a Python object from the data stream in a `FILE*' opened
     for reading.  Unlike `PyMarshal_ReadObjectFromFile()', this
     function assumes that no further objects will be read from the
     file, allowing it to aggressively load file data into memory so
     that the de-serialization can operate from data in memory rather
     than reading a byte at a time from the file.  Only use these
     variant if you are certain that you won't be reading anything else
     from the file.  On error, sets the appropriate exception
     (`EOFError' or `TypeError') and returns `NULL'.

`PyObject* PyMarshal_ReadObjectFromString(char *string, int len)'
     Return a Python object from the data stream in a character buffer
     containing LEN bytes pointed to by STRING.  On error, sets the
     appropriate exception (`EOFError' or `TypeError') and returns
     `NULL'.


File: python-api.info,  Node: Parsing arguments and building values,  Prev: Data marshalling support,  Up: Utilities

Parsing arguments and building values
=====================================

These functions are useful when creating your own extensions functions
and methods.  Additional information and examples are available in .

The first three of these functions described, `PyArg_ParseTuple()',
`PyArg_ParseTupleAndKeywords()', and `PyArg_Parse()', all use _format
strings_ which are used to tell the function about the expected
arguments.  The format strings use the same syntax for each of these
functions.

A format string consists of zero or more "format units."  A format unit
describes one Python object; it is usually a single character or a
parenthesized sequence of format units.  With a few exceptions, a
format unit that is not a parenthesized sequence normally corresponds
to a single address argument to these functions.  In the following
description, the quoted form is the format unit; the entry in (round)
parentheses is the Python object type that matches the format unit; and
the entry in [square] brackets is the type of the C variable(s) whose
address should be passed.

``s' (string or Unicode object) {[char * }]'
     Convert a Python string or Unicode object to a C pointer to a
     character string.  You must not provide storage for the string
     itself; a pointer to an existing string is stored into the
     character pointer variable whose address you pass.  The C string is
     NUL-terminated.  The Python string must not contain embedded NUL
     bytes; if it does, a `TypeError' exception is raised.  Unicode
     objects are converted to C strings using the default encoding.  If
     this conversion fails, a `UnicodeError' is raised.

``s#' (string, Unicode or any read buffer compatible object)'
     {[char *, int }] This variant on `s' stores into two C variables,
     the first one a pointer to a character string, the second one its
     length.  In this case the Python string may contain embedded null
     bytes.  Unicode objects pass back a pointer to the default encoded
     string version of the object if such a conversion is possible.
     All other read-buffer compatible objects pass back a reference to
     the raw internal data representation.

``z' (string or `None') {[char * }]'
     Like `s', but the Python object may also be `None', in which case
     the C pointer is set to `NULL'.

``z#' (string or `None' or any read buffer'
     compatible object) {[char *, int }] This is to `s#' as `z' is to
     `s'.

``u' (Unicode object) {[Py_UNICODE * }]'
     Convert a Python Unicode object to a C pointer to a NUL-terminated
     buffer of 16-bit Unicode (UTF-16) data.  As with `s', there is no
     need to provide storage for the Unicode data buffer; a pointer to
     the existing Unicode data is stored into the `Py_UNICODE' pointer
     variable whose address you pass.

``u#' (Unicode object) {[Py_UNICODE *, int }]'
     This variant on `u' stores into two C variables, the first one a
     pointer to a Unicode data buffer, the second one its length.
     Non-Unicode objects are handled by interpreting their read-buffer
     pointer as pointer to a `Py_UNICODE' array.

``es' (string, Unicode object or character buffer'
     compatible object) {[const char *encoding, char **buffer }] This
     variant on `s' is used for encoding Unicode and objects
     convertible to Unicode into a character buffer. It only works for
     encoded data without embedded NUL bytes.

     This format requires two arguments.  The first is only used as
     input, and must be a `char*' which points to the name of an
     encoding as a NUL-terminated string, or `NULL', in which case the
     default encoding is used.  An exception is raised if the named
     encoding is not known to Python.  The second argument must be a
     `char**'; the value of the pointer it references will be set to a
     buffer with the contents of the argument text.  The text will be
     encoded in the encoding specified by the first argument.

     `PyArg_ParseTuple()' will allocate a buffer of the needed size,
     copy the encoded data into this buffer and adjust *BUFFER to
     reference the newly allocated storage.  The caller is responsible
     for calling `PyMem_Free()' to free the allocated buffer after use.

``et' (string, Unicode object or character buffer'
     compatible object) {[const char *encoding, char **buffer }] Same
     as `es' except that 8-bit string objects are passed through
     without recoding them.  Instead, the implementation assumes that
     the string object uses the encoding passed in as parameter.

``es#' (string, Unicode object or character buffer compatible'
     object) {[const char *encoding, char **buffer, int *buffer_length
     }] This variant on `s#' is used for encoding Unicode and objects
     convertible to Unicode into a character buffer.  Unlike the `es'
     format, this variant allows input data which contains NUL
     characters.

     It requires three arguments.  The first is only used as input, and
     must be a `char*' which points to the name of an encoding as a
     NUL-terminated string, or `NULL', in which case the default
     encoding is used.  An exception is raised if the named encoding is
     not known to Python.  The second argument must be a `char**'; the
     value of the pointer it references will be set to a buffer with the
     contents of the argument text.  The text will be encoded in the
     encoding specified by the first argument.  The third argument must
     be a pointer to an integer; the referenced integer will be set to
     the number of bytes in the output buffer.

     There are two modes of operation:

     If *BUFFER points a `NULL' pointer, the function will allocate a
     buffer of the needed size, copy the encoded data into this buffer
     and set *BUFFER to reference the newly allocated storage.  The
     caller is responsible for calling `PyMem_Free()' to free the
     allocated buffer after usage.

     If *BUFFER points to a non-`NULL' pointer (an already allocated
     buffer), `PyArg_ParseTuple()' will use this location as the buffer
     and interpret the initial value of *BUFFER_LENGTH as the buffer
     size.  It will then copy the encoded data into the buffer and
     NUL-terminate it.  If the buffer is not large enough, a
     `ValueError' will be set.

     In both cases, *BUFFER_LENGTH is set to the length of the encoded
     data without the trailing NUL byte.

``et#' (string, Unicode object or character buffer compatible'
     object) {[const char *encoding, char **buffer }] Same as `es#'
     except that string objects are passed through without recoding
     them. Instead, the implementation assumes that the string object
     uses the encoding passed in as parameter.

``b' (integer) {[char }]'
     Convert a Python integer to a tiny int, stored in a C `char'.

``B' (integer) {[unsigned char }]'
     Convert a Python integer to a tiny int without overflow checking,
     stored in a C `unsigned char'. _Added in Python version 2.3_

``h' (integer) {[short int }]'
     Convert a Python integer to a C `short int'.

``H' (integer) {[unsigned short int }]'
     Convert a Python integer to a C `unsigned short int', without
     overflow checking.  _Added in Python version 2.3_

``i' (integer) {[int }]'
     Convert a Python integer to a plain C `int'.

``I' (integer) {[unsigned int }]'
     Convert a Python integer to a C `unsigned int', without overflow
     checking.  _Added in Python version 2.3_

``l' (integer) {[long int }]'
     Convert a Python integer to a C `long int'.

``k' (integer) {[unsigned long }]'
     Convert a Python integer to a C `unsigned long' without overflow
     checking.  _Added in Python version 2.3_

``L' (integer) {[PY_LONG_LONG }]'
     Convert a Python integer to a C `long long'.  This format is only
     available on platforms that support `long long' (or `_int64' on
     Windows).

``K' (integer) {[unsigned PY_LONG_LONG }]'
     Convert a Python integer to a C `unsigned long long' without
     overflow checking.  This format is only available on platforms
     that support `unsigned long long' (or `unsigned _int64' on
     Windows).  _Added in Python version 2.3_

``c' (string of length 1) {[char }]'
     Convert a Python character, represented as a string of length 1, to
     a C `char'.

``f' (float) {[float }]'
     Convert a Python floating point number to a C `float'.

``d' (float) {[double }]'
     Convert a Python floating point number to a C `double'.

``D' (complex) {[Py_complex }]'
     Convert a Python complex number to a C `Py_complex' structure.

``O' (object) {[PyObject * }]'
     Store a Python object (without any conversion) in a C object
     pointer.  The C program thus receives the actual object that was
     passed.  The object's reference count is not increased.  The
     pointer stored is not `NULL'.

``O!' (object) {[TYPEOBJECT, PyObject * }]'
     Store a Python object in a C object pointer.  This is similar to
     `O', but takes two C arguments: the first is the address of a
     Python type object, the second is the address of the C variable (of
     type `PyObject*') into which the object pointer is stored.  If the
     Python object does not have the required type, `TypeError' is
     raised.

``O&' (object) {[CONVERTER, ANYTHING }]'
     Convert a Python object to a C variable through a CONVERTER
     function.  This takes two arguments: the first is a function, the
     second is the address of a C variable (of arbitrary type),
     converted to `void *'.  The CONVERTER function in turn is called
     as follows:

     STATUS` = 'CONVERTER`('OBJECT, ADDRESS`);'

     where OBJECT is the Python object to be converted and ADDRESS is
     the `void*' argument that was passed to the `PyArg_Parse*()'
     function.  The returned STATUS should be `1' for a successful
     conversion and `0' if the conversion has failed.  When the
     conversion fails, the CONVERTER function should raise an exception.

``S' (string) {[PyStringObject * }]'
     Like `O' but requires that the Python object is a string object.
     Raises `TypeError' if the object is not a string object.  The C
     variable may also be declared as `PyObject*'.

``U' (Unicode string) {[PyUnicodeObject * }]'
     Like `O' but requires that the Python object is a Unicode object.
     Raises `TypeError' if the object is not a Unicode object.  The C
     variable may also be declared as `PyObject*'.

``t#' (read-only character buffer) {[char *, int }]'
     Like `s#', but accepts any object which implements the read-only
     buffer interface.  The `char*' variable is set to point to the
     first byte of the buffer, and the `int' is set to the length of
     the buffer.  Only single-segment buffer objects are accepted;
     `TypeError' is raised for all others.

``w' (read-write character buffer) {[char * }]'
     Similar to `s', but accepts any object which implements the
     read-write buffer interface.  The caller must determine the length
     of the buffer by other means, or use `w#' instead.  Only
     single-segment buffer objects are accepted; `TypeError' is raised
     for all others.

``w#' (read-write character buffer) {[char *, int }]'
     Like `s#', but accepts any object which implements the read-write
     buffer interface.  The `char *' variable is set to point to the
     first byte of the buffer, and the `int' is set to the length of
     the buffer.  Only single-segment buffer objects are accepted;
     `TypeError' is raised for all others.

``(ITEMS)' (tuple) {[MATCHING-ITEMS }]'
     The object must be a Python sequence whose length is the number of
     format units in ITEMS.  The C arguments must correspond to the
     individual format units in ITEMS.  Format units for sequences may
     be nested.

     _Note:_ Prior to Python version 1.5.2, this format specifier only
     accepted a tuple containing the individual parameters, not an
     arbitrary sequence.  Code which previously caused `TypeError' to
     be raised here may now proceed without an exception.  This is not
     expected to be a problem for existing code.

It is possible to pass Python long integers where integers are
requested; however no proper range checking is done -- the most
significant bits are silently truncated when the receiving field is too
small to receive the value (actually, the semantics are inherited from
downcasts in C -- your mileage may vary).

A few other characters have a meaning in a format string.  These may
not occur inside nested parentheses.  They are:

``|''
     Indicates that the remaining arguments in the Python argument list
     are optional.  The C variables corresponding to optional arguments
     should be initialized to their default value -- when an optional
     argument is not specified, `PyArg_ParseTuple()' does not touch the
     contents of the corresponding C variable(s).

``:''
     The list of format units ends here; the string after the colon is
     used as the function name in error messages (the "associated
     value" of the exception that `PyArg_ParseTuple()' raises).

``;''
     The list of format units ends here; the string after the semicolon
     is used as the error message _instead_ of the default error
     message.  Clearly, `:' and `;' mutually exclude each other.

Note that any Python object references which are provided to the caller
are _borrowed_ references; do not decrement their reference count!

Additional arguments passed to these functions must be addresses of
variables whose type is determined by the format string; these are used
to store values from the input tuple.  There are a few cases, as
described in the list of format units above, where these parameters are
used as input values; they should match what is specified for the
corresponding format unit in that case.

For the conversion to succeed, the ARG object must match the format and
the format must be exhausted.  On success, the `PyArg_Parse*()'
functions return true, otherwise they return false and raise an
appropriate exception.

`int PyArg_ParseTuple(PyObject *args, char *format, ...)'
     Parse the parameters of a function that takes only positional
     parameters into local variables.  Returns true on success; on
     failure, it returns false and raises the appropriate exception.

`int PyArg_ParseTupleAndKeywords(PyObject *args, PyObject *kw, char *format, char *keywords[], ...)'
     Parse the parameters of a function that takes both positional and
     keyword parameters into local variables.  Returns true on success;
     on failure, it returns false and raises the appropriate exception.

`int PyArg_Parse(PyObject *args, char *format, ...)'
     Function used to deconstruct the argument lists of "old-style"
     functions -- these are functions which use the `METH_OLDARGS'
     parameter parsing method.  This is not recommended for use in
     parameter parsing in new code, and most code in the standard
     interpreter has been modified to no longer use this for that
     purpose.  It does remain a convenient way to decompose other
     tuples, however, and may continue to be used for that purpose.

`int PyArg_UnpackTuple(PyObject *args, char *name, int min, int max, ...)'
     A simpler form of parameter retrieval which does not use a format
     string to specify the types of the arguments.  Functions which use
     this method to retrieve their parameters should be declared as
     `METH_VARARGS' in function or method tables.  The tuple containing
     the actual parameters should be passed as ARGS; it must actually
     be a tuple.  The length of the tuple must be at least MIN and no
     more than MAX; MIN and MAX may be equal.  Additional arguments
     must be passed to the function, each of which should be a pointer
     to a `PyObject*' variable; these will be filled in with the values
     from ARGS; they will contain borrowed references.  The variables
     which correspond to optional parameters not given by ARGS will not
     be filled in; these should be initialized by the caller.  This
     function returns true on success and false if ARGS is not a tuple
     or contains the wrong number of elements; an exception will be set
     if there was a failure.

     This is an example of the use of this function, taken from the
     sources for the `_weakref' helper module for weak references:

          static PyObject *
          weakref_ref(PyObject *self, PyObject *args)
          {
              PyObject *object;
              PyObject *callback = NULL;
              PyObject *result = NULL;
          
              if (PyArg_UnpackTuple(args, "ref", 1, 2, &object, &callback)) {
                  result = PyWeakref_NewRef(object, callback);
              }
              return result;
          }

     The call to `PyArg_UnpackTuple()' in this example is entirely
     equivalent to this call to `PyArg_ParseTuple()':

          PyArg_ParseTuple(args, "O|O:ref", &object, &callback)

     _Added in Python version 2.2_

`PyObject* Py_BuildValue(char *format, ...)'
     Create a new value based on a format string similar to those
     accepted by the `PyArg_Parse*()' family of functions and a
     sequence of values.  Returns the value or `NULL' in the case of an
     error; an exception will be raised if `NULL' is returned.

     `Py_BuildValue()' does not always build a tuple.  It builds a
     tuple only if its format string contains two or more format units.
     If the format string is empty, it returns `None'; if it contains
     exactly one format unit, it returns whatever object is described
     by that format unit.  To force it to return a tuple of size 0 or
     one, parenthesize the format string.

     When memory buffers are passed as parameters to supply data to
     build objects, as for the `s' and `s#' formats, the required data
     is copied.  Buffers provided by the caller are never referenced by
     the objects created by `Py_BuildValue()'.  In other words, if your
     code invokes `malloc()' and passes the allocated memory to
     `Py_BuildValue()', your code is responsible for calling `free()'
     for that memory once `Py_BuildValue()' returns.

     In the following description, the quoted form is the format unit;
     the entry in (round) parentheses is the Python object type that the
     format unit will return; and the entry in [square] brackets is the
     type of the C value(s) to be passed.

     The characters space, tab, colon and comma are ignored in format
     strings (but not within format units such as `s#').  This can be
     used to make long format strings a tad more readable.

    ``s' (string) {[char * }]'
          Convert a null-terminated C string to a Python object.  If
          the C string pointer is `NULL', `None' is used.

    ``s#' (string) {[char *, int }]'
          Convert a C string and its length to a Python object.  If the
          C string pointer is `NULL', the length is ignored and `None'
          is returned.

    ``z' (string or `None') {[char * }]'
          Same as `s'.

    ``z#' (string or `None') {[char *, int }]'
          Same as `s#'.

    ``u' (Unicode string) {[Py_UNICODE * }]'
          Convert a null-terminated buffer of Unicode (UCS-2) data to a
          Python Unicode object.  If the Unicode buffer pointer is
          `NULL', `None' is returned.

    ``u#' (Unicode string) {[Py_UNICODE *, int }]'
          Convert a Unicode (UCS-2) data buffer and its length to a
          Python Unicode object.   If the Unicode buffer pointer is
          `NULL', the length is ignored and `None' is returned.

    ``i' (integer) {[int }]'
          Convert a plain C `int' to a Python integer object.

    ``b' (integer) {[char }]'
          Same as `i'.

    ``h' (integer) {[short int }]'
          Same as `i'.

    ``l' (integer) {[long int }]'
          Convert a C `long int' to a Python integer object.

    ``c' (string of length 1) {[char }]'
          Convert a C `int' representing a character to a Python string
          of length 1.

    ``d' (float) {[double }]'
          Convert a C `double' to a Python floating point number.

    ``f' (float) {[float }]'
          Same as `d'.

    ``D' (complex) {[Py_complex * }]'
          Convert a C `Py_complex' structure to a Python complex number.

    ``O' (object) {[PyObject * }]'
          Pass a Python object untouched (except for its reference
          count, which is incremented by one).  If the object passed in
          is a `NULL' pointer, it is assumed that this was caused
          because the call producing the argument found an error and
          set an exception.  Therefore, `Py_BuildValue()' will return
          `NULL' but won't raise an exception.  If no exception has
          been raised yet, `SystemError' is set.

    ``S' (object) {[PyObject * }]'
          Same as `O'.

    ``U' (object) {[PyObject * }]'
          Same as `O'.

    ``N' (object) {[PyObject * }]'
          Same as `O', except it doesn't increment the reference count
          on the object.  Useful when the object is created by a call
          to an object constructor in the argument list.

    ``O&' (object) {[CONVERTER, ANYTHING }]'
          Convert ANYTHING to a Python object through a CONVERTER
          function.  The function is called with ANYTHING (which should
          be compatible with `void *') as its argument and should
          return a "new" Python object, or `NULL' if an error occurred.

    ``(ITEMS)' (tuple) {[MATCHING-ITEMS }]'
          Convert a sequence of C values to a Python tuple with the same
          number of items.

    ``[ITEMS ' (list) {[MATCHING-ITEMS]}]'
          Convert a sequence of C values to a Python list with the same
          number of items.

    ``{ITEMS}' (dictionary) {[MATCHING-ITEMS }]'
          Convert a sequence of C values to a Python dictionary.  Each
          pair of consecutive C values adds one item to the dictionary,
          serving as key and value, respectively.

     If there is an error in the format string, the `SystemError'
     exception is set and `NULL' returned.


File: python-api.info,  Node: Abstract Objects Layer,  Next: Concrete Objects Layer,  Prev: Utilities,  Up: Top

Abstract Objects Layer
**********************

The functions in this chapter interact with Python objects regardless
of their type, or with wide classes of object types (e.g. all numerical
types, or all sequence types).  When used on object types for which
they do not apply, they will raise a Python exception.

* Menu:

* Object Protocol::
* Number Protocol::
* Sequence Protocol::
* Mapping Protocol::
* Iterator Protocol::
* Buffer Protocol::

