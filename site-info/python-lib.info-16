This is python-lib.info, produced by makeinfo version 4.3 from
python-lib.texi.

October 3, 2003


File: python-lib.info,  Node: Process Management,  Next: Miscellaneous System Information,  Prev: Files and Directories,  Up: os

Process Management
------------------

These functions may be used to create and manage processes.

The various `exec*()' functions take a list of arguments for the new
program loaded into the process.  In each case, the first of these
arguments is passed to the new program as its own name rather than as
an argument a user may have typed on a command line.  For the C
programmer, this is the `argv[0]' passed to a program's `main()'.  For
example, `os.execv('/bin/echo', ['foo', 'bar'])' will only print `bar'
on standard output; `foo' will seem to be ignored.

`abort()'
     Generate a `SIGABRT' signal to the current process.  On UNIX, the
     default behavior is to produce a core dump; on Windows, the
     process immediately returns an exit code of `3'.  Be aware that
     programs which use `signal.signal()' to register a handler for
     `SIGABRT' will behave differently.  Availability: UNIX, Windows.

`execl(path, arg0, arg1, ...)'

`execle path, arg0, arg1, ..., env'

`execlp file, arg0, arg1, ...'

`execlpe file, arg0, arg1, ..., env'

`execv path, args'

`execve path, args, env'

`execvp file, args'

`execvpe file, args, env'
     These functions all execute a new program, replacing the current
     process; they do not return.  On UNIX, the new executable is loaded
     into the current process, and will have the same process ID as the
     caller.  Errors will be reported as `OSError' exceptions.

     The `l' and `v' variants of the `exec*()' functions differ in how
     command-line arguments are passed.  The `l' variants are perhaps
     the easiest to work with if the number of parameters is fixed when
     the code is written; the individual parameters simply become
     additional parameters to the `execl*()' functions.  The `v'
     variants are good when the number of parameters is variable, with
     the arguments being passed in a list or tuple as the ARGS
     parameter.  In either case, the arguments to the child process
     must start with the name of the command being run.

     The variants which include a `p' near the end (`execlp()',
     `execlpe()', `execvp()', and `execvpe()') will use the `PATH'
     environment variable to locate the program FILE.  When the
     environment is being replaced (using one of the `exec*e()'
     variants, discussed in the next paragraph), the new environment is
     used as the source of the `PATH' variable.  The other variants,
     `execl()', `execle()', `execv()', and `execve()', will not use the
     `PATH' variable to locate the executable; PATH must contain an
     appropriate absolute or relative path.

     For `execle()', `execlpe()', `execve()', and `execvpe()' (note
     that these all end in `e'), the ENV parameter must be a mapping
     which is used to define the environment variables for the new
     process; the `execl()', `execlp()', `execv()', and `execvp()' all
     cause the new process to inherit the environment of the current
     process.  Availability: UNIX, Windows.

`_exit(n)'
     Exit to the system with status N, without calling cleanup
     handlers, flushing stdio buffers, etc.  Availability: UNIX,
     Windows.

     Note: the standard way to exit is `sys.exit(N)'.  `_exit()' should
     normally only be used in the child process after a `fork()'.

The following exit codes are a defined, and can be used with `_exit()',
although they are not required.  These are typically used for system
programs written in Python, such as a mail server's external command
delivery program.

`EX_OK'
     Exit code that means no error occurred.  Availability: UNIX.
     _Added in Python version 2.3_

`EX_USAGE'
     Exit code that means the command was used incorrectly, such as when
     the wrong number of arguments are given.  Availability: UNIX.
     _Added in Python version 2.3_

`EX_DATAERR'
     Exit code that means the input data was incorrect.  Availability:
     UNIX.  _Added in Python version 2.3_

`EX_NOINPUT'
     Exit code that means an input file did not exist or was not
     readable.  Availability: UNIX.  _Added in Python version 2.3_

`EX_NOUSER'
     Exit code that means a specified user did not exist.
     Availability: UNIX.  _Added in Python version 2.3_

`EX_NOHOST'
     Exit code that means a specified host did not exist.
     Availability: UNIX.  _Added in Python version 2.3_

`EX_UNAVAILABLE'
     Exit code that means that a required service is unavailable.
     Availability: UNIX.  _Added in Python version 2.3_

`EX_SOFTWARE'
     Exit code that means an internal software error was detected.
     Availability: UNIX.  _Added in Python version 2.3_

`EX_OSERR'
     Exit code that means an operating system error was detected, such
     as the inability to fork or create a pipe.  Availability: UNIX.
     _Added in Python version 2.3_

`EX_OSFILE'
     Exit code that means some system file did not exist, could not be
     opened, or had some other kind of error.  Availability: UNIX.
     _Added in Python version 2.3_

`EX_CANTCREAT'
     Exit code that means a user specified output file could not be
     created.  Availability: UNIX.  _Added in Python version 2.3_

`EX_IOERR'
     Exit code that means that an error occurred while doing I/O on
     some file.  Availability: UNIX.  _Added in Python version 2.3_

`EX_TEMPFAIL'
     Exit code that means a temporary failure occurred.  This indicates
     something that may not really be an error, such as a network
     connection that couldn't be made during a retryable operation.
     Availability: UNIX.  _Added in Python version 2.3_

`EX_PROTOCOL'
     Exit code that means that a protocol exchange was illegal,
     invalid, or not understood.  Availability: UNIX.  _Added in Python
     version 2.3_

`EX_NOPERM'
     Exit code that means that there were insufficient permissions to
     perform the operation (but not intended for file system problems).
     Availability: UNIX.  _Added in Python version 2.3_

`EX_CONFIG'
     Exit code that means that some kind of configuration error
     occurred.  Availability: UNIX.  _Added in Python version 2.3_

`EX_NOTFOUND'
     Exit code that means something like "an entry was not found".
     Availability: UNIX.  _Added in Python version 2.3_

`fork()'
     Fork a child process.  Return `0' in the child, the child's
     process id in the parent.  Availability: UNIX.

`forkpty()'
     Fork a child process, using a new pseudo-terminal as the child's
     controlling terminal. Return a pair of `(PID, FD)', where PID is
     `0' in the child, the new child's process id in the parent, and FD
     is the file descriptor of the master end of the pseudo-terminal.
     For a more portable approach, use the `pty' module.  Availability:
     Some flavors of UNIX.

`kill(pid, sig)'
     Kill the process PID with signal SIG.  Constants for the specific
     signals available on the host platform are defined in the `signal'
     module.  Availability: UNIX.

`killpg(pgid, sig)'
     Kill the process group PGID with the signal SIG.  Availability:
     UNIX.  _Added in Python version 2.3_

`nice(increment)'
     Add INCREMENT to the process's "niceness".  Return the new
     niceness.  Availability: UNIX.

`plock(op)'
     Lock program segments into memory.  The value of OP (defined in
     `<sys/lock.h>') determines which segments are locked.
     Availability: UNIX.

`popen(...)'

`popen2 ...'

`popen3 ...'

`popen4 ...'
     Run child processes, returning opened pipes for communications.
     These functions are described in section *Note File Object
     Creation::.

`spawnl(mode, path, ...)'

`spawnle mode, path, ..., env'

`spawnlp mode, file, ...'

`spawnlpe mode, file, ..., env'

`spawnv mode, path, args'

`spawnve mode, path, args, env'

`spawnvp mode, file, args'

`spawnvpe mode, file, args, env'
     Execute the program PATH in a new process.  If MODE is `P_NOWAIT',
     this function returns the process ID of the new process; if MODE
     is `P_WAIT', returns the process's exit code if it exits normally,
     or `-SIGNAL', where SIGNAL is the signal that killed the process.
     On Windows, the process ID will actually be the process handle, so
     can be used with the `waitpid()' function.

     The `l' and `v' variants of the `spawn*()' functions differ in how
     command-line arguments are passed.  The `l' variants are perhaps
     the easiest to work with if the number of parameters is fixed when
     the code is written; the individual parameters simply become
     additional parameters to the `spawnl*()' functions.  The `v'
     variants are good when the number of parameters is variable, with
     the arguments being passed in a list or tuple as the ARGS
     parameter.  In either case, the arguments to the child process
     must start with the name of the command being run.

     The variants which include a second `p' near the end (`spawnlp()',
     `spawnlpe()', `spawnvp()', and `spawnvpe()') will use the `PATH'
     environment variable to locate the program FILE.  When the
     environment is being replaced (using one of the `spawn*e()'
     variants, discussed in the next paragraph), the new environment is
     used as the source of the `PATH' variable.  The other variants,
     `spawnl()', `spawnle()', `spawnv()', and `spawnve()', will not use
     the `PATH' variable to locate the executable; PATH must contain an
     appropriate absolute or relative path.

     For `spawnle()', `spawnlpe()', `spawnve()', and `spawnvpe()' (note
     that these all end in `e'), the ENV parameter must be a mapping
     which is used to define the environment variables for the new
     process; the `spawnl()', `spawnlp()', `spawnv()', and `spawnvp()'
     all cause the new process to inherit the environment of the current
     process.

     As an example, the following calls to `spawnlp()' and `spawnvpe()'
     are equivalent:

          import os
          os.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')
          
          L = ['cp', 'index.html', '/dev/null']
          os.spawnvpe(os.P_WAIT, 'cp', L, os.environ)

     Availability: UNIX, Windows.  `spawnlp()', `spawnlpe()',
     `spawnvp()' and `spawnvpe()' are not available on Windows.  _Added
     in Python version 1.6_

`P_NOWAIT'

`P_NOWAITO'
     Possible values for the MODE parameter to the `spawn*()' family of
     functions.  If either of these values is given, the `spawn*()'
     functions will return as soon as the new process has been created,
     with the process ID as the return value.  Availability: UNIX,
     Windows.  _Added in Python version 1.6_

`P_WAIT'
     Possible value for the MODE parameter to the `spawn*()' family of
     functions.  If this is given as MODE, the `spawn*()' functions
     will not return until the new process has run to completion and
     will return the exit code of the process the run is successful, or
     `-SIGNAL' if a signal kills the process.  Availability: UNIX,
     Windows.  _Added in Python version 1.6_

`P_DETACH'

`P_OVERLAY'
     Possible values for the MODE parameter to the `spawn*()' family of
     functions.  These are less portable than those listed above.
     `P_DETACH' is similar to `P_NOWAIT', but the new process is
     detached from the console of the calling process.  If `P_OVERLAY'
     is used, the current process will be replaced; the `spawn*()'
     function will not return.  Availability: Windows.  _Added in
     Python version 1.6_

`startfile(path)'
     Start a file with its associated application.  This acts like
     double-clicking the file in Windows Explorer, or giving the file
     name as an argument to the `start' command from the interactive
     command shell: the file is opened with whatever application (if
     any) its extension is associated.

     `startfile()' returns as soon as the associated application is
     launched.  There is no option to wait for the application to close,
     and no way to retrieve the application's exit status.  The PATH
     parameter is relative to the current directory.  If you want to
     use an absolute path, make sure the first character is not a slash
     (`/'); the underlying Win32 `ShellExecute()' function doesn't work
     if it is.  Use the `os.path.normpath()' function to ensure that
     the path is properly encoded for Win32.  Availability: Windows.
     _Added in Python version 2.0_

`system(command)'
     Execute the command (a string) in a subshell.  This is implemented
     by calling the Standard C function `system()', and has the same
     limitations.  Changes to `posix.environ', `sys.stdin', etc. are
     not reflected in the environment of the executed command.

     On UNIX, the return value is the exit status of the process
     encoded in the format specified for `wait()'.  Note that POSIX
     does not specify the meaning of the return value of the C
     `system()' function, so the return value of the Python function is
     system-dependent.

     On Windows, the return value is that returned by the system shell
     after running COMMAND, given by the Windows environment variable
     `COMSPEC': on `command.com' systems (Windows 95, 98 and ME) this
     is always `0'; on `cmd.exe' systems (Windows NT, 2000 and XP) this
     is the exit status of the command run; on systems using a
     non-native shell, consult your shell documentation.

     Availability: UNIX, Windows.

`times()'
     Return a 5-tuple of floating point numbers indicating accumulated
     (processor or other) times, in seconds.  The items are: user time,
     system time, children's user time, children's system time, and
     elapsed real time since a fixed point in the past, in that order.
     See the UNIX manual page `times(2)' or the corresponding Windows
     Platform API documentation.  Availability: UNIX, Windows.

`wait()'
     Wait for completion of a child process, and return a tuple
     containing its pid and exit status indication: a 16-bit number,
     whose low byte is the signal number that killed the process, and
     whose high byte is the exit status (if the signal number is zero);
     the high bit of the low byte is set if a core file was produced.
     Availability: UNIX.

`waitpid(pid, options)'
     The details of this function differ on UNIX and Windows.

     On UNIX: Wait for completion of a child process given by process
     id PID, and return a tuple containing its process id and exit
     status indication (encoded as for `wait()').  The semantics of the
     call are affected by the value of the integer OPTIONS, which
     should be `0' for normal operation.

     If PID is greater than `0', `waitpid()' requests status
     information for that specific process.  If PID is `0', the request
     is for the status of any child in the process group of the current
     process.  If PID is `-1', the request pertains to any child of the
     current process.  If PID is less than `-1', status is requested
     for any process in the process group `-PID' (the absolute value of
     PID).

     On Windows: Wait for completion of a process given by process
     handle PID, and return a tuple containing PID, and its exit status
     shifted left by 8 bits (shifting makes cross-platform use of the
     function easier).  A PID less than or equal to `0' has no special
     meaning on Windows, and raises an exception.  The value of integer
     OPTIONS has no effect.  PID can refer to any process whose id is
     known, not necessarily a child process.  The `spawn()' functions
     called with `P_NOWAIT' return suitable process handles.

`WNOHANG'
     The option for `waitpid()' to avoid hanging if no child process
     status is available immediately.  Availability: UNIX.

`WCONTINUED'
     This option causes child processes to be reported if they have been
     continued from a job control stop since their status was last
     reported.  Availability: Some UNIX systems.  _Added in Python
     version 2.3_

`WUNTRACED'
     This option causes child processes to be reported if they have been
     stopped but their current state has not been reported since they
     were stopped.  Availability: UNIX.  _Added in Python version 2.3_

The following functions take a process status code as returned by
`system()', `wait()', or `waitpid()' as a parameter.  They may be used
to determine the disposition of a process.

`WCOREDUMP(status)'
     Returns `True' if a core dump was generated for the process,
     otherwise it returns `False'.  Availability: UNIX.  _Added in
     Python version 2.3_

`WIFCONTINUED(status)'
     Returns `True' if the process has been continued from a job
     control stop, otherwise it returns `False'.  Availability: UNIX.
     _Added in Python version 2.3_

`WIFSTOPPED(status)'
     Returns `True' if the process has been stopped, otherwise it
     returns `False'.  Availability: UNIX.

`WIFSIGNALED(status)'
     Returns `True' if the process exited due to a signal, otherwise it
     returns `False'.  Availability: UNIX.

`WIFEXITED(status)'
     Returns `True' if the process exited using the `exit(2)' system
     call, otherwise it returns `False'.  Availability: UNIX.

`WEXITSTATUS(status)'
     If `WIFEXITED(STATUS)' is true, return the integer parameter to
     the `exit(2)' system call.  Otherwise, the return value is
     meaningless.  Availability: UNIX.

`WSTOPSIG(status)'
     Return the signal which caused the process to stop.  Availability:
     UNIX.

`WTERMSIG(status)'
     Return the signal which caused the process to exit.  Availability:
     UNIX.


File: python-lib.info,  Node: Miscellaneous System Information,  Prev: Process Management,  Up: os

Miscellaneous System Information
--------------------------------

`confstr(name)'
     Return string-valued system configuration values.  NAME specifies
     the configuration value to retrieve; it may be a string which is
     the name of a defined system value; these names are specified in a
     number of standards (POSIX, UNIX 95, UNIX 98, and others).  Some
     platforms define additional names as well.  The names known to the
     host operating system are given in the `confstr_names' dictionary.
     For configuration variables not included in that mapping, passing
     an integer for NAME is also accepted.  Availability: UNIX.

     If the configuration value specified by NAME isn't defined, the
     empty string is returned.

     If NAME is a string and is not known, `ValueError' is raised.  If
     a specific value for NAME is not supported by the host system,
     even if it is included in `confstr_names', an `OSError' is raised
     with `errno.EINVAL' for the error number.

`confstr_names'
     Dictionary mapping names accepted by `confstr()' to the integer
     values defined for those names by the host operating system.  This
     can be used to determine the set of names known to the system.
     Availability: UNIX.

`getloadavg()'
     Return the number of processes in the system run queue averaged
     over the last 1, 5, and 15 minutes or raises OSError if the load
     average was unobtainable.

     _Added in Python version 2.3_

`sysconf(name)'
     Return integer-valued system configuration values.  If the
     configuration value specified by NAME isn't defined, `-1' is
     returned.  The comments regarding the NAME parameter for
     `confstr()' apply here as well; the dictionary that provides
     information on the known names is given by `sysconf_names'.
     Availability: UNIX.

`sysconf_names'
     Dictionary mapping names accepted by `sysconf()' to the integer
     values defined for those names by the host operating system.  This
     can be used to determine the set of names known to the system.
     Availability: UNIX.

The follow data values are used to support path manipulation
operations.  These are defined for all platforms.

Higher-level operations on pathnames are defined in the `os.path'
module.

`curdir'
     The constant string used by the operating system to refer to the
     current directory.  For example: `'.'' for POSIX or `':'' for the
     Macintosh.  Also available via `os.path'.

`pardir'
     The constant string used by the operating system to refer to the
     parent directory.  For example: `'..'' for POSIX or `'::'' for the
     Macintosh.  Also available via `os.path'.

`sep'
     The character used by the operating system to separate pathname
     components, for example, `/' for POSIX or `:' for the Macintosh.
     Note that knowing this is not sufficient to be able to parse or
     concatenate pathnames -- use `os.path.split()' and
     `os.path.join()' -- but it is occasionally useful.  Also available
     via `os.path'.

`altsep'
     An alternative character used by the operating system to separate
     pathname components, or `None' if only one separator character
     exists.  This is set to `/' on Windows systems where `sep' is a
     backslash.  Also available via `os.path'.

`extsep'
     The character which separates the base filename from the extension;
     for example, the `.' in `os.py'.  Also available via `os.path'.
     _Added in Python version 2.2_

`pathsep'
     The character conventionally used by the operating system to
     separate search patch components (as in `PATH'), such as `:' for
     POSIX or `;' for Windows.  Also available via `os.path'.

`defpath'
     The default search path used by `exec*p*()' and `spawn*p*()' if
     the environment doesn't have a `'PATH'' key.  Also available via
     `os.path'.

`linesep'
     The string used to separate (or, rather, terminate) lines on the
     current platform.  This may be a single character, such as `'\n''
     for POSIX or `'\r'' for Mac OS, or multiple characters, for
     example, `'\r\n'' for Windows.


File: python-lib.info,  Node: ospath,  Next: dircache,  Prev: os,  Up: Generic Operating System Services

Common pathname manipulations
=============================

Common pathname manipulations.

This module implements some useful functions on pathnames.

_On Windows, many of these functions do not properly support UNC
pathnames.  `splitunc()' and `ismount()' do handle them correctly._

`abspath(path)'
     Return a normalized absolutized version of the pathname PATH.  On
     most platforms, this is equivalent to `normpath(join(os.getcwd(),
     PATH))'.  _Added in Python version 1.5.2_

`basename(path)'
     Return the base name of pathname PATH.  This is the second half of
     the pair returned by `split(PATH)'.  Note that the result of this
     function is different from the UNIX `basename' program; where
     `basename' for `'/foo/bar/'' returns `'bar'', the `basename()'
     function returns an empty string (`''').

`commonprefix(list)'
     Return the longest path prefix (taken character-by-character) that
     is a prefix of all paths in LIST.  If LIST is empty, return the
     empty string (`''').  Note that this may return invalid paths
     because it works a character at a time.

`dirname(path)'
     Return the directory name of pathname PATH.  This is the first
     half of the pair returned by `split(PATH)'.

`exists(path)'
     Return `True' if PATH refers to an existing path.

`expanduser(path)'
     Return the argument with an initial component of `~' or `~USER'
     replaced by that USER's home directory.  An initial `~{}' is
     replaced by the environment variable `HOME'; an initial `~USER' is
     looked up in the password directory through the built-in module
     `pwd' .  If the expansion fails, or if the path does not begin
     with a tilde, the path is returned unchanged.  On the Macintosh,
     this always returns PATH unchanged.

`expandvars(path)'
     Return the argument with environment variables expanded.
     Substrings of the form `$NAME' or `${NAME}' are replaced by the
     value of environment variable NAME.  Malformed variable names and
     references to non-existing variables are left unchanged.  On the
     Macintosh, this always returns PATH unchanged.

`getatime(path)'
     Return the time of last access of PATH.  The return value is a
     number giving the number of seconds since the epoch (see the
     `time' module).  Raise `os.error' if the file does not exist or is
     inaccessible.  _Added in Python version 1.5.2_ _Changed in Python
     version 2.3_

`getmtime(path)'
     Return the time of last modification of PATH.  The return value is
     a number giving the number of seconds since the epoch (see the
     `time' module).  Raise `os.error' if the file does not exist or is
     inaccessible.  _Added in Python version 1.5.2_ _Changed in Python
     version 2.3_

`getctime(path)'
     Return the time of creation of PATH.  The return value is a number
     giving the number of seconds since the epoch (see the `time'
     module).  Raise `os.error' if the file does not exist or is
     inaccessible.  _Added in Python version 2.3_

`getsize(path)'
     Return the size, in bytes, of PATH.  Raise `os.error' if the file
     does not exist or is inaccessible.  _Added in Python version 1.5.2_

`isabs(path)'
     Return `True' if PATH is an absolute pathname (begins with a
     slash).

`isfile(path)'
     Return `True' if PATH is an existing regular file.  This follows
     symbolic links, so both `islink()' and `isfile()' can be true for
     the same path.

`isdir(path)'
     Return `True' if PATH is an existing directory.  This follows
     symbolic links, so both `islink()' and `isdir()' can be true for
     the same path.

`islink(path)'
     Return `True' if PATH refers to a directory entry that is a
     symbolic link.  Always `False' if symbolic links are not supported.

`ismount(path)'
     Return `True' if pathname PATH is a "mount point": a point in a
     file system where a different file system has been mounted.  The
     function checks whether PATH's parent, `PATH/..', is on a
     different device than PATH, or whether `PATH/..' and PATH point to
     the same i-node on the same device -- this should detect mount
     points for all UNIX and POSIX variants.

`join(path1[, path2[, ...]])'
     Joins one or more path components intelligently.  If any component
     is an absolute path, all previous components are thrown away, and
     joining continues.  The return value is the concatenation of
     PATH1, and optionally PATH2, etc., with exactly one directory
     separator (`os.sep') inserted between components, unless PATH2 is
     empty.  Note that on Windows, since there is a current directory
     for each drive, `os.path.join("c:", "foo")' represents a path
     relative to the current directory on drive `C:' (`c:foo'), not
     `c:\\foo'.

`normcase(path)'
     Normalize the case of a pathname.  On UNIX, this returns the path
     unchanged; on case-insensitive filesystems, it converts the path to
     lowercase.  On Windows, it also converts forward slashes to
     backward slashes.

`normpath(path)'
     Normalize a pathname.  This collapses redundant separators and
     up-level references, e.g. `A//B', `A/./B' and `A/foo/../B' all
     become `A/B'.  It does not normalize the case (use `normcase()'
     for that).  On Windows, it converts forward slashes to backward
     slashes.

`realpath(path)'
     Return the canonical path of the specified filename, eliminating
     any symbolic links encountered in the path.  Availability:  UNIX.
     _Added in Python version 2.2_

`samefile(path1, path2)'
     Return `True' if both pathname arguments refer to the same file or
     directory (as indicated by device number and i-node number).
     Raise an exception if a `os.stat()' call on either pathname fails.
     Availability:  Macintosh, UNIX.

`sameopenfile(fp1, fp2)'
     Return `True' if the file objects FP1 and FP2 refer to the same
     file.  The two file objects may represent different file
     descriptors.  Availability:  Macintosh, UNIX.

`samestat(stat1, stat2)'
     Return `True' if the stat tuples STAT1 and STAT2 refer to the same
     file.  These structures may have been returned by `fstat()',
     `lstat()', or `stat()'.  This function implements the underlying
     comparison used by `samefile()' and `sameopenfile()'.
     Availability:  Macintosh, UNIX.

`split(path)'
     Split the pathname PATH into a pair, `(HEAD, TAIL)' where TAIL is
     the last pathname component and HEAD is everything leading up to
     that.  The TAIL part will never contain a slash; if PATH ends in a
     slash, TAIL will be empty.  If there is no slash in PATH, HEAD
     will be empty.  If PATH is empty, both HEAD and TAIL are empty.
     Trailing slashes are stripped from HEAD unless it is the root (one
     or more slashes only).  In nearly all cases, `join(HEAD, TAIL)'
     equals PATH (the only exception being when there were multiple
     slashes separating HEAD from TAIL).

`splitdrive(path)'
     Split the pathname PATH into a pair `(DRIVE, TAIL)' where DRIVE is
     either a drive specification or the empty string.  On systems
     which do not use drive specifications, DRIVE will always be the
     empty string.  In all cases, `DRIVE + TAIL' will be the same as
     PATH.  _Added in Python version 1.3_

`splitext(path)'
     Split the pathname PATH into a pair `(ROOT, EXT)' such that `ROOT
     + EXT == PATH', and EXT is empty or begins with a period and
     contains at most one period.

`walk(path, visit, arg)'
     Calls the function VISIT with arguments `(ARG, DIRNAME, NAMES)'
     for each directory in the directory tree rooted at PATH (including
     PATH itself, if it is a directory).  The argument DIRNAME
     specifies the visited directory, the argument NAMES lists the
     files in the directory (gotten from `os.listdir(DIRNAME)').  The
     VISIT function may modify NAMES to influence the set of
     directories visited below DIRNAME, e.g., to avoid visiting certain
     parts of the tree.  (The object referred to by NAMES must be
     modified in place, using `del' or slice assignment.)

     _Notice:_ Symbolic links to directories are not treated as
     subdirectories, and that `walk()' therefore will not visit them.
     To visit linked directories you must identify them with
     `os.path.islink(FILE)' and `os.path.isdir(FILE)', and invoke
     `walk()' as necessary.

     _Note:_ The newer ``os'.walk()' generator supplies similar
     functionality and can be easier to use.

`supports_unicode_filenames'
     True if arbitrary Unicode strings can be used as file names (within
     limitations imposed by the file system), and if `os.listdir()'
     returns Unicode strings for a Unicode argument.  _Added in Python
     version 2.3_


File: python-lib.info,  Node: dircache,  Next: stat,  Prev: ospath,  Up: Generic Operating System Services

Cached directory listings
=========================

Return directory listing, with cache mechanism.

The `dircache' module defines a function for reading directory listing
using a cache, and cache invalidation using the MTIME of the directory.
Additionally, it defines a function to annotate directories by appending
a slash.

The `dircache' module defines the following functions:

`listdir(path)'
     Return a directory listing of PATH, as gotten from `os.listdir()'.
     Note that unless PATH changes, further call to `listdir()' will
     not re-read the directory structure.

     Note that the list returned should be regarded as read-only.
     (Perhaps a future version should change it to return a tuple?)

`opendir(path)'
     Same as `listdir()'. Defined for backwards compatibility.

`annotate(head, list)'
     Assume LIST is a list of paths relative to HEAD, and append, in
     place, a `/' to each path which points to a directory.

     >>> import dircache
     >>> a=dircache.listdir('/')
     >>> a=a[:] # Copy the return value so we can change 'a'
     >>> a
     ['bin', 'boot', 'cdrom', 'dev', 'etc', 'floppy', 'home', 'initrd', 'lib', 'lost+
     found', 'mnt', 'proc', 'root', 'sbin', 'tmp', 'usr', 'var', 'vmlinuz']
     >>> dircache.annotate('/', a)
     >>> a
     ['bin/', 'boot/', 'cdrom/', 'dev/', 'etc/', 'floppy/', 'home/', 'initrd/', 'lib/
     ', 'lost+found/', 'mnt/', 'proc/', 'root/', 'sbin/', 'tmp/', 'usr/', 'var/', 'vm
     linuz']


File: python-lib.info,  Node: stat,  Next: statcache,  Prev: dircache,  Up: Generic Operating System Services

Interpreting `stat()' results
=============================

Utilities for interpreting the results of `os.stat()', `os.lstat()' and
`os.fstat()'.

The `stat' module defines constants and functions for interpreting the
results of `os.stat()', `os.fstat()' and `os.lstat()' (if they exist).
For complete details about the `stat()', `fstat()' and `lstat()' calls,
consult the documentation for your system.

The `stat' module defines the following functions to test for specific
file types:

`S_ISDIR(mode)'
     Return non-zero if the mode is from a directory.

`S_ISCHR(mode)'
     Return non-zero if the mode is from a character special device
     file.

`S_ISBLK(mode)'
     Return non-zero if the mode is from a block special device file.

`S_ISREG(mode)'
     Return non-zero if the mode is from a regular file.

`S_ISFIFO(mode)'
     Return non-zero if the mode is from a FIFO (named pipe).

`S_ISLNK(mode)'
     Return non-zero if the mode is from a symbolic link.

`S_ISSOCK(mode)'
     Return non-zero if the mode is from a socket.

Two additional functions are defined for more general manipulation of
the file's mode:

`S_IMODE(mode)'
     Return the portion of the file's mode that can be set by
     `os.chmod()'--that is, the file's permission bits, plus the sticky
     bit, set-group-id, and set-user-id bits (on systems that support
     them).

`S_IFMT(mode)'
     Return the portion of the file's mode that describes the file type
     (used by the `S_IS*()' functions above).

Normally, you would use the `os.path.is*()' functions for testing the
type of a file; the functions here are useful when you are doing
multiple tests of the same file and wish to avoid the overhead of the
`stat()' system call for each test.  These are also useful when
checking for information about a file that isn't handled by `os.path',
like the tests for block and character devices.

All the variables below are simply symbolic indexes into the 10-tuple
returned by `os.stat()', `os.fstat()' or `os.lstat()'.

`ST_MODE'
     Inode protection mode.

`ST_INO'
     Inode number.

`ST_DEV'
     Device inode resides on.

`ST_NLINK'
     Number of links to the inode.

`ST_UID'
     User id of the owner.

`ST_GID'
     Group id of the owner.

`ST_SIZE'
     Size in bytes of a plain file; amount of data waiting on some
     special files.

`ST_ATIME'
     Time of last access.

`ST_MTIME'
     Time of last modification.

`ST_CTIME'
     Time of last status change (see manual pages for details).

The interpretation of "file size" changes according to the file type.
For plain files this is the size of the file in bytes.  For FIFOs and
sockets under most flavors of UNIX (including Linux in particular), the
"size" is the number of bytes waiting to be read at the time of the
call to `os.stat()', `os.fstat()', or `os.lstat()'; this can sometimes
be useful, especially for polling one of these special files after a
non-blocking open.  The meaning of the size field for other character
and block devices varies more, depending on the implementation of the
underlying system call.

Example:

     import os, sys
     from stat import *
     
     def walktree(top, callback):
         '''recursively descend the directory tree rooted at top,
            calling the callback function for each regular file'''
     
         for f in os.listdir(top):
             pathname = os.path.join(top, f)
             mode = os.stat(pathname)[ST_MODE]
             if S_ISDIR(mode):
                 # It's a directory, recurse into it
                 walktree(pathname, callback)
             elif S_ISREG(mode):
                 # It's a file, call the callback function
                 callback(pathname)
             else:
                 # Unknown file type, print a message
                 print 'Skipping %s' % pathname
     
     def visitfile(file):
         print 'visiting', file
     
     if __name__ == '__main__':
         walktree(sys.argv[1], visitfile)


File: python-lib.info,  Node: statcache,  Next: statvfs,  Prev: stat,  Up: Generic Operating System Services

An optimization of `os.stat()'
==============================

Stat files, and remember results.

_This is deprecated in Python 2.2.  Use ``os'.stat()' directly instead
of using the cache; the cache introduces a very high level of fragility
in applications using it and complicates application code with the
addition of cache management support._

The `statcache' module provides a simple optimization to `os.stat()':
remembering the values of previous invocations.

The `statcache' module defines the following functions:

`stat(path)'
     This is the main module entry-point.  Identical for `os.stat()',
     except for remembering the result for future invocations of the
     function.

The rest of the functions are used to clear the cache, or parts of it.

`reset()'
     Clear the cache: forget all results of previous `stat()' calls.

`forget(path)'
     Forget the result of `stat(PATH)', if any.

`forget_prefix(prefix)'
     Forget all results of `stat(PATH)' for PATH starting with PREFIX.

`forget_dir(prefix)'
     Forget all results of `stat(PATH)' for PATH a file in the
     directory PREFIX, including `stat(PREFIX)'.

`forget_except_prefix(prefix)'
     Similar to `forget_prefix()', but for all PATH values _not_
     starting with PREFIX.

Example:

     >>> import os, statcache
     >>> statcache.stat('.')
     (16893, 2049, 772, 18, 1000, 1000, 2048, 929609777, 929609777, 929609777)
     >>> os.stat('.')
     (16893, 2049, 772, 18, 1000, 1000, 2048, 929609777, 929609777, 929609777)


File: python-lib.info,  Node: statvfs,  Next: filecmp,  Prev: statcache,  Up: Generic Operating System Services

Constants used with `os.statvfs()'
==================================

Constants for interpreting the result of `os.statvfs()'.

The `statvfs' module defines constants so interpreting the result if
`os.statvfs()', which returns a tuple, can be made without remembering
"magic numbers."  Each of the constants defined in this module is the
_index_ of the entry in the tuple returned by `os.statvfs()' that
contains the specified information.

`F_BSIZE'
     Preferred file system block size.

`F_FRSIZE'
     Fundamental file system block size.

`F_BLOCKS'
     Total number of blocks in the filesystem.

`F_BFREE'
     Total number of free blocks.

`F_BAVAIL'
     Free blocks available to non-super user.

`F_FILES'
     Total number of file nodes.

`F_FFREE'
     Total number of free file nodes.

`F_FAVAIL'
     Free nodes available to non-super user.

`F_FLAG'
     Flags. System dependent: see `statvfs()' man page.

`F_NAMEMAX'
     Maximum file name length.


File: python-lib.info,  Node: filecmp,  Next: popen2,  Prev: statvfs,  Up: Generic Operating System Services

File and Directory Comparisons
==============================

Compare files efficiently.

The `filecmp' module defines functions to compare files and
directories, with various optional time/correctness trade-offs.

The `filecmp' module defines the following functions:

`cmp(f1, f2[, shallow[, use_statcache]])'
     Compare the files named F1 and F2, returning `True' if they seem
     equal, `False' otherwise.

     Unless SHALLOW is given and is false, files with identical
     `os.stat()' signatures are taken to be equal.  _Changed in Python
     version 2.3_

     Files that were compared using this function will not be compared
     again unless their `os.stat()' signature changes.

     Note that no external programs are called from this function,
     giving it portability and efficiency.

`cmpfiles(dir1, dir2, common[, shallow[, use_statcache]])'
     Returns three lists of file names: MATCH, MISMATCH, ERRORS.  MATCH
     contains the list of files match in both directories, MISMATCH
     includes the names of those that don't, and ERRROS lists the names
     of files which could not be compared.  Files may be listed in
     ERRORS because the user may lack permission to read them or many
     other reasons, but always that the comparison could not be done
     for some reason.

     The COMMON parameter is a list of file names found in both
     directories.  The SHALLOW and USE_STATCACHE parameters have the
     same meanings and default values as for `filecmp.cmp()'.

Example:

     >>> import filecmp
     >>> filecmp.cmp('libundoc.tex', 'libundoc.tex')
     True
     >>> filecmp.cmp('libundoc.tex', 'lib.tex')
     False

* Menu:

* dircmp class::


File: python-lib.info,  Node: dircmp class,  Prev: filecmp,  Up: filecmp

The `dircmp' class
------------------

`dircmp' instances are built using this constructor:

`dircmp(a, b[, ignore[, hide]])'
     Construct a new directory comparison object, to compare the
     directories A and B. IGNORE is a list of names to ignore, and
     defaults to `['RCS', 'CVS', 'tags']'. HIDE is a list of names to
     hide, and defaults to `[os.curdir, os.pardir]'.

The `dircmp' class provides the following methods:

`report()'
     Print (to `sys.stdout') a comparison between A and B.

`report_partial_closure()'
     Print a comparison between A and B and common immediate
     subdirctories.

`report_full_closure()'
     Print a comparison between A and B and common subdirctories
     (recursively).

The `dircmp' offers a number of interesting attributes that may be used
to get various bits of information about the directory trees being
compared.

Note that via `__getattr__()' hooks, all attributes are computed
lazilly, so there is no speed penalty if only those attributes which
are lightweight to compute are used.

`left_list'
     Files and subdirectories in A, filtered by HIDE and IGNORE.

`right_list'
     Files and subdirectories in B, filtered by HIDE and IGNORE.

`common'
     Files and subdirectories in both A and B.

`left_only'
     Files and subdirectories only in A.

`right_only'
     Files and subdirectories only in B.

`common_dirs'
     Subdirectories in both A and B.

`common_files'
     Files in both A and B

`common_funny'
     Names in both A and B, such that the type differs between the
     directories, or names for which `os.stat()' reports an error.

`same_files'
     Files which are identical in both A and B.

`diff_files'
     Files which are in both A and B, whose contents differ.

`funny_files'
     Files which are in both A and B, but could not be compared.

`subdirs'
     A dictionary mapping names in `common_dirs' to `dircmp' objects.


File: python-lib.info,  Node: popen2,  Next: datetime,  Prev: filecmp,  Up: Generic Operating System Services

Subprocesses with accessible I/O streams
========================================

Subprocesses with accessible standard I/O streams.

This module allows you to spawn processes and connect to their
input/output/error pipes and obtain their return codes under UNIX and
Windows.

Note that starting with Python 2.0, this functionality is available
using functions from the `os' module which have the same names as the
factory functions here, but the order of the return values is more
intuitive in the `os' module variants.

The primary interface offered by this module is a trio of factory
functions.  For each of these, if BUFSIZE is specified, it specifies
the buffer size for the I/O pipes.  MODE, if provided, should be the
string `'b'' or `'t''; on Windows this is needed to determine whether
the file objects should be opened in binary or text mode.  The default
value for MODE is `'t''.

The only way to retrieve the return codes for the child processes is by
using the `poll()' or `wait()' methods on the `Popen3' and `Popen4'
classes; these are only available on UNIX.  This information is not
available when using the `popen2()', `popen3()', and `popen4()'
functions, or the equivalent functions in the `os' module.

`popen2(cmd[, bufsize[, mode]])'
     Executes CMD as a sub-process.  Returns the file objects
     `(CHILD_STDOUT, CHILD_STDIN)'.

`popen3(cmd[, bufsize[, mode]])'
     Executes CMD as a sub-process.  Returns the file objects
     `(CHILD_STDOUT, CHILD_STDIN, CHILD_STDERR)'.

`popen4(cmd[, bufsize[, mode]])'
     Executes CMD as a sub-process.  Returns the file objects
     `(CHILD_STDOUT_AND_STDERR, CHILD_STDIN)'.  _Added in Python
     version 2.0_

On UNIX, a class defining the objects returned by the factory functions
is also available.  These are not used for the Windows implementation,
and are not available on that platform.

`Popen3(cmd[, capturestderr[, bufsize]])'
     This class represents a child process.  Normally, `Popen3'
     instances are created using the `popen2()' and `popen3()' factory
     functions described above.

     If not using one of the helper functions to create `Popen3'
     objects, the parameter CMD is the shell command to execute in a
     sub-process.  The CAPTURESTDERR flag, if true, specifies that the
     object should capture standard error output of the child process.
     The default is false.  If the BUFSIZE parameter is specified, it
     specifies the size of the I/O buffers to/from the child process.

`Popen4(cmd[, bufsize])'
     Similar to `Popen3', but always captures standard error into the
     same file object as standard output.  These are typically created
     using `popen4()'.  _Added in Python version 2.0_

* Menu:

* Popen3 and Popen4 Objects::
* Flow Control Issues::


File: python-lib.info,  Node: Popen3 and Popen4 Objects,  Next: Flow Control Issues,  Prev: popen2,  Up: popen2

Popen3 and Popen4 Objects
-------------------------

Instances of the `Popen3' and `Popen4' classes have the following
methods:

`poll()'
     Returns `-1' if child process hasn't completed yet, or its return
     code otherwise.

`wait()'
     Waits for and returns the status code of the child process.  The
     status code encodes both the return code of the process and
     information about whether it exited using the `exit()' system call
     or died due to a signal.  Functions to help interpret the status
     code are defined in the `os' module; see section *Note Process
     Management:: for the `W*()' family of functions.

The following attributes are also available:

`fromchild'
     A file object that provides output from the child process.  For
     `Popen4' instances, this will provide both the standard output and
     standard error streams.

`tochild'
     A file object that provides input to the child process.

`childerr'
     Where the standard error from the child process goes is
     CAPTURESTDERR was true for the constructor, or `None'.  This will
     always be `None' for `Popen4' instances.

`pid'
     The process ID of the child process.


File: python-lib.info,  Node: Flow Control Issues,  Prev: Popen3 and Popen4 Objects,  Up: popen2

Flow Control Issues
-------------------

Any time you are working with any form of inter-process communication,
control flow needs to be carefully thought out.  This remains the case
with the file objects provided by this module (or the `os' module
equivalents).

When reading output from a child process that writes a lot of data to
standard error while the parent is reading from the child's standard
output, a deadlock can occur.  A similar situation can occur with other
combinations of reads and writes.  The essential factors are that more
than `_PC_PIPE_BUF' bytes are being written by one process in a
blocking fashion, while the other process is reading from the other
process, also in a blocking fashion.

There are several ways to deal with this situation.

The simplest application change, in many cases, will be to follow this
model in the parent process:

     import popen2
     
     r, w, e = popen2.popen3('python slave.py')
     e.readlines()
     r.readlines()
     r.close()
     e.close()
     w.close()

with code like this in the child:

     import os
     import sys
     
     # note that each of these print statements
     # writes a single long string
     
     print >>sys.stderr, 400 * 'this is a test\n'
     os.close(sys.stderr.fileno())
     print >>sys.stdout, 400 * 'this is another test\n'

In particular, note that `sys.stderr' must be closed after writing all
data, or `readlines()' won't return.  Also note that `os.close()' must
be used, as `sys.stderr.close()' won't close `stderr' (otherwise
assigning to `sys.stderr' will silently close it, so no further errors
can be printed).

Applications which need to support a more general approach should
integrate I/O over pipes with their `select()' loops, or use separate
threads to read each of the individual files provided by whichever
`popen*()' function or `Popen*' class was used.

