This is python-lib.info, produced by makeinfo version 4.3 from
python-lib.texi.

October 3, 2003


File: python-lib.info,  Node: asyncore,  Next: asynchat,  Prev: DocXMLRPCServer,  Up: Internet Protocols and Support

Asynchronous socket handler
===========================

A base class for developing asynchronous socket  handling services.

This module provides the basic infrastructure for writing asynchronous
socket service clients and servers.

There are only two ways to have a program on a single processor do
"more than one thing at a time." Multi-threaded programming is the
simplest and most popular way to do it, but there is another very
different technique, that lets you have nearly all the advantages of
multi-threading, without actually using multiple threads.  It's really
only practical if your program is largely I/O bound.  If your program
is processor bound, then pre-emptive scheduled threads are probably what
you really need. Network servers are rarely processor bound, however.

If your operating system supports the `select()' system call in its I/O
library (and nearly all do), then you can use it to juggle multiple
communication channels at once; doing other work while your I/O is
taking place in the "background."  Although this strategy can seem
strange and complex, especially at first, it is in many ways easier to
understand and control than multi-threaded programming.  The `asyncore'
module solves many of the difficult problems for you, making the task
of building sophisticated high-performance network servers and clients
a snap. For "conversational" applications and protocols the companion
`asynchat' module is invaluable.

The basic idea behind both modules is to create one or more network
_channels_, instances of class `asyncore.dispatcher' and
`asynchat.async_chat'. Creating the channels adds them to a global map,
used by the `loop()' function if you do not provide it with your own
MAP.

Once the initial channel(s) is(are) created, calling the `loop()'
function activates channel service, which continues until the last
channel (including any that have been added to the map during
asynchronous service) is closed.

`loop([timeout[, use_poll[, map]]])'
     Enter a polling loop that only terminates after all open channels
     have been closed.  All arguments are optional.  The TIMEOUT
     argument sets the timeout parameter for the appropriate `select()'
     or `poll()' call, measured in seconds; the default is 30 seconds.
     The USE_POLL parameter, if true, indicates that `poll()' should be
     used in preference to `select()' (the default is `False').  The
     MAP parameter is a dictionary whose items are the channels to
     watch.  As channels are closed they are deleted from their map.
     If MAP is omitted, a global map is used (this map is updated by
     the default class `__init__()' - make sure you extend, rather than
     override, `__init__()' if you want to retain this behavior).

     Channels (instances of `asyncore.dispatcher', `asynchat.async_chat'
     and subclasses thereof) can freely be mixed in the map.

`dispatcher()'
     The `dispatcher' class is a thin wrapper around a low-level socket
     object.  To make it more useful, it has a few methods for
     event-handling  which are called from the asynchronous loop.
     Otherwise, it can be treated as a normal non-blocking socket
     object.

     Two class attributes can be modified, to improve performance, or
     possibly even to conserve memory.

    `ac_in_buffer_size'
          The asynchronous input buffer size (default `4096').

    `ac_out_buffer_size'
          The asynchronous output buffer size (default `4096').

     The firing of low-level events at certain times or in certain
     connection states tells the asynchronous loop that certain
     higher-level events have taken place. For example, if we have
     asked for a socket to connect to another host, we know that the
     connection has been made when the socket becomes writable for the
     first time (at this point you know that you may write to it with
     the expectation of success). The implied higher-level events are:

     Event                              Description
     ------                             -----
     handle_connect()                   Implied by the first write event
     handle_close()                     Implied by a read event with no
                                        data available
     handle_accept()                    Implied by a read event on a
                                        listening socket

     During asynchronous processing, each mapped channel's `readable()'
     and `writable()' methods are used to determine whether the
     channel's socket should be added to the list of channels
     `select()'ed or `poll()'ed for read and write events.

Thus, the set of channel events is larger than the basic socket events.
The full set of methods that can be overridden in your subclass follows:

`handle_read()'
     Called when the asynchronous loop detects that a `read()' call on
     the channel's socket will succeed.

`handle_write()'
     Called when the asynchronous loop detects that a writable socket
     can be written.  Often this method will implement the necessary
     buffering for performance.  For example:

          def handle_write(self):
              sent = self.send(self.buffer)
              self.buffer = self.buffer[sent:]

`handle_expt()'
     Called when there is out of band (OOB) data for a socket
     connection.  This will almost never happen, as OOB is tenuously
     supported and rarely used.

`handle_connect()'
     Called when the active opener's socket actually makes a connection.
     Might send a "welcome" banner, or initiate a protocol negotiation
     with the remote endpoint, for example.

`handle_close()'
     Called when the socket is closed.

`handle_error()'
     Called when an exception is raised and not otherwise handled.  The
     default version prints a condensed traceback.

`handle_accept()'
     Called on listening channels (passive openers) when a connection
     can be established with a new remote endpoint that has issued a
     `connect()' call for the local endpoint.

`readable()'
     Called each time around the asynchronous loop to determine whether
     a channel's socket should be added to the list on which read
     events can occur.  The default method simply returns `True',
     indicating that by default, all channels will be interested in
     read events.

`writable()'
     Called each time around the asynchronous loop to determine whether
     a channel's socket should be added to the list on which write
     events can occur.  The default method simply returns `True',
     indicating that by default, all channels will be interested in
     write events.

In addition, each channel delegates or extends many of the socket
methods.  Most of these are nearly identical to their socket partners.

`create_socket(family, type)'
     This is identical to the creation of a normal socket, and will use
     the same options for creation.  Refer to the `socket'
     documentation for information on creating sockets.

`connect(address)'
     As with the normal socket object, ADDRESS is a tuple with the
     first element the host to connect to, and the second the port
     number.

`send(data)'
     Send DATA to the remote end-point of the socket.

`recv(buffer_size)'
     Read at most BUFFER_SIZE bytes from the socket's remote end-point.
     An empty string implies that the channel has been closed from the
     other end.

`listen(backlog)'
     Listen for connections made to the socket.  The BACKLOG argument
     specifies the maximum number of queued connections and should be
     at least 1; the maximum value is system-dependent (usually 5).

`bind(address)'
     Bind the socket to ADDRESS.  The socket must not already be bound.
     (The format of ADDRESS depends on the address family -- see
     above.)

`accept()'
     Accept a connection.  The socket must be bound to an address and
     listening for connections.  The return value is a pair `(CONN,
     ADDRESS)' where CONN is a _new_ socket object usable to send and
     receive data on the connection, and ADDRESS is the address bound
     to the socket on the other end of the connection.

`close()'
     Close the socket.  All future operations on the socket object will
     fail.  The remote end-point will receive no more data (after
     queued data is flushed).  Sockets are automatically closed when
     they are garbage-collected.

* Menu:

* asyncore Example basic HTTP client::


File: python-lib.info,  Node: asyncore Example basic HTTP client,  Prev: asyncore,  Up: asyncore

asyncore Example basic HTTP client
----------------------------------

As a basic example, below is a very basic HTTP client that uses the
`dispatcher' class to implement its socket handling:

     class http_client(asyncore.dispatcher):
         def __init__(self, host,path):
             asyncore.dispatcher.__init__(self)
             self.path = path
             self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
             self.connect( (host, 80) )
             self.buffer = 'GET %s HTTP/1.0\r\n\r\n' % self.path
     
         def handle_connect(self):
             pass
     
         def handle_read(self):
             data = self.recv(8192)
             print data
     
         def writable(self):
             return (len(self.buffer) > 0)
     
         def handle_write(self):
             sent = self.send(self.buffer)
             self.buffer = self.buffer[sent:]


File: python-lib.info,  Node: asynchat,  Prev: asyncore,  Up: Internet Protocols and Support

Asynchronous socket command/response handler
============================================

Support for asynchronous command/response protocols.

This module builds on the `asyncore' infrastructure, simplifying
asynchronous clients and servers and making it easier to handle
protocols whose elements are terminated by arbitrary strings, or are of
variable length. `asynchat' defines the abstract class `async_chat'
that you subclass, providing implementations of the
`collect_incoming_data()' and `found_terminator()' methods. It uses the
same asynchronous loop as `asyncore', and the two types of channel,
`asyncore.dispatcher' and `asynchat.async_chat', can freely be mixed in
the channel map.  Typically an `asyncore.dispatcher' server channel
generates new `asynchat.async_chat' channel objects as it receives
incoming connection requests.

`async_chat()'
     This class is an abstract subclass of `asyncore.dispatcher'. To
     make practical use of the code you must subclass `async_chat',
     providing meaningful `collect_incoming_data()' and
     `found_terminator()' methods. The `asyncore.dispatcher' methods
     can be used, although not all make sense in a message/response
     context.

     Like `asyncore.dispatcher', `async_chat' defines a set of events
     that are generated by an analysis of socket conditions after a
     `select()' call. Once the polling loop has been started the
     `async_chat' object's methods are called by the event-processing
     framework with no action on the part of the programmer.

     Unlike `asyncore.dispatcher', `async_chat' allows you to define a
     first-in-first-out queue (fifo) of _producers_. A producer need
     have only one method, `more()', which should return data to be
     transmitted on the channel. The producer indicates exhaustion
     (_i.e._ that it contains no more data) by having its `more()'
     method return the empty string. At this point the `async_chat'
     object removes the producer from the fifo and starts using the
     next producer, if any. When the producer fifo is empty the
     `handle_write()' method does nothing. You use the channel object's
     `set_terminator()' method to describe how to recognize the end of,
     or an important breakpoint in, an incoming transmission from the
     remote endpoint.

     To build a functioning `async_chat' subclass your input methods
     `collect_incoming_data()' and `found_terminator()' must handle the
     data that the channel receives asynchronously. The methods are
     described below.

`close_when_done()'
     Pushes a `None' on to the producer fifo. When this producer is
     popped off the fifo it causes the channel to be closed.

`collect_incoming_data(data)'
     Called with DATA holding an arbitrary amount of received data.
     The default method, which must be overridden, raises a
     `NotImplementedError' exception.

`discard_buffers()'
     In emergencies this method will discard any data held in the input
     and/or output buffers and the producer fifo.

`found_terminator()'
     Called when the incoming data stream  matches the termination
     condition set by `set_terminator'. The default method, which must
     be overridden, raises a `NotImplementedError' exception. The
     buffered input data should be available via an instance attribute.

`get_terminator()'
     Returns the current terminator for the channel.

`handle_close()'
     Called when the channel is closed. The default method silently
     closes the channel's socket.

`handle_read()'
     Called when a read event fires on the channel's socket in the
     asynchronous loop. The default method checks for the termination
     condition established by `set_terminator()', which can be either
     the appearance of a particular string in the input stream or the
     receipt of a particular number of characters. When the terminator
     is found, `handle_read' calls the `found_terminator()' method after
     calling `collect_incoming_data()' with any data preceding the
     terminating condition.

`handle_write()'
     Called when the application may write data to the channel.  The
     default method calls the `initiate_send()' method, which in turn
     will call `refill_buffer()' to collect data from the producer fifo
     associated with the channel.

`push(data)'
     Creates a `simple_producer' object (_see below_) containing the
     data and pushes it on to the channel's `producer_fifo' to ensure
     its transmission. This is all you need to do to have the channel
     write the data out to the network, although it is possible to use
     your own producers in more complex schemes to implement encryption
     and chunking, for example.

`push_with_producer(producer)'
     Takes a producer object and adds it to the producer fifo
     associated with the channel. When all currently-pushed producers
     have been exhausted the channel will consume this producer's data
     by calling its `more()' method and send the data to the remote
     endpoint.

`readable()'
     Should return `True' for the channel to be included in the set of
     channels tested by the `select()' loop for readability.

`refill_buffer()'
     Refills the output buffer by calling the `more()' method of the
     producer at the head of the fifo. If it is exhausted then the
     producer is popped off the fifo and the next producer is activated.
     If the current producer is, or becomes, `None' then the channel is
     closed.

`set_terminator(term)'
     Sets the terminating condition to be recognised on the channel.
     `term' may be any of three types of value, corresponding to three
     different ways to handle incoming protocol data.

     term                               Description
     ------                             -----
     _string_                           Will call `found_terminator()'
                                        when the string is found in the
                                        input stream
     _integer_                          Will call `found_terminator()'
                                        when the indicated number of
                                        characters have been received
     `None'                             The channel continues to collect
                                        data forever

     Note that any data following the terminator will be available for
     reading by the channel after `found_terminator()' is called.

`writable()'
     Should return `True' as long as items remain on the producer fifo,
     or the channel is connected and the channel's output buffer is
     non-empty.

* Menu:

* asynchat - Auxiliary Classes and Functions::
* asynchat Example::


File: python-lib.info,  Node: asynchat - Auxiliary Classes and Functions,  Next: asynchat Example,  Prev: asynchat,  Up: asynchat

asynchat - Auxiliary Classes and Functions
------------------------------------------

`simple_producer(data[, buffer_size=512])'
     A `simple_producer' takes a chunk of data and an optional buffer
     size.  Repeated calls to its `more()' method yield successive
     chunks of the data no larger than BUFFER_SIZE.

`more()'
     Produces the next chunk of information from the producer, or
     returns the empty string.

`fifo([list=None])'
     Each channel maintains a `fifo' holding data which has been pushed
     by the application but not yet popped for writing to the channel.
     A `fifo' is a list used to hold data and/or producers until they
     are required.  If the LIST argument is provided then it should
     contain producers or data items to be written to the channel.

`is_empty()'
     Returns `True' iff the fifo is empty.

`first()'
     Returns the least-recently `push()'ed item from the fifo.

`push(data)'
     Adds the given data (which may be a string or a producer object)
     to the producer fifo.

`pop()'
     If the fifo is not empty, returns `True, first()', deleting the
     popped item. Returns `False, None' for an empty fifo.

The `asynchat' module also defines one utility function, which may be
of use in network and textual analysis operations.

`find_prefix_at_end(haystack, needle)'
     Returns `True' if string HAYSTACK ends with any non-empty prefix
     of string NEEDLE.


File: python-lib.info,  Node: asynchat Example,  Prev: asynchat - Auxiliary Classes and Functions,  Up: asynchat

asynchat Example
----------------

The following partial example shows how HTTP requests can be read with
`async_chat'. A web server might create an `http_request_handler'
object for each incoming client connection. Notice that initially the
channel terminator is set to match the blank line at the end of the HTTP
headers, and a flag indicates that the headers are being read.

Once the headers have been read, if the request is of type POST
(indicating that further data are present in the input stream) then the
`Content-Length:' header is used to set a numeric terminator to read
the right amount of data from the channel.

The `handle_request()' method is called once all relevant input has
been marshalled, after setting the channel terminator to `None' to
ensure that any extraneous data sent by the web client are ignored.

     class http_request_handler(asynchat.async_chat):
     
         def __init__(self, conn, addr, sessions, log):
             asynchat.async_chat.__init__(self, conn=conn)
             self.addr = addr
             self.sessions = sessions
             self.ibuffer = []
             self.obuffer = ""
             self.set_terminator("\r\n\r\n")
             self.reading_headers = True
             self.handling = False
             self.cgi_data = None
             self.log = log
     
         def collect_incoming_data(self, data):
             """Buffer the data"""
             self.ibuffer.append(data)
     
         def found_terminator(self):
             if self.reading_headers:
                 self.reading_headers = False
                 self.parse_headers("".join(self.ibuffer))
                 self.ibuffer = []
                 if self.op.upper() == "POST":
                     clen = self.headers.getheader("content-length")
                     self.set_terminator(int(clen))
                 else:
                     self.handling = True
                     self.set_terminator(None)
                     self.handle_request()
             elif not self.handling:
                 self.set_terminator(None) # browsers sometimes over-send
                 self.cgi_data = parse(self.headers, "".join(self.ibuffer))
                 self.handling = True
                 self.ibuffer = []
                 self.handle_request()


File: python-lib.info,  Node: Internet Data Handling,  Next: Structured Markup Processing Tools,  Prev: Internet Protocols and Support,  Up: Top

Internet Data Handling
**********************

This chapter describes modules which support handling data formats
commonly used on the Internet.

* Menu:

* formatter::
* email::
* mailcap::
* mailbox::
* mhlib::
* mimetools::
* mimetypes::
* MimeWriter::
* mimify::
* multifile::
* rfc822::
* base64::
* binascii::
* binhex::
* quopri::
* uu::
* xdrlib::
* netrc::
* robotparser::
* csv::


File: python-lib.info,  Node: formatter,  Next: email,  Prev: Internet Data Handling,  Up: Internet Data Handling

Generic output formatting
=========================

Generic output formatter and device interface.

This module supports two interface definitions, each with multiple
implementations.  The _formatter_ interface is used by the `HTMLParser'
class of the `htmllib' module, and the _writer_ interface is required
by the formatter interface.

Formatter objects transform an abstract flow of formatting events into
specific output events on writer objects.  Formatters manage several
stack structures to allow various properties of a writer object to be
changed and restored; writers need not be able to handle relative
changes nor any sort of "change back" operation.  Specific writer
properties which may be controlled via formatter objects are horizontal
alignment, font, and left margin indentations.  A mechanism is provided
which supports providing arbitrary, non-exclusive style settings to a
writer as well.  Additional interfaces facilitate formatting events
which are not reversible, such as paragraph separation.

Writer objects encapsulate device interfaces.  Abstract devices, such
as file formats, are supported as well as physical devices.  The
provided implementations all work with abstract devices.  The interface
makes available mechanisms for setting the properties which formatter
objects manage and inserting data into the output.

* Menu:

* Formatter Interface::
* Formatter Implementations::
* Writer Interface::
* Writer Implementations::


File: python-lib.info,  Node: Formatter Interface,  Next: Formatter Implementations,  Prev: formatter,  Up: formatter

The Formatter Interface
-----------------------

Interfaces to create formatters are dependent on the specific formatter
class being instantiated.  The interfaces described below are the
required interfaces which all formatters must support once initialized.

One data element is defined at the module level:

`AS_IS'
     Value which can be used in the font specification passed to the
     `push_font()' method described below, or as the new value to any
     other `push_PROPERTY()' method.  Pushing the `AS_IS' value allows
     the corresponding `pop_PROPERTY()' method to be called without
     having to track whether the property was changed.

The following attributes are defined for formatter instance objects:

`writer'
     The writer instance with which the formatter interacts.

`end_paragraph(blanklines)'
     Close any open paragraphs and insert at least BLANKLINES before
     the next paragraph.

`add_line_break()'
     Add a hard line break if one does not already exist.  This does not
     break the logical paragraph.

`add_hor_rule(*args, **kw)'
     Insert a horizontal rule in the output.  A hard break is inserted
     if there is data in the current paragraph, but the logical
     paragraph is not broken.  The arguments and keywords are passed on
     to the writer's `send_line_break()' method.

`add_flowing_data(data)'
     Provide data which should be formatted with collapsed whitespace.
     Whitespace from preceding and successive calls to
     `add_flowing_data()' is considered as well when the whitespace
     collapse is performed.  The data which is passed to this method is
     expected to be word-wrapped by the output device.  Note that any
     word-wrapping still must be performed by the writer object due to
     the need to rely on device and font information.

`add_literal_data(data)'
     Provide data which should be passed to the writer unchanged.
     Whitespace, including newline and tab characters, are considered
     legal in the value of DATA.

`add_label_data(format, counter)'
     Insert a label which should be placed to the left of the current
     left margin.  This should be used for constructing bulleted or
     numbered lists.  If the FORMAT value is a string, it is
     interpreted as a format specification for COUNTER, which should be
     an integer.  The result of this formatting becomes the value of
     the label; if FORMAT is not a string it is used as the label value
     directly.  The label value is passed as the only argument to the
     writer's `send_label_data()' method.  Interpretation of non-string
     label values is dependent on the associated writer.

     Format specifications are strings which, in combination with a
     counter value, are used to compute label values.  Each character
     in the format string is copied to the label value, with some
     characters recognized to indicate a transform on the counter
     value.  Specifically, the character `1' represents the counter
     value formatter as an Arabic number, the characters `A' and `a'
     represent alphabetic representations of the counter value in upper
     and lower case, respectively, and `I' and `i' represent the
     counter value in Roman numerals, in upper and lower case.  Note
     that the alphabetic and roman transforms require that the counter
     value be greater than zero.

`flush_softspace()'
     Send any pending whitespace buffered from a previous call to
     `add_flowing_data()' to the associated writer object.  This should
     be called before any direct manipulation of the writer object.

`push_alignment(align)'
     Push a new alignment setting onto the alignment stack.  This may be
     `AS_IS' if no change is desired.  If the alignment value is
     changed from the previous setting, the writer's `new_alignment()'
     method is called with the ALIGN value.

`pop_alignment()'
     Restore the previous alignment.

`push_font(`('size, italic, bold, teletype`)')'
     Change some or all font properties of the writer object.
     Properties which are not set to `AS_IS' are set to the values
     passed in while others are maintained at their current settings.
     The writer's `new_font()' method is called with the fully resolved
     font specification.

`pop_font()'
     Restore the previous font.

`push_margin(margin)'
     Increase the number of left margin indentations by one, associating
     the logical tag MARGIN with the new indentation.  The initial
     margin level is `0'.  Changed values of the logical tag must be
     true values; false values other than `AS_IS' are not sufficient to
     change the margin.

`pop_margin()'
     Restore the previous margin.

`push_style(*styles)'
     Push any number of arbitrary style specifications.  All styles are
     pushed onto the styles stack in order.  A tuple representing the
     entire stack, including `AS_IS' values, is passed to the writer's
     `new_styles()' method.

`pop_style([n` = 1'])'
     Pop the last N style specifications passed to `push_style()'.  A
     tuple representing the revised stack, including `AS_IS' values, is
     passed to the writer's `new_styles()' method.

`set_spacing(spacing)'
     Set the spacing style for the writer.

`assert_line_data([flag` = 1'])'
     Inform the formatter that data has been added to the current
     paragraph out-of-band.  This should be used when the writer has
     been manipulated directly.  The optional FLAG argument can be set
     to false if the writer manipulations produced a hard line break at
     the end of the output.


File: python-lib.info,  Node: Formatter Implementations,  Next: Writer Interface,  Prev: Formatter Interface,  Up: formatter

Formatter Implementations
-------------------------

Two implementations of formatter objects are provided by this module.
Most applications may use one of these classes without modification or
subclassing.

`NullFormatter([writer])'
     A formatter which does nothing.  If WRITER is omitted, a
     `NullWriter' instance is created.  No methods of the writer are
     called by `NullFormatter' instances.  Implementations should
     inherit from this class if implementing a writer interface but
     don't need to inherit any implementation.

`AbstractFormatter(writer)'
     The standard formatter.  This implementation has demonstrated wide
     applicability to many writers, and may be used directly in most
     circumstances.  It has been used to implement a full-featured
     World Wide Web browser.


File: python-lib.info,  Node: Writer Interface,  Next: Writer Implementations,  Prev: Formatter Implementations,  Up: formatter

The Writer Interface
--------------------

Interfaces to create writers are dependent on the specific writer class
being instantiated.  The interfaces described below are the required
interfaces which all writers must support once initialized.  Note that
while most applications can use the `AbstractFormatter' class as a
formatter, the writer must typically be provided by the application.

`flush()'
     Flush any buffered output or device control events.

`new_alignment(align)'
     Set the alignment style.  The ALIGN value can be any object, but
     by convention is a string or `None', where `None' indicates that
     the writer's "preferred" alignment should be used.  Conventional
     ALIGN values are `'left'', `'center'', `'right'', and `'justify''.

`new_font(font)'
     Set the font style.  The value of FONT will be `None', indicating
     that the device's default font should be used, or a tuple of the
     form `('SIZE, ITALIC, BOLD, TELETYPE`)'.  Size will be a string
     indicating the size of font that should be used; specific strings
     and their interpretation must be defined by the application.  The
     ITALIC, BOLD, and TELETYPE values are Boolean values specifying
     which of those font attributes should be used.

`new_margin(margin, level)'
     Set the margin level to the integer LEVEL and the logical tag to
     MARGIN.  Interpretation of the logical tag is at the writer's
     discretion; the only restriction on the value of the logical tag
     is that it not be a false value for non-zero values of LEVEL.

`new_spacing(spacing)'
     Set the spacing style to SPACING.

`new_styles(styles)'
     Set additional styles.  The STYLES value is a tuple of arbitrary
     values; the value `AS_IS' should be ignored.  The STYLES tuple may
     be interpreted either as a set or as a stack depending on the
     requirements of the application and writer implementation.

`send_line_break()'
     Break the current line.

`send_paragraph(blankline)'
     Produce a paragraph separation of at least BLANKLINE blank lines,
     or the equivalent.  The BLANKLINE value will be an integer.  Note
     that the implementation will receive a call to `send_line_break()'
     before this call if a line break is needed; this method should not
     include ending the last line of the paragraph.  It is only
     responsible for vertical spacing between paragraphs.

`send_hor_rule(*args, **kw)'
     Display a horizontal rule on the output device.  The arguments to
     this method are entirely application- and writer-specific, and
     should be interpreted with care.  The method implementation may
     assume that a line break has already been issued via
     `send_line_break()'.

`send_flowing_data(data)'
     Output character data which may be word-wrapped and re-flowed as
     needed.  Within any sequence of calls to this method, the writer
     may assume that spans of multiple whitespace characters have been
     collapsed to single space characters.

`send_literal_data(data)'
     Output character data which has already been formatted for
     display.  Generally, this should be interpreted to mean that line
     breaks indicated by newline characters should be preserved and no
     new line breaks should be introduced.  The data may contain
     embedded newline and tab characters, unlike data provided to the
     `send_formatted_data()' interface.

`send_label_data(data)'
     Set DATA to the left of the current left margin, if possible.  The
     value of DATA is not restricted; treatment of non-string values is
     entirely application- and writer-dependent.  This method will only
     be called at the beginning of a line.


File: python-lib.info,  Node: Writer Implementations,  Prev: Writer Interface,  Up: formatter

Writer Implementations
----------------------

Three implementations of the writer object interface are provided as
examples by this module.  Most applications will need to derive new
writer classes from the `NullWriter' class.

`NullWriter()'
     A writer which only provides the interface definition; no actions
     are taken on any methods.  This should be the base class for all
     writers which do not need to inherit any implementation methods.

`AbstractWriter()'
     A writer which can be used in debugging formatters, but not much
     else.  Each method simply announces itself by printing its name and
     arguments on standard output.

`DumbWriter([file[, maxcol` = 72']])'
     Simple writer class which writes output on the file object passed
     in as FILE or, if FILE is omitted, on standard output.  The output
     is simply word-wrapped to the number of columns specified by
     MAXCOL.  This class is suitable for reflowing a sequence of
     paragraphs.


File: python-lib.info,  Node: email,  Next: mailcap,  Prev: formatter,  Up: Internet Data Handling

An email and MIME handling package
==================================

Package supporting the parsing, manipulating, and generating email
messages, including MIME documents.

_Added in Python version 2.2_

The `email' package is a library for managing email messages, including
MIME and other RFC 2822 -based message documents.  It subsumes most of
the functionality in several older standard modules such as `rfc822',
`mimetools', `multifile', and other non-standard packages such as
`mimecntl'.  It is specifically _not_ designed to do any sending of
email messages to SMTP (RFC 2821 ) servers; that is the function of the
`smtplib' module.  The `email' package attempts to be as RFC-compliant
as possible, supporting in addition to RFC 2822 , such MIME-related
RFCs as RFC 2045 -RFC 2047 , and RFC 2231 .

The primary distinguishing feature of the `email' package is that it
splits the parsing and generating of email messages from the internal
_object model_ representation of email.  Applications using the `email'
package deal primarily with objects; you can add sub-objects to
messages, remove sub-objects from messages, completely re-arrange the
contents, etc.  There is a separate parser and a separate generator
which handles the transformation from flat text to the object model,
and then back to flat text again.  There are also handy subclasses for
some common MIME object types, and a few miscellaneous utilities that
help with such common tasks as extracting and parsing message field
values, creating RFC-compliant dates, etc.

The following sections describe the functionality of the `email'
package.  The ordering follows a progression that should be common in
applications: an email message is read as flat text from a file or
other source, the text is parsed to produce the object structure of the
email message, this structure is manipulated, and finally rendered back
into flat text.

It is perfectly feasible to create the object structure out of whole
cloth -- i.e. completely from scratch.  From there, a similar
progression can be taken as above.

Also included are detailed specifications of all the classes and
modules that the `email' package provides, the exception classes you
might encounter while using the `email' package, some auxiliary
utilities, and a few examples.  For users of the older `mimelib'
package, or previous versions of the `email' package, a section on
differences and porting is provided.

See also:
     *Note smtplib:: SMTP protocol client

* Menu:

* Representing an email message::
* Parsing email messages::
* Generating MIME documents::
* Creating email and MIME objects from scratch::
* Internationalized headers::
* Representing character sets::
* Encoders::
* Exception classes::
* Miscellaneous utilities::
* Iterators::
* Differences from email v1 up to Python 221::
* Differences from mimelib::
* Examples 10::

