This is python-lib.info, produced by makeinfo version 4.3 from
python-lib.texi.

October 3, 2003


File: python-lib.info,  Node: DatagramHandler,  Next: SysLogHandler,  Prev: SocketHandler,  Up: Handler Objects

DatagramHandler
...............

The `DatagramHandler' class inherits from `SocketHandler' to support
sending logging messages over UDP sockets.

`DatagramHandler(host, port)'
     Returns a new instance of the `DatagramHandler' class intended to
     communicate with a remote machine whose address is given by HOST
     and PORT.

`emit()'
     Pickles the record's attribute dictionary and writes it to the
     socket in binary format. If there is an error with the socket,
     silently drops the packet.  To unpickle the record at the
     receiving end into a LogRecord, use the `makeLogRecord' function.

`makeSocket()'
     The factory method of `SocketHandler' is here overridden to create
     a UDP socket (`socket.SOCK_DGRAM').

`send(s)'
     Send a pickled string to a socket.


File: python-lib.info,  Node: SysLogHandler,  Next: NTEventLogHandler,  Prev: DatagramHandler,  Up: Handler Objects

SysLogHandler
.............

The `SysLogHandler' class supports sending logging messages to a remote
or local UNIX syslog.

`SysLogHandler([address[, facility]])'
     Returns a new instance of the `SysLogHandler' class intended to
     communicate with a remote UNIX machine whose address is given by
     ADDRESS in the form of a `(HOST, PORT)' tuple.  If ADDRESS is not
     specified, `('localhost', 514)' is used.  The address is used to
     open a UDP socket.  If FACILITY is not specified, `LOG_USER' is
     used.

`close()'
     Closes the socket to the remote host.

`emit(record)'
     The record is formatted, and then sent to the syslog server. If
     exception information is present, it is _not_ sent to the server.

`encodePriority(facility, priority)'
     Encodes the facility and priority into an integer. You can pass in
     strings or integers - if strings are passed, internal mapping
     dictionaries are used to convert them to integers.


File: python-lib.info,  Node: NTEventLogHandler,  Next: SMTPHandler,  Prev: SysLogHandler,  Up: Handler Objects

NTEventLogHandler
.................

The `NTEventLogHandler' class supports sending logging messages to a
local Windows NT, Windows 2000 or Windows XP event log. Before you can
use it, you need Mark Hammond's Win32 extensions for Python installed.

`NTEventLogHandler(appname[, dllname[, logtype]])'
     Returns a new instance of the `NTEventLogHandler' class. The
     APPNAME is used to define the application name as it appears in the
     event log. An appropriate registry entry is created using this
     name.  The DLLNAME should give the fully qualified pathname of a
     .dll or .exe which contains message definitions to hold in the log
     (if not specified, `'win32service.pyd'' is used - this is
     installed with the Win32 extensions and contains some basic
     placeholder message definitions.  Note that use of these
     placeholders will make your event logs big, as the entire message
     source is held in the log. If you want slimmer logs, you have to
     pass in the name of your own .dll or .exe which contains the
     message definitions you want to use in the event log). The LOGTYPE
     is one of `'Application'', `'System'' or `'Security'', and
     defaults to `'Application''.

`close()'
     At this point, you can remove the application name from the
     registry as a source of event log entries. However, if you do
     this, you will not be able to see the events as you intended in
     the Event Log Viewer - it needs to be able to access the registry
     to get the .dll name. The current version does not do this (in
     fact it doesn't do anything).

`emit(record)'
     Determines the message ID, event category and event type, and then
     logs the message in the NT event log.

`getEventCategory(record)'
     Returns the event category for the record. Override this if you
     want to specify your own categories. This version returns 0.

`getEventType(record)'
     Returns the event type for the record. Override this if you want
     to specify your own types. This version does a mapping using the
     handler's typemap attribute, which is set up in `__init__()' to a
     dictionary which contains mappings for `DEBUG', `INFO', `WARNING',
     `ERROR' and `CRITICAL'. If you are using your own levels, you will
     either need to override this method or place a suitable dictionary
     in the handler's TYPEMAP attribute.

`getMessageID(record)'
     Returns the message ID for the record. If you are using your own
     messages, you could do this by having the MSG passed to the logger
     being an ID rather than a format string. Then, in here, you could
     use a dictionary lookup to get the message ID. This version
     returns 1, which is the base message ID in `win32service.pyd'.


File: python-lib.info,  Node: SMTPHandler,  Next: MemoryHandler,  Prev: NTEventLogHandler,  Up: Handler Objects

SMTPHandler
...........

The `SMTPHandler' class supports sending logging messages to an email
address via SMTP.

`SMTPHandler(mailhost, fromaddr, toaddrs, subject)'
     Returns a new instance of the `SMTPHandler' class. The instance is
     initialized with the from and to addresses and subject line of the
     email. The TOADDRS should be a list of strings without domain
     names (That's what the MAILHOST is for). To specify a non-standard
     SMTP port, use the (host, port) tuple format for the MAILHOST
     argument. If you use a string, the standard SMTP port is used.

`emit(record)'
     Formats the record and sends it to the specified addressees.

`getSubject(record)'
     If you want to specify a subject line which is record-dependent,
     override this method.


File: python-lib.info,  Node: MemoryHandler,  Next: HTTPHandler,  Prev: SMTPHandler,  Up: Handler Objects

MemoryHandler
.............

The `MemoryHandler' supports buffering of logging records in memory,
periodically flushing them to a "target" handler. Flushing occurs
whenever the buffer is full, or when an event of a certain severity or
greater is seen.

`MemoryHandler' is a subclass of the more general `BufferingHandler',
which is an abstract class. This buffers logging records in memory.
Whenever each record is added to the buffer, a check is made by calling
`shouldFlush()' to see if the buffer should be flushed.  If it should,
then `flush()' is expected to do the needful.

`BufferingHandler(capacity)'
     Initializes the handler with a buffer of the specified capacity.

`emit(record)'
     Appends the record to the buffer. If `shouldFlush()' returns true,
     calls `flush()' to process the buffer.

`flush()'
     You can override this to implement custom flushing behavior. This
     version just zaps the buffer to empty.

`shouldFlush(record)'
     Returns true if the buffer is up to capacity. This method can be
     overridden to implement custom flushing strategies.

`MemoryHandler(capacity[, flushLevel [, target]])'
     Returns a new instance of the `MemoryHandler' class. The instance
     is initialized with a buffer size of CAPACITY. If FLUSHLEVEL is
     not specified, `ERROR' is used. If no TARGET is specified, the
     target will need to be set using `setTarget()' before this handler
     does anything useful.

`close()'
     Calls `flush()', sets the target to `None' and clears the buffer.

`flush()'
     For a `MemoryHandler', flushing means just sending the buffered
     records to the target, if there is one. Override if you want
     different behavior.

`setTarget(target)'
     Sets the target handler for this handler.

`shouldFlush(record)'
     Checks for buffer full or a record at the FLUSHLEVEL or higher.


File: python-lib.info,  Node: HTTPHandler,  Prev: MemoryHandler,  Up: Handler Objects

HTTPHandler
...........

The `HTTPHandler' class supports sending logging messages to a Web
server, using either `GET' or `POST' semantics.

`HTTPHandler(host, url[, method])'
     Returns a new instance of the `HTTPHandler' class. The instance is
     initialized with a host address, url and HTTP method.  If no
     METHOD is specified, `GET' is used.

`emit(record)'
     Sends the record to the Web server as an URL-encoded dictionary.


File: python-lib.info,  Node: Formatter Objects,  Next: Filter Objects,  Prev: Handler Objects,  Up: logging

Formatter Objects
-----------------

`Formatter's have the following attributes and methods. They are
responsible for converting a `LogRecord' to (usually) a string which
can be interpreted by either a human or an external system. The base
`Formatter' allows a formatting string to be specified. If none is
supplied, the default value of `'%(message)s\'' is used.

A Formatter can be initialized with a format string which makes use of
knowledge of the `LogRecord' attributes - such as the default value
mentioned above making use of the fact that the user's message and
arguments are pre-formatted into a LogRecord's MESSAGE attribute.  This
format string contains standard python %-style mapping keys. See
section *Note String Formatting Operations::, "String Formatting
Operations," for more information on string formatting.

Currently, the useful mapping keys in a LogRecord are:

Format                               Description
------                               -----
%(name)s                             Name of the logger (logging
                                     channel).
%(levelno)s                          Numeric logging level for the
                                     message (`DEBUG', `INFO',
                                     `WARNING', `ERROR', `CRITICAL').
%(levelname)s                        Text logging level for the message
                                     (`'DEBUG'', `'INFO'', `'WARNING'',
                                     `'ERROR'', `'CRITICAL'').
%(pathname)s                         Full pathname of the source file
                                     where the logging call was issued
                                     (if available).
%(filename)s                         Filename portion of pathname.
%(module)s                           Module (name portion of filename).
%(lineno)d                           Source line number where the
                                     logging call was issued (if
                                     available).
%(created)f                          Time when the LogRecord was created
                                     (as returned by `time.time()').
%(asctime)s                          Human-readable time when the
                                     LogRecord was created. By default
                                     this is of the form "2003-07-08
                                     16:49:45,896" (the numbers after
                                     the comma are millisecond portion
                                     of the time).
%(msecs)d                            Millisecond portion of the time
                                     when the `LogRecord' was created.
%(thread)d                           Thread ID (if available).
%(process)d                          Process ID (if available).
%(message)s                          The logged message, computed as
                                     `msg % args'.

`Formatter([fmt[, datefmt]])'
     Returns a new instance of the `Formatter' class. The instance is
     initialized with a format string for the message as a whole, as
     well as a format string for the date/time portion of a message. If
     no FMT is specified, `'%(message)s'' is used. If no DATEFMT is
     specified, the ISO8601 date format is used.

`format(record)'
     The record's attribute dictionary is used as the operand to a
     string formatting operation. Returns the resulting string.  Before
     formatting the dictionary, a couple of preparatory steps are
     carried out. The MESSAGE attribute of the record is computed using
     MSG % ARGS. If the formatting string contains `'(asctime)'',
     `formatTime()' is called to format the event time. If there is
     exception information, it is formatted using `formatException()'
     and appended to the message.

`formatTime(record[, datefmt])'
     This method should be called from `format()' by a formatter which
     wants to make use of a formatted time. This method can be
     overridden in formatters to provide for any specific requirement,
     but the basic behavior is as follows: if DATEFMT (a string) is
     specified, it is used with `time.strftime()' to format the
     creation time of the record. Otherwise, the ISO8601 format is
     used. The resulting string is returned.

`formatException(exc_info)'
     Formats the specified exception information (a standard exception
     tuple as returned by `sys.exc_info()') as a string. This default
     implementation just uses `traceback.print_exception()'.  The
     resulting string is returned.


File: python-lib.info,  Node: Filter Objects,  Next: LogRecord Objects,  Prev: Formatter Objects,  Up: logging

Filter Objects
--------------

`Filter's can be used by `Handler's and `Logger's for more
sophisticated filtering than is provided by levels. The base filter
class only allows events which are below a certain point in the logger
hierarchy. For example, a filter initialized with "A.B" will allow
events logged by loggers "A.B", "A.B.C", "A.B.C.D", "A.B.D" etc. but
not "A.BB", "B.A.B" etc. If initialized with the empty string, all
events are passed.

`Filter([name])'
     Returns an instance of the `Filter' class. If NAME is specified,
     it names a logger which, together with its children, will have its
     events allowed through the filter. If no name is specified, allows
     every event.

`filter(record)'
     Is the specified record to be logged? Returns zero for no, nonzero
     for yes. If deemed appropriate, the record may be modified
     in-place by this method.


File: python-lib.info,  Node: LogRecord Objects,  Next: Thread Safety,  Prev: Filter Objects,  Up: logging

LogRecord Objects
-----------------

LogRecord instances are created every time something is logged. They
contain all the information pertinent to the event being logged. The
main information passed in is in msg and args, which are combined using
msg % args to create the message field of the record. The record also
includes information such as when the record was created, the source
line where the logging call was made, and any exception information to
be logged.

LogRecord has no methods; it's just a repository for information about
the logging event. The only reason it's a class rather than a
dictionary is to facilitate extension.

`LogRecord(name, lvl, pathname, lineno, msg, args, exc_info)'
     Returns an instance of `LogRecord' initialized with interesting
     information. The NAME is the logger name; LVL is the numeric
     level; PATHNAME is the absolute pathname of the source file in
     which the logging call was made; LINENO is the line number in that
     file where the logging call is found; MSG is the user-supplied
     message (a format string); ARGS is the tuple which, together with
     MSG, makes up the user message; and EXC_INFO is the exception
     tuple obtained by calling `sys.exc_info() '(or `None', if no
     exception information is available).


File: python-lib.info,  Node: Thread Safety,  Next: Configuration,  Prev: LogRecord Objects,  Up: logging

Thread Safety
-------------

The logging module is intended to be thread-safe without any special
work needing to be done by its clients. It achieves this though using
threading locks; there is one lock to serialize access to the module's
shared data, and each handler also creates a lock to serialize access
to its underlying I/O.


File: python-lib.info,  Node: Configuration,  Next: Using the logging package,  Prev: Thread Safety,  Up: logging

Configuration
-------------

* Menu:

* Configuration functions::
* Configuration file format::


File: python-lib.info,  Node: Configuration functions,  Next: Configuration file format,  Prev: Configuration,  Up: Configuration

Configuration functions
.......................

The following functions allow the logging module to be configured.
Before they can be used, you must import `logging.config'.  Their use
is optional -- you can configure the logging module entirely by making
calls to the main API (defined in `logging' itself) and defining
handlers which are declared either in `logging' or `logging.handlers'.

`fileConfig(fname[, defaults])'
     Reads the logging configuration from a ConfigParser-format file
     named FNAME. This function can be called several times from an
     application, allowing an end user the ability to select from
     various pre-canned configurations (if the developer provides a
     mechanism to present the choices and load the chosen
     configuration). Defaults to be passed to ConfigParser can be
     specified in the DEFAULTS argument.

`listen([port])'
     Starts up a socket server on the specified port, and listens for
     new configurations. If no port is specified, the module's default
     `DEFAULT_LOGGING_CONFIG_PORT' is used. Logging configurations will
     be sent as a file suitable for processing by `fileConfig()'.
     Returns a `Thread' instance on which you can call `start()' to
     start the server, and which you can `join()' when appropriate.  To
     stop the server, call `stopListening()'.

`stopListening()'
     Stops the listening server which was created with a call to
     `listen()'. This is typically called before calling `join()' on
     the return value from `listen()'.


File: python-lib.info,  Node: Configuration file format,  Prev: Configuration functions,  Up: Configuration

Configuration file format
.........................

The configuration file format understood by `fileConfig' is based on
ConfigParser functionality. The file must contain sections called
`[loggers]', `[handlers]' and `[formatters]' which identify by name the
entities of each type which are defined in the file. For each such
entity, there is a separate section which identified how that entity is
configured. Thus, for a logger named `log01' in the `[loggers]'
section, the relevant configuration details are held in a section
`[logger_log01]'. Similarly, a handler called `hand01' in the
`[handlers]' section will have its configuration held in a section
called `[handler_hand01]', while a formatter called `form01' in the
`[formatters]' section will have its configuration specified in a
section called `[formatter_form01]'. The root logger configuration must
be specified in a section called `[logger_root]'.

Examples of these sections in the file are given below.

     [loggers]
     keys=root,log02,log03,log04,log05,log06,log07
     
     [handlers]
     keys=hand01,hand02,hand03,hand04,hand05,hand06,hand07,hand08,hand09
     
     [formatters]
     keys=form01,form02,form03,form04,form05,form06,form07,form08,form09

The root logger must specify a level and a list of handlers. An example
of a root logger section is given below.

     [logger_root]
     level=NOTSET
     handlers=hand01

The `level' entry can be one of `DEBUG, INFO, WARNING, ERROR, CRITICAL'
or `NOTSET'. For the root logger only, `NOTSET' means that all messages
will be logged. Level values are `eval()'uated in the context of the
`logging' package's namespace.

The `handlers' entry is a comma-separated list of handler names, which
must appear in the `[handlers]' section. These names must appear in the
`[handlers]' section and have corresponding sections in the
configuration file.

For loggers other than the root logger, some additional information is
required. This is illustrated by the following example.

     [logger_parser]
     level=DEBUG
     handlers=hand01
     propagate=1
     qualname=compiler.parser

The `level' and `handlers' entries are interpreted as for the root
logger, except that if a non-root logger's level is specified as
`NOTSET', the system consults loggers higher up the hierarchy to
determine the effective level of the logger. The `propagate' entry is
set to 1 to indicate that messages must propagate to handlers higher up
the logger hierarchy from this logger, or 0 to indicate that messages
are *not* propagated to handlers up the hierarchy. The `qualname' entry
is the hierarchical channel name of the logger, for example, the name
used by the application to get the logger.

Sections which specify handler configuration are exemplified by the
following.

     [handler_hand01]
     class=StreamHandler
     level=NOTSET
     formatter=form01
     args=(sys.stdout,)

The `class' entry indicates the handler's class (as determined by
`eval()' in the `logging' package's namespace). The `level' is
interpreted as for loggers, and `NOTSET' is taken to mean "log
everything".

The `formatter' entry indicates the key name of the formatter for this
handler. If blank, a default formatter (`logging._defaultFormatter') is
used. If a name is specified, it must appear in the `[formatters]'
section and have a corresponding section in the configuration file.

The `args' entry, when `eval()'uated in the context of the `logging'
package's namespace, is the list of arguments to the constructor for
the handler class. Refer to the constructors for the relevant handlers,
or to the examples below, to see how typical entries are constructed.

     [handler_hand02]
     class=FileHandler
     level=DEBUG
     formatter=form02
     args=('python.log', 'w')
     
     [handler_hand03]
     class=handlers.SocketHandler
     level=INFO
     formatter=form03
     args=('localhost', handlers.DEFAULT_TCP_LOGGING_PORT)
     
     [handler_hand04]
     class=handlers.DatagramHandler
     level=WARN
     formatter=form04
     args=('localhost', handlers.DEFAULT_UDP_LOGGING_PORT)
     
     [handler_hand05]
     class=handlers.SysLogHandler
     level=ERROR
     formatter=form05
     args=(('localhost', handlers.SYSLOG_UDP_PORT), handlers.SysLogHandler.LOG_USER)
     
     [handler_hand06]
     class=NTEventLogHandler
     level=CRITICAL
     formatter=form06
     args=('Python Application', '', 'Application')
     
     [handler_hand07]
     class=SMTPHandler
     level=WARN
     formatter=form07
     args=('localhost', 'from@abc', ['user1@abc', 'user2@xyz'], 'Logger Subject')
     
     [handler_hand08]
     class=MemoryHandler
     level=NOTSET
     formatter=form08
     target=
     args=(10, ERROR)
     
     [handler_hand09]
     class=HTTPHandler
     level=NOTSET
     formatter=form09
     args=('localhost:9022', '/log', 'GET')

Sections which specify formatter configuration are typified by the
following.

     [formatter_form01]
     format=F1 %(asctime)s %(levelname)s %(message)s
     datefmt=

The `format' entry is the overall format string, and the `datefmt'
entry is the `strftime()'-compatible date/time format string. If empty,
the package substitutes ISO8601 format date/times, which is almost
equivalent to specifying the date format string "The ISO8601 format
also specifies milliseconds, which are appended to the result of using
the above format string, with a comma separator. An example time in
ISO8601 format is `2003-01-23 00:29:50,411'.


File: python-lib.info,  Node: Using the logging package,  Prev: Configuration,  Up: logging

Using the logging package
-------------------------

* Menu:

* Basic example - log to a file::


File: python-lib.info,  Node: Basic example - log to a file,  Prev: Using the logging package,  Up: Using the logging package

Basic example - log to a file
.............................

Here's a simple logging example that just logs to a file. In order, it
creates a `Logger' instance, then a `FileHandler' and a `Formatter'. It
attaches the `Formatter' to the `FileHandler', then the `FileHandler'
to the `Logger'.  Finally, it sets a debug level for the logger.

     import logging
     logger = logging.getLogger('myapp')
     hdlr = logging.FileHandler('/var/tmp/myapp.log')
     formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
     hdlr.setFormatter(formatter)
     logger.addHandler(hdlr)
     logger.setLevel(logging.WARNING)

We can use this logger object now to write entries to the log file:

     logger.error('We have a problem')
     logger.info('While this is just chatty')

If we look in the file that was created, we'll see something like this:
     2003-07-08 16:49:45,896 ERROR We have a problem

The info message was not written to the file - we called the `setLevel'
method to say we only wanted `WARNING' or worse, so the info message is
discarded.

The timestamp is of the form "year-month-day
hour:minutes:seconds,milliseconds."  Note that despite the three digits
of precision in the milliseconds field, not all systems provide time
with this much precision.


File: python-lib.info,  Node: Optional Operating System Services,  Next: Unix Specific Services,  Prev: Generic Operating System Services,  Up: Top

Optional Operating System Services
**********************************

The modules described in this chapter provide interfaces to operating
system features that are available on selected operating systems only.
The interfaces are generally modeled after the UNIX or C interfaces but
they are available on some other systems as well (e.g. Windows or NT).
Here's an overview:

* Menu:

* signal::
* socket::
* select::
* thread::
* threading::
* dummy_thread::
* dummy_threading::
* Queue::
* mmap::
* anydbm::
* dbhash::
* whichdb::
* bsddb::
* dumbdbm::
* zlib::
* gzip::
* bz2::
* zipfile::
* tarfile::
* readline::
* rlcompleter::


File: python-lib.info,  Node: signal,  Next: socket,  Prev: Optional Operating System Services,  Up: Optional Operating System Services

Set handlers for asynchronous events
====================================

Set handlers for asynchronous events.

This module provides mechanisms to use signal handlers in Python.  Some
general rules for working with signals and their handlers:

   * A handler for a particular signal, once set, remains installed
     until it is explicitly reset (Python emulates the BSD style
     interface regardless of the underlying implementation), with the
     exception of the handler for `SIGCHLD', which follows the
     underlying implementation.

   * There is no way to "block" signals temporarily from critical
     sections (since this is not supported by all UNIX flavors).

   * Although Python signal handlers are called asynchronously as far as
     the Python user is concerned, they can only occur between the
     "atomic" instructions of the Python interpreter.  This means that
     signals arriving during long calculations implemented purely in C
     (such as regular expression matches on large bodies of text) may be
     delayed for an arbitrary amount of time.

   * When a signal arrives during an I/O operation, it is possible that
     the I/O operation raises an exception after the signal handler
     returns.  This is dependent on the underlying UNIX system's
     semantics regarding interrupted system calls.

   * Because the C signal handler always returns, it makes little sense
     to catch synchronous errors like `SIGFPE' or `SIGSEGV'.

   * Python installs a small number of signal handlers by default:
     `SIGPIPE' is ignored (so write errors on pipes and sockets can be
     reported as ordinary Python exceptions) and `SIGINT' is translated
     into a `KeyboardInterrupt' exception.  All of these can be
     overridden.

   * Some care must be taken if both signals and threads are used in the
     same program.  The fundamental thing to remember in using signals
     and threads simultaneously is: always perform `signal()' operations
     in the main thread of execution.  Any thread can perform an
     `alarm()', `getsignal()', or `pause()'; only the main thread can
     set a new signal handler, and the main thread will be the only one
     to receive signals (this is enforced by the Python `signal'
     module, even if the underlying thread implementation supports
     sending signals to individual threads).  This means that signals
     can't be used as a means of inter-thread communication.  Use locks
     instead.


The variables defined in the `signal' module are:

`SIG_DFL'
     This is one of two standard signal handling options; it will simply
     perform the default function for the signal.  For example, on most
     systems the default action for `SIGQUIT' is to dump core and exit,
     while the default action for `SIGCLD' is to simply ignore it.

`SIG_IGN'
     This is another standard signal handler, which will simply ignore
     the given signal.

`SIG*'
     All the signal numbers are defined symbolically.  For example, the
     hangup signal is defined as `signal.SIGHUP'; the variable names
     are identical to the names used in C programs, as found in
     `<signal.h>'.  The UNIX man page for ``signal()'' lists the
     existing signals (on some systems this is `signal(2)', on others
     the list is in `signal(7)').  Note that not all systems define the
     same set of signal names; only those names defined by the system
     are defined by this module.

`NSIG'
     One more than the number of the highest signal number.

The `signal' module defines the following functions:

`alarm(time)'
     If TIME is non-zero, this function requests that a `SIGALRM'
     signal be sent to the process in TIME seconds.  Any previously
     scheduled alarm is canceled (only one alarm can be scheduled at
     any time).  The returned value is then the number of seconds
     before any previously set alarm was to have been delivered.  If
     TIME is zero, no alarm id scheduled, and any scheduled alarm is
     canceled.  The return value is the number of seconds remaining
     before a previously scheduled alarm.  If the return value is zero,
     no alarm is currently scheduled.  (See the UNIX man page
     `alarm(2)'.)  Availability: UNIX.

`getsignal(signalnum)'
     Return the current signal handler for the signal SIGNALNUM.  The
     returned value may be a callable Python object, or one of the
     special values `signal.SIG_IGN', `signal.SIG_DFL' or `None'.
     Here, `signal.SIG_IGN' means that the signal was previously
     ignored, `signal.SIG_DFL' means that the default way of handling
     the signal was previously in use, and `None' means that the
     previous signal handler was not installed from Python.

`pause()'
     Cause the process to sleep until a signal is received; the
     appropriate handler will then be called.  Returns nothing.  Not on
     Windows. (See the UNIX man page `signal(2)'.)

`signal(signalnum, handler)'
     Set the handler for signal SIGNALNUM to the function HANDLER.
     HANDLER can be a callable Python object taking two arguments (see
     below), or one of the special values `signal.SIG_IGN' or
     `signal.SIG_DFL'.  The previous signal handler will be returned
     (see the description of `getsignal()' above).  (See the UNIX man
     page `signal(2)'.)

     When threads are enabled, this function can only be called from the
     main thread; attempting to call it from other threads will cause a
     `ValueError' exception to be raised.

     The HANDLER is called with two arguments: the signal number and
     the current stack frame (`None' or a frame object; see the
     reference manual for a description of frame objects).

* Menu:

* Signal Example::


File: python-lib.info,  Node: Signal Example,  Prev: signal,  Up: signal

Example
-------

Here is a minimal example program. It uses the `alarm()' function to
limit the time spent waiting to open a file; this is useful if the file
is for a serial device that may not be turned on, which would normally
cause the `os.open()' to hang indefinitely.  The solution is to set a
5-second alarm before opening the file; if the operation takes too
long, the alarm signal will be sent, and the handler raises an
exception.

     import signal, os
     
     def handler(signum, frame):
         print 'Signal handler called with signal', signum
         raise IOError, "Couldn't open device!"
     
     # Set the signal handler and a 5-second alarm
     signal.signal(signal.SIGALRM, handler)
     signal.alarm(5)
     
     # This open() may hang indefinitely
     fd = os.open('/dev/ttyS0', os.O_RDWR)
     
     signal.alarm(0)          # Disable the alarm


File: python-lib.info,  Node: socket,  Next: select,  Prev: signal,  Up: Optional Operating System Services

Low-level networking interface
==============================

Low-level networking interface.

This module provides access to the BSD _socket_ interface.  It is
available on all modern UNIX systems, Windows, MacOS, BeOS, OS/2, and
probably additional platforms.

For an introduction to socket programming (in C), see the following
papers: , by Stuart Sechrest and , by Samuel J.  Leffler et al, both in
the (sections PS1:7 and PS1:8).  The platform-specific reference
material for the various socket-related system calls are also a
valuable source of information on the details of socket semantics.  For
UNIX, refer to the manual pages; for Windows, see the WinSock (or
Winsock 2) specification.  For IPv6-ready APIs, readers may want to
refer to RFC 2553 titled .

The Python interface is a straightforward transliteration of the UNIX
system call and library interface for sockets to Python's
object-oriented style: the `socket()' function returns a "socket object"
whose methods implement the various socket system calls.  Parameter
types are somewhat higher-level than in the C interface: as with
`read()' and `write()' operations on Python files, buffer allocation on
receive operations is automatic, and buffer length is implicit on send
operations.

Socket addresses are represented as follows: A single string is used
for the `AF_UNIX' address family.  A pair `(HOST, PORT)' is used for the
`AF_INET' address family, where HOST is a string representing either a
hostname in Internet domain notation like `'daring.cwi.nl'' or an IPv4
address like `'100.50.200.5'', and PORT is an integral port number.
For `AF_INET6' address family, a four-tuple `(HOST, PORT, FLOWINFO,
SCOPEID)' is used, where FLOWINFO and SCOPEID represents
`sin6_flowinfo' and `sin6_scope_id' member in `struct sockaddr_in6' in
C.  For `socket' module methods, FLOWINFO and SCOPEID can be omitted
just for backward compatibility. Note, however, omission of SCOPEID can
cause problems in manipulating scoped IPv6 addresses. Other address
families are currently not supported.  The address format required by a
particular socket object is automatically selected based on the address
family specified when the socket object was created.

For IPv4 addresses, two special forms are accepted instead of a host
address: the empty string represents `INADDR_ANY', and the string
`'<broadcast>'' represents `INADDR_BROADCAST'.  The behavior is not
available for IPv6 for backward compatibility, therefore, you may want
to avoid these if you intend to support IPv6 with your Python programs.

If you use a hostname in the HOST portion of IPv4/v6 socket address,
the program may show a nondeterministic behavior, as Python uses the
first address returned from the DNS resolution.  The socket address
will be resolved differently into an actual IPv4/v6 address, depending
on the results from DNS resolution and/or the host configuration.  For
deterministic behavior use a numeric address in HOST portion.

All errors raise exceptions.  The normal exceptions for invalid
argument types and out-of-memory conditions can be raised; errors
related to socket or address semantics raise the error `socket.error'.

Non-blocking mode is supported through `setblocking()'.  A
generalization of this based on timeouts is supported through
`settimeout()'.

The module `socket' exports the following constants and functions:

`error'
     This exception is raised for socket-related errors.  The
     accompanying value is either a string telling what went wrong or a
     pair `(ERRNO, STRING)' representing an error returned by a system
     call, similar to the value accompanying `os.error'.  See the
     module `errno' , which contains names for the error codes defined
     by the underlying operating system.

`herror'
     This exception is raised for address-related errors, i.e. for
     functions that use H_ERRNO in the C API, including
     `gethostbyname_ex()' and `gethostbyaddr()'.

     The accompanying value is a pair `(H_ERRNO, STRING)' representing
     an error returned by a library call. STRING represents the
     description of H_ERRNO, as returned by the `hstrerror()' C
     function.

`gaierror'
     This exception is raised for address-related errors, for
     `getaddrinfo()' and `getnameinfo()'.  The accompanying value is a
     pair `(ERROR, STRING)' representing an error returned by a library
     call.  STRING represents the description of ERROR, as returned by
     the `gai_strerror()' C function.

`timeout'
     This exception is raised when a timeout occurs on a socket which
     has had timeouts enabled via a prior call to `settimeout()'.  The
     accompanying value is a string whose value is currently always
     "timed out".  _Added in Python version 2.3_

`AF_UNIX'

`AF_INET'

`AF_INET6'
     These constants represent the address (and protocol) families,
     used for the first argument to `socket()'.  If the `AF_UNIX'
     constant is not defined then this protocol is unsupported.

`SOCK_STREAM'

`SOCK_DGRAM'

`SOCK_RAW'

`SOCK_RDM'

`SOCK_SEQPACKET'
     These constants represent the socket types, used for the second
     argument to `socket()'.  (Only `SOCK_STREAM' and `SOCK_DGRAM'
     appear to be generally useful.)

`SO_*'

`SOMAXCONN'

`MSG_*'

`SOL_*'

`IPPROTO_*'

`IPPORT_*'

`INADDR_*'

`IP_*'

`IPV6_*'

`EAI_*'

`AI_*'

`NI_*'

`TCP_*'
     Many constants of these forms, documented in the UNIX
     documentation on sockets and/or the IP protocol, are also defined
     in the socket module.  They are generally used in arguments to the
     `setsockopt()' and `getsockopt()' methods of socket objects.  In
     most cases, only those symbols that are defined in the UNIX header
     files are defined; for a few symbols, default values are provided.

`has_ipv6'
     This constant contains a boolean value which indicates if IPv6 is
     supported on this platform.  _Added in Python version 2.3_

`getaddrinfo(host, port[, family[, socktype[, proto[, flags]]]])'
     Resolves the HOST/PORT argument, into a sequence of 5-tuples that
     contain all the necessary argument for the sockets manipulation.
     HOST is a domain name, a string representation of IPv4/v6 address
     or `None'.  PORT is a string service name (like `'http''), a
     numeric port number or `None'.

     The rest of the arguments are optional and must be numeric if
     specified.  For HOST and PORT, by passing either an empty string
     or `None', you can pass `NULL' to the C API.  The `getaddrinfo()'
     function returns a list of 5-tuples with the following structure:

     `(FAMILY, SOCKTYPE, PROTO, CANONNAME, SOCKADDR)'

     FAMILY, SOCKTYPE, PROTO are all integer and are meant to be passed
     to the `socket()' function.  CANONNAME is a string representing
     the canonical name of the HOST.  It can be a numeric IPv4/v6
     address when `AI_CANONNAME' is specified for a numeric HOST.
     SOCKADDR is a tuple describing a socket address, as described
     above.  See the source for the `httplib' and other library modules
     for a typical usage of the function.  _Added in Python version 2.2_

`getfqdn([name])'
     Return a fully qualified domain name for NAME.  If NAME is omitted
     or empty, it is interpreted as the local host.  To find the fully
     qualified name, the hostname returned by `gethostbyaddr()' is
     checked, then aliases for the host, if available.  The first name
     which includes a period is selected.  In case no fully qualified
     domain name is available, the hostname is returned.  _Added in
     Python version 2.0_

`gethostbyname(hostname)'
     Translate a host name to IPv4 address format.  The IPv4 address is
     returned as a string, such as  `'100.50.200.5''.  If the host name
     is an IPv4 address itself it is returned unchanged.  See
     `gethostbyname_ex()' for a more complete interface.
     `gethostbyname()' does not support IPv6 name resolution, and
     `getaddrinfo()' should be used instead for IPv4/v6 dual stack
     support.

`gethostbyname_ex(hostname)'
     Translate a host name to IPv4 address format, extended interface.
     Return a triple `(HOSTNAME, ALIASLIST, IPADDRLIST)' where HOSTNAME
     is the primary host name responding to the given IP_ADDRESS,
     ALIASLIST is a (possibly empty) list of alternative host names for
     the same address, and IPADDRLIST is a list of IPv4 addresses for
     the same interface on the same host (often but not always a single
     address).  `gethostbyname_ex()' does not support IPv6 name
     resolution, and `getaddrinfo()' should be used instead for IPv4/v6
     dual stack support.

`gethostname()'
     Return a string containing the hostname of the machine where the
     Python interpreter is currently executing.  If you want to know
     the current machine's IP address, you may want to use
     `gethostbyname(gethostname())'.  This operation assumes that there
     is a valid address-to-host mapping for the host, and the
     assumption does not always hold.  Note: `gethostname()' doesn't
     always return the fully qualified domain name; use
     `gethostbyaddr(gethostname())' (see below).

`gethostbyaddr(ip_address)'
     Return a triple `(HOSTNAME, ALIASLIST, IPADDRLIST)' where HOSTNAME
     is the primary host name responding to the given IP_ADDRESS,
     ALIASLIST is a (possibly empty) list of alternative host names for
     the same address, and IPADDRLIST is a list of IPv4/v6 addresses
     for the same interface on the same host (most likely containing
     only a single address).  To find the fully qualified domain name,
     use the function `getfqdn()'.  `gethostbyaddr' supports both IPv4
     and IPv6.

`getnameinfo(sockaddr, flags)'
     Translate a socket address SOCKADDR into a 2-tuple `(HOST, PORT)'.
     Depending on the settings of FLAGS, the result can contain a
     fully-qualified domain name or numeric address representation in
     HOST.  Similarly, PORT can contain a string port name or a numeric
     port number.  _Added in Python version 2.2_

`getprotobyname(protocolname)'
     Translate an Internet protocol name (for example, `'icmp'') to a
     constant suitable for passing as the (optional) third argument to
     the `socket()' function.  This is usually only needed for sockets
     opened in "raw" mode (`SOCK_RAW'); for the normal socket modes,
     the correct protocol is chosen automatically if the protocol is
     omitted or zero.

`getservbyname(servicename, protocolname)'
     Translate an Internet service name and protocol name to a port
     number for that service.  The protocol name should be `'tcp'' or
     `'udp''.

`socket(family, type[, proto])'
     Create a new socket using the given address family, socket type and
     protocol number.  The address family should be `AF_INET',
     `AF_INET6' or `AF_UNIX'.  The socket type should be `SOCK_STREAM',
     `SOCK_DGRAM' or perhaps one of the other `SOCK_' constants.  The
     protocol number is usually zero and may be omitted in that case.

`ssl(sock[, keyfile, certfile])'
     Initiate a SSL connection over the socket SOCK. KEYFILE is the
     name of a PEM formatted file that contains your private key.
     CERTFILE is a PEM formatted certificate chain file. On success, a
     new `SSLObject' is returned.

     _This does not do any certificate verification!_

`fromfd(fd, family, type[, proto])'
     Build a socket object from an existing file descriptor (an integer
     as returned by a file object's `fileno()' method).  Address family,
     socket type and protocol number are as for the `socket()' function
     above.  The file descriptor should refer to a socket, but this is
     not checked -- subsequent operations on the object may fail if the
     file descriptor is invalid.  This function is rarely needed, but
     can be used to get or set socket options on a socket passed to a
     program as standard input or output (such as a server started by
     the UNIX inet daemon).  The socket is assumed to be in blocking
     mode.  Availability: UNIX.

`ntohl(x)'
     Convert 32-bit integers from network to host byte order.  On
     machines where the host byte order is the same as network byte
     order, this is a no-op; otherwise, it performs a 4-byte swap
     operation.

`ntohs(x)'
     Convert 16-bit integers from network to host byte order.  On
     machines where the host byte order is the same as network byte
     order, this is a no-op; otherwise, it performs a 2-byte swap
     operation.

`htonl(x)'
     Convert 32-bit integers from host to network byte order.  On
     machines where the host byte order is the same as network byte
     order, this is a no-op; otherwise, it performs a 4-byte swap
     operation.

`htons(x)'
     Convert 16-bit integers from host to network byte order.  On
     machines where the host byte order is the same as network byte
     order, this is a no-op; otherwise, it performs a 2-byte swap
     operation.

`inet_aton(ip_string)'
     Convert an IPv4 address from dotted-quad string format (for
     example, '123.45.67.89') to 32-bit packed binary format, as a
     string four characters in length.  This is useful when conversing
     with a program that uses the standard C library and needs objects
     of type `struct in_addr', which is the C type for the 32-bit packed
     binary this function returns.

     If the IPv4 address string passed to this function is invalid,
     `socket.error' will be raised. Note that exactly what is valid
     depends on the underlying C implementation of `inet_aton()'.

     `inet_aton()' does not support IPv6, and `getnameinfo()' should be
     used instead for IPv4/v6 dual stack support.

`inet_ntoa(packed_ip)'
     Convert a 32-bit packed IPv4 address (a string four characters in
     length) to its standard dotted-quad string representation (for
     example, '123.45.67.89').  This is useful when conversing with a
     program that uses the standard C library and needs objects of type
     `struct in_addr', which is the C type for the 32-bit packed binary
     data this function takes as an argument.

     If the string passed to this function is not exactly 4 bytes in
     length, `socket.error' will be raised.  `inet_ntoa()' does not
     support IPv6, and `getnameinfo()' should be used instead for
     IPv4/v6 dual stack support.

`inet_pton(address_family, ip_string)'
     Convert an IP address from its family-specific string format to a
     packed, binary format.  `inet_pton()' is useful when a library or
     network protocol calls for an object of type `struct in_addr'
     (similar to `inet_aton()') or `struct in6_addr'.

     Supported values for ADDRESS_FAMILY are currently `AF_INET' and
     `AF_INET6'.  If the IP address string IP_STRING is invalid,
     `socket.error' will be raised. Note that exactly what is valid
     depends on both the value of ADDRESS_FAMILY and the underlying
     implementation of `inet_pton()'.

     Availability: UNIX (maybe not all platforms).  _Added in Python
     version 2.3_

`inet_ntop(address_family, packed_ip)'
     Convert a packed IP address (a string of some number of
     characters) to its standard, family-specific string representation
     (for example, `'7.10.0.5'' or `'5aef:2b::8'') `inet_ntop()' is
     useful when a library or network protocol returns an object of
     type `struct in_addr' (similar to `inet_ntoa()') or `struct
     in6_addr'.

     Supported values for ADDRESS_FAMILY are currently `AF_INET' and
     `AF_INET6'.  If the string PACKED_IP is not the correct length for
     the specified address family, `ValueError' will be raised.  A
     `socket.error' is raised for errors from the call to `inet_ntop()'.

     Availability: UNIX (maybe not all platforms).  _Added in Python
     version 2.3_

`getdefaulttimeout()'
     Return the default timeout in floating seconds for new socket
     objects.  A value of `None' indicates that new socket objects have
     no timeout.  When the socket module is first imported, the default
     is `None'.  _Added in Python version 2.3_

`setdefaulttimeout(timeout)'
     Set the default timeout in floating seconds for new socket objects.
     A value of `None' indicates that new socket objects have no
     timeout.  When the socket module is first imported, the default is
     `None'.  _Added in Python version 2.3_

`SocketType'
     This is a Python type object that represents the socket object
     type.  It is the same as `type(socket(...))'.

See also:
     *Note SocketServer:: Classes that simplify writing network servers.

* Menu:

* Socket Objects::
* SSL Objects::
* Example 7::

