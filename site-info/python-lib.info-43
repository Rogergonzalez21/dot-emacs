This is python-lib.info, produced by makeinfo version 4.3 from
python-lib.texi.

October 3, 2003


File: python-lib.info,  Node: Other Graphical User Interface Packages,  Prev: Idle,  Up: Graphical User Interfaces with Tk

Other Graphical User Interface Packages
=======================================

There are an number of extension widget sets to `Tkinter'.

     `Python megawidgets'{is a toolkit for building high-level compound
     widgets in Python using the `Tkinter' module.  It consists of a
     set of base classes and a library of flexible and extensible
     megawidgets built on this foundation. These megawidgets include
     notebooks, comboboxes, selection widgets, paned widgets, scrolled
     widgets, dialog windows, etc.  Also, with the Pmw.Blt interface to
     BLT, the busy, graph, stripchart, tabset and vector commands are
     be available.  The initial ideas for Pmw were taken from the Tk
     `itcl' extensions `[incr Tk]' by Michael McLennan and `[incr
     Widgets]' by Mark Ulferts. Several of the megawidgets are direct
     translations from the itcl to Python. It offers most of the range
     of widgets that `[incr Widgets]' does, and is almost as complete
     as Tix, lacking however Tix's fast `HList' widget for drawing
     trees. }

     `Tkinter3000 Widget Construction Kit (WCK)'{is a library that
     allows you to write new Tkinter widgets in pure Python.  The WCK
     framework gives you full control over widget creation,
     configuration, screen appearance, and event handling.  WCK widgets
     can be very fast and light-weight, since they can operate directly
     on Python data structures, without having to transfer data through
     the Tk/Tcl layer.}

Tk is not the only GUI for Python, but is however the most commonly
used one.

     `wxWindows'{ is a GUI toolkit that combines the most attractive
     attributes of Qt, Tk, Motif, and GTK+ in one powerful and
     efficient package. It is implemented in C++. wxWindows supports
     two flavors of UNIX implementation: GTK+ and Motif, and under
     Windows, it has a standard Microsoft Foundation Classes (MFC)
     appearance, because it uses Win32 widgets.  There is a Python
     class wrapper, independent of Tkinter.  wxWindows is much richer
     in widgets than `Tkinter', with its help system, sophisticated
     HTML and image viewers, and other specialized widgets, extensive
     documentation, and printing capabilities. } `PyQt'{ PyQt is a
     `sip'-wrapped binding to the Qt toolkit.  Qt is an extensive C++
     GUI toolkit that is available for UNIX, Windows and Mac OS X.
     `sip' is a tool for generating bindings for C++ libraries as
     Python classes, and is specifically designed for Python. An online
     manual is available at <http://www.opendocspublishing.com/pyqt/>
     (errata are located at <http://www.valdyas.org/python/book.html>).
     } `PyKDE'{ PyKDE is a `sip'-wrapped interface to the KDE desktop
     libraries.  KDE is a desktop environment for UNIX computers; the
     graphical components are based on Qt. } `FXPy'{ is a Python
     extension module which provides an interface to the  GUI. FOX is a
     C++ based Toolkit for developing Graphical User Interfaces easily
     and effectively. It offers a wide, and growing, collection of
     Controls, and provides state of the art facilities such as drag
     and drop, selection, as well as OpenGL widgets for 3D graphical
     manipulation.  FOX also implements icons, images, and
     user-convenience features such as status line help, and tooltips.
      Even though FOX offers a large collection of controls already,
     FOX leverages C++ to allow programmers to easily build additional
     Controls and GUI elements, simply by taking existing controls, and
     creating a derived class which simply adds or redefines the
     desired behavior. } `PyGTK'{ is a set of bindings for the GTK
     widget set. It provides an object oriented interface that is
     slightly higher level than the C one. It automatically does all
     the type casting and reference counting that you would have to do
     normally with the C API. There are also bindings to  GNOME, and a
     tutorial is available. }


File: python-lib.info,  Node: Restricted Execution,  Next: Python Language Services,  Prev: Graphical User Interfaces with Tk,  Up: Top

Restricted Execution
********************

_Notice:_ [warning] In Python 2.3 these modules have been disabled due
to various known and not readily fixable security holes.  The modules
are still documented here to help in reading old code that uses the
`rexec' and `Bastion' modules.

_Restricted execution_ is the basic framework in Python that allows for
the segregation of trusted and untrusted code.  The framework is based
on the notion that trusted Python code (a _supervisor_) can create a
"padded cell' (or environment) with limited permissions, and run the
untrusted code within this cell.  The untrusted code cannot break out
of its cell, and can only interact with sensitive system resources
through interfaces defined and managed by the trusted code.  The term
"restricted execution" is favored over "safe-Python" since true safety
is hard to define, and is determined by the way the restricted
environment is created.  Note that the restricted environments can be
nested, with inner cells creating subcells of lesser, but never
greater, privilege.

An interesting aspect of Python's restricted execution model is that
the interfaces presented to untrusted code usually have the same names
as those presented to trusted code.  Therefore no special interfaces
need to be learned to write code designed to run in a restricted
environment.  And because the exact nature of the padded cell is
determined by the supervisor, different restrictions can be imposed,
depending on the application.  For example, it might be deemed "safe"
for untrusted code to read any file within a specified directory, but
never to write a file.  In this case, the supervisor may redefine the
built-in `open()' function so that it raises an exception whenever the
MODE parameter is `'w''.  It might also perform a `chroot()'-like
operation on the FILENAME parameter, such that root is always relative
to some safe "sandbox" area of the filesystem.  In this case, the
untrusted code would still see an built-in `open()' function in its
environment, with the same calling interface.  The semantics would be
identical too, with `IOError's being raised when the supervisor
determined that an unallowable parameter is being used.

The Python run-time determines whether a particular code block is
executing in restricted execution mode based on the identity of the
`__builtins__' object in its global variables: if this is (the
dictionary of) the standard `__builtin__' module, the code is deemed to
be unrestricted, else it is deemed to be restricted.

Python code executing in restricted mode faces a number of limitations
that are designed to prevent it from escaping from the padded cell.
For instance, the function object attribute `func_globals' and the
class and instance object attribute `__dict__' are unavailable.

Two modules provide the framework for setting up restricted execution
environments:

See also:
     `Grail Home Page' {Grail, an Internet browser written in Python,
     uses these modules to support Python applets.  More information on
     the use of Python's restricted execution mode in Grail is
     available on the Web site.}

* Menu:

* rexec::
* Bastion::


File: python-lib.info,  Node: rexec,  Next: Bastion,  Prev: Restricted Execution,  Up: Restricted Execution

Restricted execution framework
==============================

Basic restricted execution framework.  _Changed in Python version 2.3_

_Notice:_ [warning] The documentation has been left in place to help in
reading old code that uses the module.

This module contains the `RExec' class, which supports `r_eval()',
`r_execfile()', `r_exec()', and `r_import()' methods, which are
restricted versions of the standard Python functions `eval()',
`execfile()' and the `exec' and `import' statements.  Code executed in
this restricted environment will only have access to modules and
functions that are deemed safe; you can subclass `RExec' to add or
remove capabilities as desired.

_Notice:_ [warning] While the `rexec' module is designed to perform as
described below, it does have a few known vulnerabilities which could be
exploited by carefully written code.  Thus it should not be relied upon
in situations requiring "production ready" security.  In such
situations, execution via sub-processes or very careful "cleansing" of
both code and data to be processed may be necessary.  Alternatively,
help in patching known `rexec' vulnerabilities would be welcomed.

_Notice:_ The `RExec' class can prevent code from performing unsafe
operations like reading or writing disk files, or using TCP/IP sockets.
However, it does not protect against code using extremely large
amounts of memory or processor time.

`RExec([hooks[, verbose]])'
     Returns an instance of the `RExec' class.

     HOOKS is an instance of the `RHooks' class or a subclass of it.
     If it is omitted or `None', the default `RHooks' class is
     instantiated.  Whenever the `rexec' module searches for a module
     (even a built-in one) or reads a module's code, it doesn't
     actually go out to the file system itself.  Rather, it calls
     methods of an `RHooks' instance that was passed to or created by
     its constructor.  (Actually, the `RExec' object doesn't make these
     calls -- they are made by a module loader object that's part of
     the `RExec' object.  This allows another level of flexibility,
     which can be useful when changing the mechanics of `import' within
     the restricted environment.)

     By providing an alternate `RHooks' object, we can control the file
     system accesses made to import a module, without changing the
     actual algorithm that controls the order in which those accesses
     are made.  For instance, we could substitute an `RHooks' object
     that passes all filesystem requests to a file server elsewhere,
     via some RPC mechanism such as ILU.  Grail's applet loader uses
     this to support importing applets from a URL for a directory.

     If VERBOSE is true, additional debugging output may be sent to
     standard output.

It is important to be aware that code running in a restricted
environment can still call the `sys.exit()' function.  To disallow
restricted code from exiting the interpreter, always protect calls that
cause restricted code to run with a `try'/`except' statement that
catches the `SystemExit' exception.  Removing the `sys.exit()' function
from the restricted environment is not sufficient -- the restricted
code could still use `raise SystemExit'.  Removing `SystemExit' is not
a reasonable option; some library code makes use of this and would
break were it not available.

See also:
     `Grail Home Page'{Grail is a Web browser written entirely in
     Python.  It uses the `rexec' module as a foundation for supporting
     Python applets, and can be used as an example usage of this
     module.}

* Menu:

* RExec Objects::
* Defining restricted environments::
* An example::


File: python-lib.info,  Node: RExec Objects,  Next: Defining restricted environments,  Prev: rexec,  Up: rexec

RExec Objects
-------------

`RExec' instances support the following methods:

`r_eval(code)'
     CODE must either be a string containing a Python expression, or a
     compiled code object, which will be evaluated in the restricted
     environment's `__main__' module.  The value of the expression or
     code object will be returned.

`r_exec(code)'
     CODE must either be a string containing one or more lines of
     Python code, or a compiled code object, which will be executed in
     the restricted environment's `__main__' module.

`r_execfile(filename)'
     Execute the Python code contained in the file FILENAME in the
     restricted environment's `__main__' module.

Methods whose names begin with `s_' are similar to the functions
beginning with `r_', but the code will be granted access to restricted
versions of the standard I/O streams `sys.stdin', `sys.stderr', and
`sys.stdout'.

`s_eval(code)'
     CODE must be a string containing a Python expression, which will
     be evaluated in the restricted environment.

`s_exec(code)'
     CODE must be a string containing one or more lines of Python code,
     which will be executed in the restricted environment.

`s_execfile(code)'
     Execute the Python code contained in the file FILENAME in the
     restricted environment.

`RExec' objects must also support various methods which will be
implicitly called by code executing in the restricted environment.
Overriding these methods in a subclass is used to change the policies
enforced by a restricted environment.

`r_import(modulename[, globals[, locals[, fromlist]]])'
     Import the module MODULENAME, raising an `ImportError' exception
     if the module is considered unsafe.

`r_open(filename[, mode[, bufsize]])'
     Method called when `open()' is called in the restricted
     environment.  The arguments are identical to those of `open()',
     and a file object (or a class instance compatible with file
     objects) should be returned.  `RExec''s default behaviour is allow
     opening any file for reading, but forbidding any attempt to write
     a file.  See the example below for an implementation of a less
     restrictive `r_open()'.

`r_reload(module)'
     Reload the module object MODULE, re-parsing and re-initializing it.

`r_unload(module)'
     Unload the module object MODULE (remove it from the restricted
     environment's `sys.modules' dictionary).

And their equivalents with access to restricted standard I/O streams:

`s_import(modulename[, globals[, locals[, fromlist]]])'
     Import the module MODULENAME, raising an `ImportError' exception
     if the module is considered unsafe.

`s_reload(module)'
     Reload the module object MODULE, re-parsing and re-initializing it.

`s_unload(module)'
     Unload the module object MODULE.


File: python-lib.info,  Node: Defining restricted environments,  Next: An example,  Prev: RExec Objects,  Up: rexec

Defining restricted environments
--------------------------------

The `RExec' class has the following class attributes, which are used by
the `__init__()' method.  Changing them on an existing instance won't
have any effect; instead, create a subclass of `RExec' and assign them
new values in the class definition.  Instances of the new class will
then use those new values.  All these attributes are tuples of strings.

`nok_builtin_names'
     Contains the names of built-in functions which will _not_ be
     available to programs running in the restricted environment.  The
     value for `RExec' is `('open', 'reload', '__import__')'.  (This
     gives the exceptions, because by far the majority of built-in
     functions are harmless.  A subclass that wants to override this
     variable should probably start with the value from the base class
     and concatenate additional forbidden functions -- when new
     dangerous built-in functions are added to Python, they will also
     be added to this module.)

`ok_builtin_modules'
     Contains the names of built-in modules which can be safely
     imported.  The value for `RExec' is `('audioop', 'array',
     'binascii', 'cmath', 'errno', 'imageop', 'marshal', 'math', 'md5',
     'operator', 'parser', 'regex', 'rotor', 'select', 'sha', '_sre',
     'strop', 'struct', 'time')'.  A similar remark about overriding
     this variable applies -- use the value from the base class as a
     starting point.

`ok_path'
     Contains the directories which will be searched when an `import'
     is performed in the restricted environment.  The value for `RExec'
     is the same as `sys.path' (at the time the module is loaded) for
     unrestricted code.

`ok_posix_names'
     Contains the names of the functions in the `os' module which will
     be available to programs running in the restricted environment.
     The value for `RExec' is `('error', 'fstat', 'listdir', 'lstat',
     'readlink', 'stat', 'times', 'uname', 'getpid', 'getppid',
     'getcwd', 'getuid', 'getgid', 'geteuid', 'getegid')'.

`ok_sys_names'
     Contains the names of the functions and variables in the `sys'
     module which will be available to programs running in the
     restricted environment.  The value for `RExec' is `('ps1', 'ps2',
     'copyright', 'version', 'platform', 'exit', 'maxint')'.

`ok_file_types'
     Contains the file types from which modules are allowed to be
     loaded.  Each file type is an integer constant defined in the
     `imp' module.  The meaningful values are `PY_SOURCE',
     `PY_COMPILED', and `C_EXTENSION'.  The value for `RExec' is
     `(C_EXTENSION, PY_SOURCE)'.  Adding `PY_COMPILED' in subclasses is
     not recommended; an attacker could exit the restricted execution
     mode by putting a forged byte-compiled file (`.pyc') anywhere in
     your file system, for example by writing it to `/tmp' or uploading
     it to the `/incoming' directory of your public FTP server.


File: python-lib.info,  Node: An example,  Prev: Defining restricted environments,  Up: rexec

An example
----------

Let us say that we want a slightly more relaxed policy than the
standard `RExec' class.  For example, if we're willing to allow files
in `/tmp' to be written, we can subclass the `RExec' class:

     class TmpWriterRExec(rexec.RExec):
         def r_open(self, file, mode='r', buf=-1):
             if mode in ('r', 'rb'):
                 pass
             elif mode in ('w', 'wb', 'a', 'ab'):
                 # check filename : must begin with /tmp/
                 if file[:5]!='/tmp/':
                     raise IOError, "can't write outside /tmp"
                 elif (string.find(file, '/../') >= 0 or
                      file[:3] == '../' or file[-3:] == '/..'):
                     raise IOError, "'..' in filename forbidden"
             else: raise IOError, "Illegal open() mode"
             return open(file, mode, buf)

Notice that the above code will occasionally forbid a perfectly valid
filename; for example, code in the restricted environment won't be able
to open a file called `/tmp/foo/../bar'.  To fix this, the `r_open()'
method would have to simplify the filename to `/tmp/bar', which would
require splitting apart the filename and performing various operations
on it.  In cases where security is at stake, it may be preferable to
write simple code which is sometimes overly restrictive, instead of
more general code that is also more complex and may harbor a subtle
security hole.


File: python-lib.info,  Node: Bastion,  Prev: rexec,  Up: Restricted Execution

Restricting access to objects
=============================

Providing restricted access to objects.

_Changed in Python version 2.3_

_Notice:_ [warning] The documentation has been left in place to help in
reading old code that uses the module.

According to the dictionary, a bastion is "a fortified area or
position", or "something that is considered a stronghold."  It's a
suitable name for this module, which provides a way to forbid access to
certain attributes of an object.  It must always be used with the
`rexec' module, in order to allow restricted-mode programs access to
certain safe attributes of an object, while denying access to other,
unsafe attributes.

`Bastion(object[, filter[, name[, class]]])'
     Protect the object OBJECT, returning a bastion for the object.
     Any attempt to access one of the object's attributes will have to
     be approved by the FILTER function; if the access is denied an
     `AttributeError' exception will be raised.

     If present, FILTER must be a function that accepts a string
     containing an attribute name, and returns true if access to that
     attribute will be permitted; if FILTER returns false, the access
     is denied.  The default filter denies access to any function
     beginning with an underscore (`_').  The bastion's string
     representation will be `<Bastion for NAME>' if a value for NAME is
     provided; otherwise, `repr(OBJECT)' will be used.

     CLASS, if present, should be a subclass of `BastionClass'; see the
     code in `bastion.py' for the details.  Overriding the default
     `BastionClass' will rarely be required.

`BastionClass(getfunc, name)'
     Class which actually implements bastion objects.  This is the
     default class used by `Bastion()'.  The GETFUNC parameter is a
     function which returns the value of an attribute which should be
     exposed to the restricted execution environment when called with
     the name of the attribute as the only parameter.  NAME is used to
     construct the `repr()' of the `BastionClass' instance.


File: python-lib.info,  Node: Python Language Services,  Next: Python compiler package,  Prev: Restricted Execution,  Up: Top

Python Language Services
************************

Python provides a number of modules to assist in working with the
Python language.  These module support tokenizing, parsing, syntax
analysis, bytecode disassembly, and various other facilities.

These modules include:

* Menu:

* parser::
* symbol::
* token::
* keyword::
* tokenize::
* tabnanny::
* pyclbr::
* py_compile::
* compileall::
* dis::
* distutils::


File: python-lib.info,  Node: parser,  Next: symbol,  Prev: Python Language Services,  Up: Python Language Services

Access Python parse trees
=========================

Access parse trees for Python source code.

The `parser' module provides an interface to Python's internal parser
and byte-code compiler.  The primary purpose for this interface is to
allow Python code to edit the parse tree of a Python expression and
create executable code from this.  This is better than trying to parse
and modify an arbitrary Python code fragment as a string because
parsing is performed in a manner identical to the code forming the
application.  It is also faster.

There are a few things to note about this module which are important to
making use of the data structures created.  This is not a tutorial on
editing the parse trees for Python code, but some examples of using the
`parser' module are presented.

Most importantly, a good understanding of the Python grammar processed
by the internal parser is required.  For full information on the
language syntax, refer to the .  The parser itself is created from a
grammar specification defined in the file `Grammar/Grammar' in the
standard Python distribution.  The parse trees stored in the AST
objects created by this module are the actual output from the internal
parser when created by the `expr()' or `suite()' functions, described
below.  The AST objects created by `sequence2ast()' faithfully simulate
those structures.  Be aware that the values of the sequences which are
considered "correct" will vary from one version of Python to another as
the formal grammar for the language is revised.  However, transporting
code from one Python version to another as source text will always
allow correct parse trees to be created in the target version, with the
only restriction being that migrating to an older version of the
interpreter will not support more recent language constructs.  The
parse trees are not typically compatible from one version to another,
whereas source code has always been forward-compatible.

Each element of the sequences returned by `ast2list()' or `ast2tuple()'
has a simple form.  Sequences representing non-terminal elements in the
grammar always have a length greater than one.  The first element is an
integer which identifies a production in the grammar.  These integers
are given symbolic names in the C header file `Include/graminit.h' and
the Python module `symbol'.  Each additional element of the sequence
represents a component of the production as recognized in the input
string: these are always sequences which have the same form as the
parent.  An important aspect of this structure which should be noted is
that keywords used to identify the parent node type, such as the keyword
`if' in an `if_stmt', are included in the node tree without any special
treatment.  For example, the `if' keyword is represented by the tuple
`(1, 'if')', where `1' is the numeric value associated with all `NAME'
tokens, including variable and function names defined by the user.  In
an alternate form returned when line number information is requested,
the same token might be represented as `(1, 'if', 12)', where the `12'
represents the line number at which the terminal symbol was found.

Terminal elements are represented in much the same way, but without any
child elements and the addition of the source text which was
identified.  The example of the `if' keyword above is representative.
The various types of terminal symbols are defined in the C header file
`Include/token.h' and the Python module `token'.

The AST objects are not required to support the functionality of this
module, but are provided for three purposes: to allow an application to
amortize the cost of processing complex parse trees, to provide a parse
tree representation which conserves memory space when compared to the
Python list or tuple representation, and to ease the creation of
additional modules in C which manipulate parse trees.  A simple
"wrapper" class may be created in Python to hide the use of AST objects.

The `parser' module defines functions for a few distinct purposes.  The
most important purposes are to create AST objects and to convert AST
objects to other representations such as parse trees and compiled code
objects, but there are also functions which serve to query the type of
parse tree represented by an AST object.

See also:
     *Note symbol:: Useful constants representing internal nodes of the
     parse tree.  *Note token:: Useful constants representing leaf
     nodes of the parse tree and functions for testing node values.

* Menu:

* Creating AST Objects::
* Converting AST Objects::
* Queries on AST Objects::
* Exceptions and Error Handling::
* AST Objects::
* Examples 12::


File: python-lib.info,  Node: Creating AST Objects,  Next: Converting AST Objects,  Prev: parser,  Up: parser

Creating AST Objects
--------------------

AST objects may be created from source code or from a parse tree.  When
creating an AST object from source, different functions are used to
create the `'eval'' and `'exec'' forms.

`expr(source)'
     The `expr()' function parses the parameter SOURCE as if it were an
     input to `compile(SOURCE, 'file.py', 'eval')'.  If the parse
     succeeds, an AST object is created to hold the internal parse tree
     representation, otherwise an appropriate exception is thrown.

`suite(source)'
     The `suite()' function parses the parameter SOURCE as if it were
     an input to `compile(SOURCE, 'file.py', 'exec')'.  If the parse
     succeeds, an AST object is created to hold the internal parse tree
     representation, otherwise an appropriate exception is thrown.

`sequence2ast(sequence)'
     This function accepts a parse tree represented as a sequence and
     builds an internal representation if possible.  If it can validate
     that the tree conforms to the Python grammar and all nodes are
     valid node types in the host version of Python, an AST object is
     created from the internal representation and returned to the
     called.  If there is a problem creating the internal
     representation, or if the tree cannot be validated, a
     `ParserError' exception is thrown.  An AST object created this way
     should not be assumed to compile correctly; normal exceptions
     thrown by compilation may still be initiated when the AST object
     is passed to `compileast()'.  This may indicate problems not
     related to syntax (such as a `MemoryError' exception), but may
     also be due to constructs such as the result of parsing `del
     f(0)', which escapes the Python parser but is checked by the
     bytecode compiler.

     Sequences representing terminal tokens may be represented as either
     two-element lists of the form `(1, 'name')' or as three-element
     lists of the form `(1, 'name', 56)'.  If the third element is
     present, it is assumed to be a valid line number.  The line number
     may be specified for any subset of the terminal symbols in the
     input tree.

`tuple2ast(sequence)'
     This is the same function as `sequence2ast()'.  This entry point
     is maintained for backward compatibility.


File: python-lib.info,  Node: Converting AST Objects,  Next: Queries on AST Objects,  Prev: Creating AST Objects,  Up: parser

Converting AST Objects
----------------------

AST objects, regardless of the input used to create them, may be
converted to parse trees represented as list- or tuple- trees, or may
be compiled into executable code objects.  Parse trees may be extracted
with or without line numbering information.

`ast2list(ast[, line_info])'
     This function accepts an AST object from the caller in AST and
     returns a Python list representing the equivalent parse tree.  The
     resulting list representation can be used for inspection or the
     creation of a new parse tree in list form.  This function does not
     fail so long as memory is available to build the list
     representation.  If the parse tree will only be used for
     inspection, `ast2tuple()' should be used instead to reduce memory
     consumption and fragmentation.  When the list representation is
     required, this function is significantly faster than retrieving a
     tuple representation and converting that to nested lists.

     If LINE_INFO is true, line number information will be included for
     all terminal tokens as a third element of the list representing
     the token.  Note that the line number provided specifies the line
     on which the token _ends_.  This information is omitted if the
     flag is false or omitted.

`ast2tuple(ast[, line_info])'
     This function accepts an AST object from the caller in AST and
     returns a Python tuple representing the equivalent parse tree.
     Other than returning a tuple instead of a list, this function is
     identical to `ast2list()'.

     If LINE_INFO is true, line number information will be included for
     all terminal tokens as a third element of the list representing
     the token.  This information is omitted if the flag is false or
     omitted.

`compileast(ast[, filename` = '<ast>''])'
     The Python byte compiler can be invoked on an AST object to produce
     code objects which can be used as part of an `exec' statement or a
     call to the built-in `eval()'  function.  This function provides
     the interface to the compiler, passing the internal parse tree
     from AST to the parser, using the source file name specified by
     the FILENAME parameter.  The default value supplied for FILENAME
     indicates that the source was an AST object.

     Compiling an AST object may result in exceptions related to
     compilation; an example would be a `SyntaxError' caused by the
     parse tree for `del f(0)': this statement is considered legal
     within the formal grammar for Python but is not a legal language
     construct.  The `SyntaxError' raised for this condition is
     actually generated by the Python byte-compiler normally, which is
     why it can be raised at this point by the `parser' module.  Most
     causes of compilation failure can be diagnosed programmatically by
     inspection of the parse tree.


File: python-lib.info,  Node: Queries on AST Objects,  Next: Exceptions and Error Handling,  Prev: Converting AST Objects,  Up: parser

Queries on AST Objects
----------------------

Two functions are provided which allow an application to determine if
an AST was created as an expression or a suite.  Neither of these
functions can be used to determine if an AST was created from source
code via `expr()' or `suite()' or from a parse tree via
`sequence2ast()'.

`isexpr(ast)'
     When AST represents an `'eval'' form, this function returns true,
     otherwise it returns false.  This is useful, since code objects
     normally cannot be queried for this information using existing
     built-in functions.  Note that the code objects created by
     `compileast()' cannot be queried like this either, and are
     identical to those created by the built-in `compile()'  function.

`issuite(ast)'
     This function mirrors `isexpr()' in that it reports whether an AST
     object represents an `'exec'' form, commonly known as a "suite."
     It is not safe to assume that this function is equivalent to `not
     isexpr(AST)', as additional syntactic fragments may be supported
     in the future.


File: python-lib.info,  Node: Exceptions and Error Handling,  Next: AST Objects,  Prev: Queries on AST Objects,  Up: parser

Exceptions and Error Handling
-----------------------------

The parser module defines a single exception, but may also pass other
built-in exceptions from other portions of the Python runtime
environment.  See each function for information about the exceptions it
can raise.

`ParserError'
     Exception raised when a failure occurs within the parser module.
     This is generally produced for validation failures rather than the
     built in `SyntaxError' thrown during normal parsing.  The
     exception argument is either a string describing the reason of the
     failure or a tuple containing a sequence causing the failure from
     a parse tree passed to `sequence2ast()' and an explanatory string.
     Calls to `sequence2ast()' need to be able to handle either type
     of exception, while calls to other functions in the module will
     only need to be aware of the simple string values.

Note that the functions `compileast()', `expr()', and `suite()' may
throw exceptions which are normally thrown by the parsing and
compilation process.  These include the built in exceptions
`MemoryError', `OverflowError', `SyntaxError', and `SystemError'.  In
these cases, these exceptions carry all the meaning normally associated
with them.  Refer to the descriptions of each function for detailed
information.


File: python-lib.info,  Node: AST Objects,  Next: Examples 12,  Prev: Exceptions and Error Handling,  Up: parser

AST Objects
-----------

Ordered and equality comparisons are supported between AST objects.
Pickling of AST objects (using the `pickle' module) is also supported.

`ASTType'
     The type of the objects returned by `expr()', `suite()' and
     `sequence2ast()'.

AST objects have the following methods:

`compile([filename])'
     Same as `compileast(AST, FILENAME)'.

`isexpr()'
     Same as `isexpr(AST)'.

`issuite()'
     Same as `issuite(AST)'.

`tolist([line_info])'
     Same as `ast2list(AST, LINE_INFO)'.

`totuple([line_info])'
     Same as `ast2tuple(AST, LINE_INFO)'.


File: python-lib.info,  Node: Examples 12,  Prev: AST Objects,  Up: parser

Examples
--------

The parser modules allows operations to be performed on the parse tree
of Python source code before the bytecode is generated, and provides
for inspection of the parse tree for information gathering purposes.
Two examples are presented.  The simple example demonstrates emulation
of the `compile()'  built-in function and the complex example shows the
use of a parse tree for information discovery.

* Menu:

* Emulation of compile::
* Information Discovery::


File: python-lib.info,  Node: Emulation of compile,  Next: Information Discovery,  Prev: Examples 12,  Up: Examples 12

Emulation of `compile()'
........................

While many useful operations may take place between parsing and
bytecode generation, the simplest operation is to do nothing.  For this
purpose, using the `parser' module to produce an intermediate data
structure is equivalent to the code

     >>> code = compile('a + 5', 'file.py', 'eval')
     >>> a = 5
     >>> eval(code)
     10

The equivalent operation using the `parser' module is somewhat longer,
and allows the intermediate internal parse tree to be retained as an
AST object:

     >>> import parser
     >>> ast = parser.expr('a + 5')
     >>> code = ast.compile('file.py')
     >>> a = 5
     >>> eval(code)
     10

An application which needs both AST and code objects can package this
code into readily available functions:

     import parser
     
     def load_suite(source_string):
         ast = parser.suite(source_string)
         return ast, ast.compile()
     
     def load_expression(source_string):
         ast = parser.expr(source_string)
         return ast, ast.compile()

