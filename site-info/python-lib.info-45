This is python-lib.info, produced by makeinfo version 4.3 from
python-lib.texi.

October 3, 2003


File: python-lib.info,  Node: Python Abstract Syntax,  Next: Using Visitors to Walk ASTs,  Prev: Limitations 2,  Up: Python compiler package

Python Abstract Syntax
======================

The `compiler.ast' module defines an abstract syntax for Python.  In
the abstract syntax tree, each node represents a syntactic construct.
The root of the tree is `Module' object.

The abstract syntax offers a higher level interface to parsed Python
source code.  The `parser' module and the compiler written in C for the
Python interpreter use a concrete syntax tree.  The concrete syntax is
tied closely to the grammar description used for the Python parser.
Instead of a single node for a construct, there are often several
levels of nested nodes that are introduced by Python's precedence rules.

The abstract syntax tree is created by the `compiler.transformer'
module.  The transformer relies on the builtin Python parser to
generate a concrete syntax tree.  It generates an abstract syntax tree
from the concrete tree.

The `transformer' module was created by Greg Stein  and Bill Tutt  for
an experimental Python-to-C compiler.  The current version contains a
number of modifications and improvements, but the basic form of the
abstract syntax and of the transformer are due to Stein and Tutt.

* Menu:

* AST Nodes::
* Assignment nodes::
* Examples 13::


File: python-lib.info,  Node: AST Nodes,  Next: Assignment nodes,  Prev: Python Abstract Syntax,  Up: Python Abstract Syntax

AST Nodes
---------

The `compiler.ast' module is generated from a text file that describes
each node type and its elements.  Each node type is represented as a
class that inherits from the abstract base class `compiler.ast.Node'
and defines a set of named attributes for child nodes.

`Node()'
     The `Node' instances are created automatically by the parser
     generator.  The recommended interface for specific `Node'
     instances is to use the public attributes to access child nodes.  A
     public attribute may be bound to a single node or to a sequence of
     nodes, depending on the `Node' type.  For example, the `bases'
     attribute of the `Class' node, is bound to a list of base class
     nodes, and the `doc' attribute is bound to a single node.

     Each `Node' instance has a `lineno' attribute which may be `None'.
     XXX Not sure what the rules are for which nodes will have a
     useful lineno.

All `Node' objects offer the following methods:

`getChildren()'
     Returns a flattened list of the child nodes and objects in the
     order they occur.  Specifically, the order of the nodes is the
     order in which they appear in the Python grammar.  Not all of the
     children are `Node' instances.  The names of functions and
     classes, for example, are plain strings.

`getChildNodes()'
     Returns a flattened list of the child nodes in the order they
     occur.  This method is like `getChildren()', except that it only
     returns those children that are `Node' instances.

Two examples illustrate the general structure of `Node' classes.  The
`while' statement is defined by the following grammar production:

     while_stmt:     "while" expression ":" suite
                    ["else" ":" suite]

The `While' node has three attributes: `test', `body', and `else_'.
(If the natural name for an attribute is also a Python reserved word,
it can't be used as an attribute name.  An underscore is appended to
the word to make it a legal identifier, hence `else_' instead of
`else'.)

The `if' statement is more complicated because it can include several
tests.

     if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]

The `If' node only defines two attributes: `tests' and `else_'.  The
`tests' attribute is a sequence of test expression, consequent body
pairs.  There is one pair for each `if'/`elif' clause.  The first
element of the pair is the test expression.  The second elements is a
`Stmt' node that contains the code to execute if the test is true.

The `getChildren()' method of `If' returns a flat list of child nodes.
If there are three `if'/`elif' clauses and no `else' clause, then
`getChildren()' will return a list of six elements: the first test
expression, the first `Stmt', the second text expression, etc.

The following table lists each of the `Node' subclasses defined in
`compiler.ast' and each of the public attributes available on their
instances.  The values of most of the attributes are themselves `Node'
instances or sequences of instances.  When the value is something other
than an instance, the type is noted in the comment.  The attributes are
listed in the order in which they are returned by `getChildren()' and
`getChildNodes()'.

Node type                Attribute                Value
------                   -----                    -----
Add                      `left'                   left operand
                         `right'                  right operand
And                      `nodes'                  list of operands
AssAttr                                           _attribute as target of
                                                  assignment_
                         `expr'                   expression on the
                                                  left-hand side of the
                                                  dot
                         `attrname'               the attribute name, a
                                                  string
                         `flags'                  XXX
AssList                  `nodes'                  list of list elements
                                                  being assigned to
AssName                  `name'                   name being assigned to
                         `flags'                  XXX
AssTuple                 `nodes'                  list of tuple elements
                                                  being assigned to
Assert                   `test'                   the expression to be
                                                  tested
                         `fail'                   the value of the
                                                  `AssertionError'
Assign                   `nodes'                  a list of assignment
                                                  targets, one per equal
                                                  sign
                         `expr'                   the value being assigned
AugAssign                `node'                   
                         `op'                     
                         `expr'                   
Backquote                `expr'                   
Bitand                   `nodes'                  
Bitor                    `nodes'                  
Bitxor                   `nodes'                  
Break                                             
CallFunc                 `node'                   expression for the
                                                  callee
                         `args'                   a list of arguments
                         `star_args'              the extended *-arg value
                         `dstar_args'             the extended **-arg
                                                  value
Class                    `name'                   the name of the class,
                                                  a string
                         `bases'                  a list of base classes
                         `doc'                    doc string, a string or
                                                  `None'
                         `code'                   the body of the class
                                                  statement
Compare                  `expr'                   
                         `ops'                    
Const                    `value'                  
Continue                                          
Dict                     `items'                  
Discard                  `expr'                   
Div                      `left'                   
                         `right'                  
Ellipsis                                          
Exec                     `expr'                   
                         `locals'                 
                         `globals'                
For                      `assign'                 
                         `list'                   
                         `body'                   
                         `else_'                  
From                     `modname'                
                         `names'                  
Function                 `name'                   name used in def, a
                                                  string
                         `argnames'               list of argument names,
                                                  as strings
                         `defaults'               list of default values
                         `flags'                  xxx
                         `doc'                    doc string, a string or
                                                  `None'
                         `code'                   the body of the function
Getattr                  `expr'                   
                         `attrname'               
Global                   `names'                  
If                       `tests'                  
                         `else_'                  
Import                   `names'                  
Invert                   `expr'                   
Keyword                  `name'                   
                         `expr'                   
Lambda                   `argnames'               
                         `defaults'               
                         `flags'                  
                         `code'                   
LeftShift                `left'                   
                         `right'                  
List                     `nodes'                  
ListComp                 `expr'                   
                         `quals'                  
ListCompFor              `assign'                 
                         `list'                   
                         `ifs'                    
ListCompIf               `test'                   
Mod                      `left'                   
                         `right'                  
Module                   `doc'                    doc string, a string or
                                                  `None'
                         `node'                   body of the module, a
                                                  `Stmt'
Mul                      `left'                   
                         `right'                  
Name                     `name'                   
Not                      `expr'                   
Or                       `nodes'                  
Pass                                              
Power                    `left'                   
                         `right'                  
Print                    `nodes'                  
                         `dest'                   
Printnl                  `nodes'                  
                         `dest'                   
Raise                    `expr1'                  
                         `expr2'                  
                         `expr3'                  
Return                   `value'                  
RightShift               `left'                   
                         `right'                  
Slice                    `expr'                   
                         `flags'                  
                         `lower'                  
                         `upper'                  
Sliceobj                 `nodes'                  list of statements
Stmt                     `nodes'                  
Sub                      `left'                   
                         `right'                  
Subscript                `expr'                   
                         `flags'                  
                         `subs'                   
TryExcept                `body'                   
                         `handlers'               
                         `else_'                  
TryFinally               `body'                   
                         `final'                  
Tuple                    `nodes'                  
UnaryAdd                 `expr'                   
UnarySub                 `expr'                   
While                    `test'                   
                         `body'                   
                         `else_'                  
Yield                    `value'                  


File: python-lib.info,  Node: Assignment nodes,  Next: Examples 13,  Prev: AST Nodes,  Up: Python Abstract Syntax

Assignment nodes
----------------

There is a collection of nodes used to represent assignments.  Each
assignment statement in the source code becomes a single `Assign' node
in the AST.  The `nodes' attribute is a list that contains a node for
each assignment target.  This is necessary because assignment can be
chained, e.g. `a = b = 2'.  Each `Node' in the list will be one of the
following classes: `AssAttr', `AssList', `AssName', or `AssTuple'.

Each target assignment node will describe the kind of object being
assigned to:  `AssName' for a simple name, e.g. `a = 1'.  `AssAttr' for
an attribute assigned, e.g. `a.x = 1'.  `AssList' and `AssTuple' for
list and tuple expansion respectively, e.g. `a, b, c = a_tuple'.

The target assignment nodes also have a `flags' attribute that
indicates whether the node is being used for assignment or in a delete
statement.  The `AssName' is also used to represent a delete statement,
e.g. `del x'.

When an expression contains several attribute references, an assignment
or delete statement will contain only one `AssAttr' node - for the
final attribute reference.  The other attribute references will be
represented as `Getattr' nodes in the `expr' attribute of the `AssAttr'
instance.


File: python-lib.info,  Node: Examples 13,  Prev: Assignment nodes,  Up: Python Abstract Syntax

Examples
--------

This section shows several simple examples of ASTs for Python source
code.  The examples demonstrate how to use the `parse()' function, what
the repr of an AST looks like, and how to access attributes of an AST
node.

The first module defines a single function.  Assume it is stored in
`/tmp/doublelib.py'.

     """This is an example module.
     
     This is the docstring.
     """
     
     def double(x):
         "Return twice the argument"
         return x * 2

In the interactive interpreter session below, I have reformatted the
long AST reprs for readability.  The AST reprs use unqualified class
names.  If you want to create an instance from a repr, you must import
the class names from the `compiler.ast' module.

     >>> import compiler
     >>> mod = compiler.parseFile("/tmp/doublelib.py")
     >>> mod
     Module('This is an example module.\n\nThis is the docstring.\n',
            Stmt([Function('double', ['x'], [], 0, 'Return twice the argument',
            Stmt([Return(Mul((Name('x'), Const(2))))]))]))
     >>> from compiler.ast import *
     >>> Module('This is an example module.\n\nThis is the docstring.\n',
     ...    Stmt([Function('double', ['x'], [], 0, 'Return twice the argument',
     ...    Stmt([Return(Mul((Name('x'), Const(2))))]))]))
     Module('This is an example module.\n\nThis is the docstring.\n',
            Stmt([Function('double', ['x'], [], 0, 'Return twice the argument',
            Stmt([Return(Mul((Name('x'), Const(2))))]))]))
     >>> mod.doc
     'This is an example module.\n\nThis is the docstring.\n'
     >>> for node in mod.node.nodes:
     ...     print node
     ...
     Function('double', ['x'], [], 0, 'Return twice the argument',
              Stmt([Return(Mul((Name('x'), Const(2))))]))
     >>> func = mod.node.nodes[0]
     >>> func.code
     Stmt([Return(Mul((Name('x'), Const(2))))])


File: python-lib.info,  Node: Using Visitors to Walk ASTs,  Next: Bytecode Generation,  Prev: Python Abstract Syntax,  Up: Python compiler package

Using Visitors to Walk ASTs
===========================

The visitor pattern is ...  The `compiler' package uses a variant on
the visitor pattern that takes advantage of Python's introspection
features to elminiate the need for much of the visitor's infrastructure.

The classes being visited do not need to be programmed to accept
visitors.  The visitor need only define visit methods for classes it is
specifically interested in; a default visit method can handle the rest.

XXX The magic `visit()' method for visitors.

`walk(tree, visitor[, verbose])'

`ASTVisitor()'
     The `ASTVisitor' is responsible for walking over the tree in the
     correct order.  A walk begins with a call to `preorder()'.  For
     each node, it checks the VISITOR argument to `preorder()' for a
     method named `visitNodeType,' where NodeType is the name of the
     node's class, e.g. for a `While' node a `visitWhile()' would be
     called.  If the method exists, it is called with the node as its
     first argument.

     The visitor method for a particular node type can control how child
     nodes are visited during the walk.  The `ASTVisitor' modifies the
     visitor argument by adding a visit method to the visitor; this
     method can be used to visit a particular child node.  If no
     visitor is found for a particular node type, the `default()'
     method is called.

`ASTVisitor' objects have the following methods:

XXX describe extra arguments

`default(node[, ...])'

`dispatch(node[, ...])'

`preorder(tree, visitor)'

File: python-lib.info,  Node: Bytecode Generation,  Prev: Using Visitors to Walk ASTs,  Up: Python compiler package

Bytecode Generation
===================

The code generator is a visitor that emits bytecodes.  Each visit method
can call the `emit()' method to emit a new bytecode.  The basic code
generator is specialized for modules, classes, and functions.  An
assembler converts that emitted instructions to the low-level bytecode
format.  It handles things like generator of constant lists of code
objects and calculation of jump offsets.


File: python-lib.info,  Node: SGI IRIX Specific Services,  Next: SunOS Specific Services,  Prev: Python compiler package,  Up: Top

SGI IRIX Specific Services
**************************

The modules described in this chapter provide interfaces to features
that are unique to SGI's IRIX operating system (versions 4 and 5).

* Menu:

* al::
* AL::
* cd::
* fl::
* FL::
* flp::
* fm::
* gl::
* DEVICE::
* GL::
* imgfile::
* jpeg::


File: python-lib.info,  Node: al,  Next: AL,  Prev: SGI IRIX Specific Services,  Up: SGI IRIX Specific Services

Audio functions on the SGI
==========================

Audio functions on the SGI.

This module provides access to the audio facilities of the SGI Indy and
Indigo workstations.  See section 3A of the IRIX man pages for details.
You'll need to read those man pages to understand what these functions
do!  Some of the functions are not available in IRIX releases before
4.0.5.  Again, see the manual to check whether a specific function is
available on your platform.

All functions and methods defined in this module are equivalent to the
C functions with `AL' prefixed to their name.

Symbolic constants from the C header file `<audio.h>' are defined in
the standard module `AL' , see below.

_The current version of the audio library may dump core when bad
argument values are passed rather than returning an error status.
Unfortunately, since the precise circumstances under which this may
happen are undocumented and hard to check, the Python interface can
provide no protection against this kind of problems. (One example is
specifying an excessive queue size -- there is no documented upper
limit.)_

The module defines the following functions:

`openport(name, direction[, config])'
     The name and direction arguments are strings.  The optional CONFIG
     argument is a configuration object as returned by `newconfig()'.
     The return value is an "audio port object"; methods of audio port
     objects are described below.

`newconfig()'
     The return value is a new "audio configuration object"; methods of
     audio configuration objects are described below.

`queryparams(device)'
     The device argument is an integer.  The return value is a list of
     integers containing the data returned by `ALqueryparams()'.

`getparams(device, list)'
     The DEVICE argument is an integer.  The list argument is a list
     such as returned by `queryparams()'; it is modified in place (!).

`setparams(device, list)'
     The DEVICE argument is an integer.  The LIST argument is a list
     such as returned by `queryparams()'.

* Menu:

* Configuration Objects::
* Port Objects::


File: python-lib.info,  Node: Configuration Objects,  Next: Port Objects,  Prev: al,  Up: al

Configuration Objects
---------------------

Configuration objects returned by `newconfig()' have the following
methods:

`getqueuesize()'
     Return the queue size.

`setqueuesize(size)'
     Set the queue size.

`getwidth()'
     Get the sample width.

`setwidth(width)'
     Set the sample width.

`getchannels()'
     Get the channel count.

`setchannels(nchannels)'
     Set the channel count.

`getsampfmt()'
     Get the sample format.

`setsampfmt(sampfmt)'
     Set the sample format.

`getfloatmax()'
     Get the maximum value for floating sample formats.

`setfloatmax(floatmax)'
     Set the maximum value for floating sample formats.


File: python-lib.info,  Node: Port Objects,  Prev: Configuration Objects,  Up: al

Port Objects
------------

Port objects, as returned by `openport()', have the following methods:

`closeport()'
     Close the port.

`getfd()'
     Return the file descriptor as an int.

`getfilled()'
     Return the number of filled samples.

`getfillable()'
     Return the number of fillable samples.

`readsamps(nsamples)'
     Read a number of samples from the queue, blocking if necessary.
     Return the data as a string containing the raw data, (e.g., 2
     bytes per sample in big-endian byte order (high byte, low byte) if
     you have set the sample width to 2 bytes).

`writesamps(samples)'
     Write samples into the queue, blocking if necessary.  The samples
     are encoded as described for the `readsamps()' return value.

`getfillpoint()'
     Return the `fill point'.

`setfillpoint(fillpoint)'
     Set the `fill point'.

`getconfig()'
     Return a configuration object containing the current configuration
     of the port.

`setconfig(config)'
     Set the configuration from the argument, a configuration object.

`getstatus(list)'
     Get status information on last error.


File: python-lib.info,  Node: AL,  Next: cd,  Prev: al,  Up: SGI IRIX Specific Services

Constants used with the `al' module
===================================

Constants used with the `al' module.

This module defines symbolic constants needed to use the built-in
module `al' (see above); they are equivalent to those defined in the C
header file `<audio.h>' except that the name prefix `AL_' is omitted.
Read the module source for a complete list of the defined names.
Suggested use:

     import al
     from AL import *


File: python-lib.info,  Node: cd,  Next: fl,  Prev: AL,  Up: SGI IRIX Specific Services

CD-ROM access on SGI systems
============================

Interface to the CD-ROM on Silicon Graphics systems.

This module provides an interface to the Silicon Graphics CD library.
It is available only on Silicon Graphics systems.

The way the library works is as follows.  A program opens the CD-ROM
device with `open()' and creates a parser to parse the data from the CD
with `createparser()'.  The object returned by `open()' can be used to
read data from the CD, but also to get status information for the
CD-ROM device, and to get information about the CD, such as the table
of contents.  Data from the CD is passed to the parser, which parses
the frames, and calls any callback functions that have previously been
added.

An audio CD is divided into "tracks" or "programs" (the terms are used
interchangeably).  Tracks can be subdivided into "indices".  An audio
CD contains a "table of contents" which gives the starts of the tracks
on the CD.  Index 0 is usually the pause before the start of a track.
The start of the track as given by the table of contents is normally
the start of index 1.

Positions on a CD can be represented in two ways.  Either a frame
number or a tuple of three values, minutes, seconds and frames.  Most
functions use the latter representation.  Positions can be both
relative to the beginning of the CD, and to the beginning of the track.

Module `cd' defines the following functions and constants:

`createparser()'
     Create and return an opaque parser object.  The methods of the
     parser object are described below.

`msftoframe(minutes, seconds, frames)'
     Converts a `(MINUTES, SECONDS, FRAMES)' triple representing time
     in absolute time code into the corresponding CD frame number.

`open([device[, mode]])'
     Open the CD-ROM device.  The return value is an opaque player
     object; methods of the player object are described below.  The
     device is the name of the SCSI device file, e.g.
     `'/dev/scsi/sc0d4l0'', or `None'.  If omitted or `None', the
     hardware inventory is consulted to locate a CD-ROM drive.  The
     MODE, if not omited, should be the string `'r''.

The module defines the following variables:

`error'
     Exception raised on various errors.

`DATASIZE'
     The size of one frame's worth of audio data.  This is the size of
     the audio data as passed to the callback of type `audio'.

`BLOCKSIZE'
     The size of one uninterpreted frame of audio data.

The following variables are states as returned by `getstatus()':

`READY'
     The drive is ready for operation loaded with an audio CD.

`NODISC'
     The drive does not have a CD loaded.

`CDROM'
     The drive is loaded with a CD-ROM.  Subsequent play or read
     operations will return I/O errors.

`ERROR'
     An error occurred while trying to read the disc or its table of
     contents.

`PLAYING'
     The drive is in CD player mode playing an audio CD through its
     audio jacks.

`PAUSED'
     The drive is in CD layer mode with play paused.

`STILL'
     The equivalent of `PAUSED' on older (non 3301) model Toshiba
     CD-ROM drives.  Such drives have never been shipped by SGI.

`audio'

`pnum'

`index'

`ptime'

`atime'

`catalog'

`ident'

`control'
     Integer constants describing the various types of parser callbacks
     that can be set by the `addcallback()' method of CD parser objects
     (see below).

* Menu:

* Player Objects::
* Parser Objects::


File: python-lib.info,  Node: Player Objects,  Next: Parser Objects,  Prev: cd,  Up: cd

Player Objects
--------------

Player objects (returned by `open()') have the following methods:

`allowremoval()'
     Unlocks the eject button on the CD-ROM drive permitting the user to
     eject the caddy if desired.

`bestreadsize()'
     Returns the best value to use for the NUM_FRAMES parameter of the
     `readda()' method.  Best is defined as the value that permits a
     continuous flow of data from the CD-ROM drive.

`close()'
     Frees the resources associated with the player object.  After
     calling `close()', the methods of the object should no longer be
     used.

`eject()'
     Ejects the caddy from the CD-ROM drive.

`getstatus()'
     Returns information pertaining to the current state of the CD-ROM
     drive.  The returned information is a tuple with the following
     values: STATE, TRACK, RTIME, ATIME, TTIME, FIRST, LAST,
     SCSI_AUDIO, CUR_BLOCK.  RTIME is the time relative to the start of
     the current track; ATIME is the time relative to the beginning of
     the disc; TTIME is the total time on the disc.  For more
     information on the meaning of the values, see the man page
     `CDgetstatus(3dm)'.  The value of STATE is one of the following:
     `ERROR', `NODISC', `READY', `PLAYING', `PAUSED', `STILL', or
     `CDROM'.

`gettrackinfo(track)'
     Returns information about the specified track.  The returned
     information is a tuple consisting of two elements, the start time
     of the track and the duration of the track.

`msftoblock(min, sec, frame)'
     Converts a minutes, seconds, frames triple representing a time in
     absolute time code into the corresponding logical block number for
     the given CD-ROM drive.  You should use `msftoframe()' rather than
     `msftoblock()' for comparing times.  The logical block number
     differs from the frame number by an offset required by certain
     CD-ROM drives.

`play(start, play)'
     Starts playback of an audio CD in the CD-ROM drive at the specified
     track.  The audio output appears on the CD-ROM drive's headphone
     and audio jacks (if fitted).  Play stops at the end of the disc.
     START is the number of the track at which to start playing the CD;
     if PLAY is 0, the CD will be set to an initial paused state.  The
     method `togglepause()' can then be used to commence play.

`playabs(minutes, seconds, frames, play)'
     Like `play()', except that the start is given in minutes, seconds,
     and frames instead of a track number.

`playtrack(start, play)'
     Like `play()', except that playing stops at the end of the track.

`playtrackabs(track, minutes, seconds, frames, play)'
     Like `play()', except that playing begins at the specified
     absolute time and ends at the end of the specified track.

`preventremoval()'
     Locks the eject button on the CD-ROM drive thus preventing the user
     from arbitrarily ejecting the caddy.

`readda(num_frames)'
     Reads the specified number of frames from an audio CD mounted in
     the CD-ROM drive.  The return value is a string representing the
     audio frames.  This string can be passed unaltered to the
     `parseframe()' method of the parser object.

`seek(minutes, seconds, frames)'
     Sets the pointer that indicates the starting point of the next
     read of digital audio data from a CD-ROM.  The pointer is set to
     an absolute time code location specified in MINUTES, SECONDS, and
     FRAMES.  The return value is the logical block number to which the
     pointer has been set.

`seekblock(block)'
     Sets the pointer that indicates the starting point of the next
     read of digital audio data from a CD-ROM.  The pointer is set to
     the specified logical block number.  The return value is the
     logical block number to which the pointer has been set.

`seektrack(track)'
     Sets the pointer that indicates the starting point of the next
     read of digital audio data from a CD-ROM.  The pointer is set to
     the specified track.  The return value is the logical block number
     to which the pointer has been set.

`stop()'
     Stops the current playing operation.

`togglepause()'
     Pauses the CD if it is playing, and makes it play if it is paused.


File: python-lib.info,  Node: Parser Objects,  Prev: Player Objects,  Up: cd

Parser Objects
--------------

Parser objects (returned by `createparser()') have the following
methods:

`addcallback(type, func, arg)'
     Adds a callback for the parser.  The parser has callbacks for eight
     different types of data in the digital audio data stream.
     Constants for these types are defined at the `cd' module level
     (see above).  The callback is called as follows: `FUNC(ARG, type,
     data)', where ARG is the user supplied argument, TYPE is the
     particular type of callback, and DATA is the data returned for
     this TYPE of callback.  The type of the data depends on the TYPE
     of callback as follows:

     Type                               Value
     ------                             -----
     audio                              String which can be passed
                                        unmodified to `al.writesamps()'.
     pnum                               Integer giving the program
                                        (track) number.
     index                              Integer giving the index number.
     ptime                              Tuple consisting of the program
                                        time in minutes, seconds, and
                                        frames.
     atime                              Tuple consisting of the absolute
                                        time in minutes, seconds, and
                                        frames.
     catalog                            String of 13 characters, giving
                                        the catalog number of the CD.
     ident                              String of 12 characters, giving
                                        the ISRC identification number of
                                        the recording.  The string
                                        consists of two characters
                                        country code, three characters
                                        owner code, two characters giving
                                        the year, and five characters
                                        giving a serial number.
     control                            Integer giving the control bits
                                        from the CD subcode data

`deleteparser()'
     Deletes the parser and frees the memory it was using.  The object
     should not be used after this call.  This call is done
     automatically when the last reference to the object is removed.

`parseframe(frame)'
     Parses one or more frames of digital audio data from a CD such as
     returned by `readda()'.  It determines which subcodes are present
     in the data.  If these subcodes have changed since the last frame,
     then `parseframe()' executes a callback of the appropriate type
     passing to it the subcode data found in the frame.  Unlike the C
     function, more than one frame of digital audio data can be passed
     to this method.

`removecallback(type)'
     Removes the callback for the given TYPE.

`resetparser()'
     Resets the fields of the parser used for tracking subcodes to an
     initial state.  `resetparser()' should be called after the disc
     has been changed.


File: python-lib.info,  Node: fl,  Next: FL,  Prev: cd,  Up: SGI IRIX Specific Services

FORMS library for graphical user interfaces
===========================================

FORMS library for applications with graphical user interfaces.

This module provides an interface to the FORMS Library  by Mark Overmars
.  The source for the library can be retrieved by anonymous ftp from
host `ftp.cs.ruu.nl', directory `SGI/FORMS'.  It was last tested with
version 2.0b.

Most functions are literal translations of their C equivalents,
dropping the initial `fl_' from their name.  Constants used by the
library are defined in module `FL' described below.

The creation of objects is a little different in Python than in C:
instead of the `current form' maintained by the library to which new
FORMS objects are added, all functions that add a FORMS object to a
form are methods of the Python object representing the form.
Consequently, there are no Python equivalents for the C functions
`fl_addto_form()' and `fl_end_form()', and the equivalent of
`fl_bgn_form()' is called `fl.make_form()'.

Watch out for the somewhat confusing terminology: FORMS uses the word
"object" for the buttons, sliders etc. that you can place in a form.
In Python, `object' means any value.  The Python interface to FORMS
introduces two new Python object types: form objects (representing an
entire form) and FORMS objects (representing one button, slider etc.).
Hopefully this isn't too confusing.

There are no `free objects' in the Python interface to FORMS, nor is
there an easy way to add object classes written in Python.  The FORMS
interface to GL event handling is available, though, so you can mix
FORMS with pure GL windows.

*Please note:* importing `fl' implies a call to the GL function
`foreground()' and to the FORMS routine `fl_init()'.

* Menu:

* FL Functions::
* Form Objects::
* FORMS Objects::


File: python-lib.info,  Node: FL Functions,  Next: Form Objects,  Prev: fl,  Up: fl

Functions Defined in Module `fl'
--------------------------------

Module `fl' defines the following functions.  For more information
about what they do, see the description of the equivalent C function in
the FORMS documentation:

`make_form(type, width, height)'
     Create a form with given type, width and height.  This returns a
     "form" object, whose methods are described below.

`do_forms()'
     The standard FORMS main loop.  Returns a Python object representing
     the FORMS object needing interaction, or the special value
     `FL.EVENT'.

`check_forms()'
     Check for FORMS events.  Returns what `do_forms()' above returns,
     or `None' if there is no event that immediately needs interaction.

`set_event_call_back(function)'
     Set the event callback function.

`set_graphics_mode(rgbmode, doublebuffering)'
     Set the graphics modes.

`get_rgbmode()'
     Return the current rgb mode.  This is the value of the C global
     variable `fl_rgbmode'.

`show_message(str1, str2, str3)'
     Show a dialog box with a three-line message and an OK button.

`show_question(str1, str2, str3)'
     Show a dialog box with a three-line message and YES and NO buttons.
     It returns `1' if the user pressed YES, `0' if NO.

`show_choice(str1, str2, str3, but1[, but2[, but3]])'
     Show a dialog box with a three-line message and up to three
     buttons.  It returns the number of the button clicked by the user
     (`1', `2' or `3').

`show_input(prompt, default)'
     Show a dialog box with a one-line prompt message and text field in
     which the user can enter a string.  The second argument is the
     default input string.  It returns the string value as edited by
     the user.

`show_file_selector(message, directory, pattern, default)'
     Show a dialog box in which the user can select a file.  It returns
     the absolute filename selected by the user, or `None' if the user
     presses Cancel.

`get_directory()'

`get_pattern'

`get_filename'
     These functions return the directory, pattern and filename (the
     tail part only) selected by the user in the last
     `show_file_selector()' call.

`qdevice(dev)'

`unqdevice dev'

`isqueued dev'

`qtest'

`qread'

`qreset'

`qenter dev, val'

`get_mouse'

`tie button, valuator1, valuator2'
     These functions are the FORMS interfaces to the corresponding GL
     functions.  Use these if you want to handle some GL events yourself
     when using `fl.do_events()'.  When a GL event is detected that
     FORMS cannot handle, `fl.do_forms()' returns the special value
     `FL.EVENT' and you should call `fl.qread()' to read the event from
     the queue.  Don't use the equivalent GL functions!

`color()'

`mapcolor'

`getmcolor'
     See the description in the FORMS documentation of `fl_color()',
     `fl_mapcolor()' and `fl_getmcolor()'.


File: python-lib.info,  Node: Form Objects,  Next: FORMS Objects,  Prev: FL Functions,  Up: fl

Form Objects
------------

Form objects (returned by `make_form()' above) have the following
methods.  Each method corresponds to a C function whose name is
prefixed with `fl_'; and whose first argument is a form pointer; please
refer to the official FORMS documentation for descriptions.

All the `add_*()' methods return a Python object representing the FORMS
object.  Methods of FORMS objects are described below.  Most kinds of
FORMS object also have some methods specific to that kind; these
methods are listed here.

`show_form(placement, bordertype, name)'
     Show the form.

`hide_form()'
     Hide the form.

`redraw_form()'
     Redraw the form.

`set_form_position(x, y)'
     Set the form's position.

`freeze_form()'
     Freeze the form.

`unfreeze_form()'
     Unfreeze the form.

`activate_form()'
     Activate the form.

`deactivate_form()'
     Deactivate the form.

`bgn_group()'
     Begin a new group of objects; return a group object.

`end_group()'
     End the current group of objects.

`find_first()'
     Find the first object in the form.

`find_last()'
     Find the last object in the form.

`add_box(type, x, y, w, h, name)'
     Add a box object to the form.  No extra methods.

`add_text(type, x, y, w, h, name)'
     Add a text object to the form.  No extra methods.

`add_clock(type, x, y, w, h, name)'
     Add a clock object to the form. \ Method: `get_clock()'.

`add_button(type, x, y, w, h,  name)'
     Add a button object to the form. \ Methods: `get_button()',
     `set_button()'.

`add_lightbutton(type, x, y, w, h, name)'
     Add a lightbutton object to the form. \ Methods: `get_button()',
     `set_button()'.

`add_roundbutton(type, x, y, w, h, name)'
     Add a roundbutton object to the form. \ Methods: `get_button()',
     `set_button()'.

`add_slider(type, x, y, w, h, name)'
     Add a slider object to the form. \ Methods: `set_slider_value()',
     `get_slider_value()', `set_slider_bounds()', `get_slider_bounds()',
     `set_slider_return()', `set_slider_size()',
     `set_slider_precision()', `set_slider_step()'.

`add_valslider(type, x, y, w, h, name)'
     Add a valslider object to the form. \ Methods:
     `set_slider_value()', `get_slider_value()', `set_slider_bounds()',
     `get_slider_bounds()', `set_slider_return()', `set_slider_size()',
     `set_slider_precision()', `set_slider_step()'.

`add_dial(type, x, y, w, h, name)'
     Add a dial object to the form. \ Methods: `set_dial_value()',
     `get_dial_value()', `set_dial_bounds()', `get_dial_bounds()'.

`add_positioner(type, x, y, w, h, name)'
     Add a positioner object to the form. \ Methods:
     `set_positioner_xvalue()', `set_positioner_yvalue()',
     `set_positioner_xbounds()', `set_positioner_ybounds()',
     `get_positioner_xvalue()', `get_positioner_yvalue()',
     `get_positioner_xbounds()', `get_positioner_ybounds()'.

`add_counter(type, x, y, w, h, name)'
     Add a counter object to the form. \ Methods: `set_counter_value()',
     `get_counter_value()', `set_counter_bounds()',
     `set_counter_step()', `set_counter_precision()',
     `set_counter_return()'.

`add_input(type, x, y, w, h, name)'
     Add a input object to the form. \ Methods: `set_input()',
     `get_input()', `set_input_color()', `set_input_return()'.

`add_menu(type, x, y, w, h, name)'
     Add a menu object to the form. \ Methods: `set_menu()',
     `get_menu()', `addto_menu()'.

`add_choice(type, x, y, w, h, name)'
     Add a choice object to the form. \ Methods: `set_choice()',
     `get_choice()', `clear_choice()', `addto_choice()',
     `replace_choice()', `delete_choice()', `get_choice_text()',
     `set_choice_fontsize()', `set_choice_fontstyle()'.

`add_browser(type, x, y, w, h, name)'
     Add a browser object to the form. \ Methods:
     `set_browser_topline()', `clear_browser()', `add_browser_line()',
     `addto_browser()', `insert_browser_line()',
     `delete_browser_line()', `replace_browser_line()',
     `get_browser_line()', `load_browser()', `get_browser_maxline()',
     `select_browser_line()', `deselect_browser_line()',
     `deselect_browser()', `isselected_browser_line()', `get_browser()',
     `set_browser_fontsize()', `set_browser_fontstyle()',
     `set_browser_specialkey()'.

`add_timer(type, x, y, w, h, name)'
     Add a timer object to the form. \ Methods: `set_timer()',
     `get_timer()'.

Form objects have the following data attributes; see the FORMS
documentation:

Name                     C Type                   Meaning
------                   -----                    -----
window                   int (read-only)          GL window id
w                        float                    form width
h                        float                    form height
x                        float                    form x origin
y                        float                    form y origin
deactivated              int                      nonzero if form is
                                                  deactivated
visible                  int                      nonzero if form is
                                                  visible
frozen                   int                      nonzero if form is
                                                  frozen
doublebuf                int                      nonzero if double
                                                  buffering on


File: python-lib.info,  Node: FORMS Objects,  Prev: Form Objects,  Up: fl

FORMS Objects
-------------

Besides methods specific to particular kinds of FORMS objects, all
FORMS objects also have the following methods:

`set_call_back(function, argument)'
     Set the object's callback function and argument.  When the object
     needs interaction, the callback function will be called with two
     arguments: the object, and the callback argument.  (FORMS objects
     without a callback function are returned by `fl.do_forms()' or
     `fl.check_forms()' when they need interaction.)  Call this method
     without arguments to remove the callback function.

`delete_object()'
     Delete the object.

`show_object()'
     Show the object.

`hide_object()'
     Hide the object.

`redraw_object()'
     Redraw the object.

`freeze_object()'
     Freeze the object.

`unfreeze_object()'
     Unfreeze the object.

FORMS objects have these data attributes; see the FORMS documentation:

Name                     C Type                   Meaning
------                   -----                    -----
objclass                 int (read-only)          object class
type                     int (read-only)          object type
boxtype                  int                      box type
x                        float                    x origin
y                        float                    y origin
w                        float                    width
h                        float                    height
col1                     int                      primary color
col2                     int                      secondary color
align                    int                      alignment
lcol                     int                      label color
lsize                    float                    label font size
label                    string                   label string
lstyle                   int                      label style
pushed                   int (read-only)          (see FORMS docs)
focus                    int (read-only)          (see FORMS docs)
belowmouse               int (read-only)          (see FORMS docs)
frozen                   int (read-only)          (see FORMS docs)
active                   int (read-only)          (see FORMS docs)
input                    int (read-only)          (see FORMS docs)
visible                  int (read-only)          (see FORMS docs)
radio                    int (read-only)          (see FORMS docs)
automatic                int (read-only)          (see FORMS docs)


File: python-lib.info,  Node: FL,  Next: flp,  Prev: fl,  Up: SGI IRIX Specific Services

Constants used with the `fl' module
===================================

Constants used with the `fl' module.

This module defines symbolic constants needed to use the built-in
module `fl' (see above); they are equivalent to those defined in the C
header file `<forms.h>' except that the name prefix `FL_' is omitted.
Read the module source for a complete list of the defined names.
Suggested use:

     import fl
     from FL import *


File: python-lib.info,  Node: flp,  Next: fm,  Prev: FL,  Up: SGI IRIX Specific Services

Functions for loading stored FORMS designs
==========================================

Functions for loading stored FORMS designs.

This module defines functions that can read form definitions created by
the `form designer' (`fdesign') program that comes with the FORMS
library (see module `fl' above).

For now, see the file `flp.doc' in the Python library source directory
for a description.

XXX A complete description should be inserted here!

